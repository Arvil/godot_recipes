[{"content":"Here you can find the most recently added recipes:\nLine2D Collision KinematicBody: Stopping on Slopes Rolling Cube 8-Directional Movement/Animation Know Your Nodes: RigidBody2D Arcade-style 3D Spaceship Know Your Nodes: YSort Know Your Nodes: RayCast2D Know Your Nodes: Path2D \u0026 PathFollow2D Add “Know Your Nodes” section Simplified Airplane Controller Interpolated Camera ","description":"","tags":null,"title":"Fresh Recipes","uri":"/godot_recipes/3.x/recent/"},{"content":"Getting Started Have you downloaded Godot yet? You can get it here: https://godotengine.org\nIn this section: What is Godot? Godot's Editor: Finding your way around Nodes: Godot's building blocks ","description":"","tags":null,"title":"Getting Started","uri":"/godot_recipes/3.x/g101/start/"},{"content":"In this tutorial, we’ll look at how to start working in 3D in Godot. You’ll learn how to navigate in the 3D editor, how to create and manipulate 3D objects, and how to work with some of Godot’s essential 3D nodes, such as cameras and lighting.\nAre you ready? A word of warning: 3D development can be quite a bit more complex than working in 2D. While many of the same principles apply - such as working with nodes, writing scripts, and handling logic/data - 3D brings with it a number of other considerations. For this reason, it’s a good idea to stick to 2D for your first few projects, moving to 3D once you have a good understanding of the game development process. This tutorial will assume you have completed at least an introductory Godot 2D project, such as the one in the [official Godot tutorial] (https://docs.godotengine.org/en/stable/getting_started/step_by_step/your_first_game.html).\nGetting Started in 3D One of Godot’s strengths is its ability to handle both 2D and 3D games. While much of what you’ve learned working on 2D projects (nodes, scenes, signals, etc.) applies equally well in 3D, there is also a whole new layer of complexity and capabilities. First, you’ll find that there are some additional features available in the 3D editor window, so we’ll start there:\nOrienting in 3D Space When you first open a new project in Godot, you will see the 3D project view:\nThe first thing you should notice is the three colored lines in the center. These are the x (red), y (green), and z (blue) axes. The point where they meet is the origin, which has the coordinates (0, 0, 0). You’ll find that this color scheme will also apply elsewhere in the Inspector.\nNote Different 3D applications follow different conventions for orientation. Godot uses Y-Up orientation, so that when looking at the axes, if x is pointing to the left/right, then y is up/down, and z is forward/back. Some other popular 3D software uses Z-UP. It’s good to keep this in mind when moving between applications.\nNavigation in 3D is performed using the mouse and keyboard. Here are the basic controls for the view camera:\nMousewheel up/down: zoom in/out Middle button + drag: orbit camera around current target Shift + middle button + drag: pan camera Right-click + drag: rotate camera in place In addition, if you’re familiar with popular 3D games, you might prefer Freelook mode, which you can toggle on/off using Shift+F. In this mode, you can use the WASD keys to fly around the scene while aiming with the mouse.\nYou can also alter the camera’s view by clicking on the [Perspective] label in the upper-left corner. Here, you can snap the camera to a particular orientation.\nAdding 3D Objects Now let’s add our first 3D node. Just as all 2D nodes inherit from Node2D, which provides properties such as position and rotation, 3D nodes inherit from Spatial. Add one to your scene and you’ll see the following object appear at the origin:\nThis object is not the node. It is something called a 3D gizmo. Gizmos are tools that allow you to move and rotate objects in space. The three rings control rotation, while the three arrows move (translate) the object along the three axes. Note that the rings and arrows are color-coded to match the axis colors.\nTake a few minutes to experiment and get familiar with the gizmo. Use Undo if you find yourself getting lost.\nTip Sometimes you may feel the gizmos are getting in your way. You can click on the mode icons to restrict yourself to only one type of transformation: move, rotate, or scale: Global vs. Local Space By default, the gizmo controls operate in global space. When you rotate the object, the gizmo’s arrows still point along the axes. However, if you click the “Local Space Mode” button, the gizmo will switch to moving the body in local space.\nNow when you rotate the object, the gizmo arrows point along the object’s axes and not the world’s. Switching back and forth between Local and World space can make it much easier to place an object exactly where you want it.\nTransforms Look at the Inspector for the Spatial node. Instead of a Position property, you have Translation, as well as Rotation Degrees, and Scale. Drag the object around with the gizmo and observe how these values change.\nYou’ll also find a Transform property, which changes as you move the object. A transform is a matrix that describes an object’s translation, rotation, and scale all in one. The math behind transforms can get quite complex - you’ll start working with them in a later tutorial.\nMeshes Just like a Node2D, a Spatial has no size or appearance of its own. In 2D, you would use a Sprite to add a texture to the node. In 3D, you need to add a mesh. A mesh is a mathematical description of a shape. It consists of a collection of points, called vertices. These vertices are connected by lines, called edges, and multiple edges (at least three) together make a face.\nFor example, a cube is made up of 8 vertices, 12 edges, and 6 faces.\nAdding Meshes Typically, meshes are created by using 3D modeling software, such as Blender. You can also find many collections of 3D models available for download, if you’re unable to create your own. However, often you just need a basic shape such as a cube or sphere. In this case, Godot provides a way to create simple meshes called primitives.\nAdd a MeshInstance node as a child of the Spatial and in the Inspector, click its Mesh property:\nHere you can see the list of available primitives. They represent a handy collection of common useful shapes. Select “New CubeMesh” and you’ll see a plain cube appear on the screen. Note that the cube is white by default, although it may appear slightly blue on your screen due to the default ambient lighting. We’ll talk about lighting a little bit later.\nCameras Try running the scene with your cube object. Did you see anything? In 3D, you won’t see anything in the game viewport without adding a Camera. Add one and use the camera’s gizmo to position it pointing towards the cube:\nThe pinkish-purple pyramid shape on the camera is called the fustrum and represents the camera’s view. Notice the small triangular arrow which represents the camera’s “up” orientation. As you’re moving the camera around, try pressing the “Preview” button in the upper-left to see what the camera sees. Play the scene to verify everything is working as expected.\nWrapping Up In this tutorial you learned how to use Godot’s 3D editor, how to add 3D nodes such as Spatial, MeshInstance, and Camera, and how to use gizmos to place your objects. You also learned a bunch of new terminology. Hopefully you’re not overwhelmed.\nIn the next part, we’ll look at how to build a 3D scene by importing 3D assets and how to use more of Godot’s 3D nodes.\nYou can also find a video version of this lesson here:\n","description":"","tags":null,"title":"The 3D Editor","uri":"/godot_recipes/3.x/g101/3d/101_3d_01/"},{"content":"Game Engines Game development is complex and involves a wide variety of knowledge and skills. In order to build a modern game, you need a lot of underlying technology before you can make the actual game itself. Imagine if you had to build your own computer and write your own operating system before you could even start programming. Game development would be a lot like that if you truly had to start from scratch and build everything you needed.\nIn addition, there are a number of common needs every game has. For example, no matter what your game is, it’s going to need to draw things on the screen. If the code to do that has already been written, it makes more sense to reuse it that to create it all over again for every game. This is where game engines come in.\nA game engine is a collection of tools and technologies designed to assist in developing games. This allows you to focus more on building your game, and less on reinventing the wheel. Here are some of the features a good game engine will provide:\nRendering (2D/3D) “Rendering” is the process of displaying your game on the player’s screen. A good rendering pipeline needs to work with modern GPU features, high resolution displays, and effects like lighting and perspective, while maintaining a high frame rate.\nPhysics Building an accurate and usable physics engine is an enormous task. Most games require some sort of collision detection and response, and many need simulated physics (ie. friction, inertia, etc.), but few developers want to take on the task of writing one.\nPlatform Support In today’s market, you want to be able to release your game on multiple platforms, such as mobile, web, PC, and/or console. A game engine lets you build your game once and export it to one or more platforms.\nDevelopment Environment All of these tools are brought together in a single application, combining everything into one environment so you don’t have to learn a new workflow for every new project.\nThere are dozens of popular game engines to choose from today, such as Unity, Unreal, and GameMaker Studio, to name a few. It is important to remember that the majority of popular engines are commercial products. They may or may not be free to download, but the will require some kind of licensing or royalty agreement if you plan to release your game (and especially if your game makes money). You need to carefully read and understand what you’re agreeing to and what you are and are not allowed to do with the engine.\nWhy use Godot? Click here to download Godot. In contrast to the above, Godot is completely free and open source, released under the very permissive MIT license. This means there are no fees, hidden costs, or royalties you need to pay. This is in addition to being a fully featured modern game engine.\nAs a developer, the benefits are great. Because it’s unencumbered by commercial licensing, you have complete control over exactly how and where your game is distributed. In addition, Godot’s open source nature also means there is a much greater level of transparency than you’ll find with commercial engines. For example, if you find a particular feature doesn’t quite meet your needs, you’re free to modify the engine itself - no permission required.\n","description":"","tags":null,"title":"What is Godot?","uri":"/godot_recipes/3.x/g101/start/101_01/"},{"content":" Godot 101 Your introduction to the Godot game engine. If you’ve never used a game engine before, or if you’re just new to Godot, this is the place to start.\nIn this section: Getting Started What is Godot? Godot's Editor: Finding your way around Nodes: Godot's building blocks GDScript GDScript: Getting started Intro to 3D The 3D Editor Importing 3D Objects Creating a 3D Character Using Areas Edge Detection \u0026 Mouse Capture Using CSG First-person Character ","description":"","tags":null,"title":"Godot 101","uri":"/godot_recipes/3.x/g101/"},{"content":"Problem You’re looking to make a 3D driving or racing game and don’t know where to start.\nSolution Note Even in 3D, cars tend to remain on the ground. For this reason, movement can (mostly) be treated as if it were 2D. Much of the car’s movement code will be very much like the 2D: Car Steering recipe. It’s recommended that you review that recipe before proceeding with this one.\nGodot does provide a VehicleBody node, which is based on RigidBody and includes a complex simulation of engine, braking, suspension, etc. However, this introduces a lot of complexity and tends to be overkill for most casual racing/driving games. For that reason, we’re going with a KinematicBody based solution here.\nInfo If you’re interested in how to work with VehicleBody, I highly recommend this series by Bastiaan Olij.\nSetting up the car Before we start coding, we need to find a 3D model of a car and import it to Godot.\nImporting the Model Here’s the car model we’ll use for this demonstration:\nNote You can find this and other car models in Kenney’s “Car Kit”, available here: https://kenney.nl/assets/car-kit. Download the whole kit, you can use some of the other cars later.\nTo import the car, find the model in the \"Models/GLTF format\" folder. In our case, we want the sedanSports.glb. Drop this file in your new Godot project, preferably in a separate folder such as res://assets/cars/.\nSelect the file in Godot and go to the “Import” tab. Change the Root Type to “KinematicBody” and click “Reimport”. Now we’re ready to use this car.\nSetting up the KinematicBody Double-click on the sedanSports.glb file and choose “New Inherited”. You’ll have a new scene that looks like this:\nNote the individual meshes for each of the car’s parts. There’s also a stray “tmpParent” Spatial node, but we can ignore that.\nThe KinematicBody has a warning about missing collision shapes, so we’ll need to fix that first. We’re going to add 3 CollisionShapes: a BoxShape for the car’s body, and a CylinderShape for each of the front and rear axles.\nOnce the shapes are set up they should look something like this:\nTip To ensure the front and rear shapes match, just create and size one of them, then duplicate it. It is also a good idea to name the CollisionShape nodes to help keep track of them - CollisionBody, CollisionWheelsFront, and CollisionWheelsRear would be a good example.\nBase script We want to be able to make cars that can be driven by human or AI control. In either case, most of the movement code will be the same - it’s really just the input that will be different. For this reason, we can use a base car script that can be shared between them.\nMake a new script called car_base.gd. We’ll start with our variables: some exports to allow for adjusting the car’s behavior, and some others to track its state.\nextends KinematicBody # Car behavior parameters, adjust as needed export var gravity = -20.0 export var wheel_base = 0.6 # distance between front/rear axles export var steering_limit = 10.0 # front wheel max turning angle (deg) export var engine_power = 6.0 export var braking = -9.0 export var friction = -2.0 export var drag = -2.0 export var max_speed_reverse = 3.0 # Car state properties var acceleration = Vector3.ZERO # current acceleration var velocity = Vector3.ZERO # current velocity var steer_angle = 0.0 # current wheel angle Note that rather than using a gravity variable you can set the global value in “Project Settings”. Having it separate does allow for different behavior for different game objects. It’s up to you, use whichever works best for your game.\nengine_power and braking will apply for accelerating and decelerating the car.\ndrag and friction are explained here.\nThe rest of the script will be very similar to the 2D version, which a few changes to work correctly with Spatials and Transforms.\nWe’ll start with _physics_process().\nHere we check if the car is on the ground before applying controls - you can’t steer in mid-air! Then we apply the standard movement equations.\nNote that we’re using move_and_slide_with_snap(), which will keep the car from coming off slopes (if your track has them). We’re also using the car’s local down vector as the snap - again, to handle slopes correctly.\nfunc _physics_process(delta): if is_on_floor(): get_input() apply_friction(delta) calculate_steering(delta) acceleration.y = gravity velocity += acceleration * delta velocity = move_and_slide_with_snap(velocity, -transform.basis.y, Vector3.UP, true) This function applies friction (proportional to the car’s velocity) and drag (proportional to the velocity squared). This will not only slow the car when not applying power, but it will also determine the car’s maximum speed.\nfunc apply_friction(delta): if velocity.length() \u003c 0.2 and acceleration.length() == 0: velocity.x = 0 velocity.z = 0 var friction_force = velocity * friction * delta var drag_force = velocity * velocity.length() * drag * delta acceleration += drag_force + friction_force Finally, we need to calculate turning, using the same simplified “bicycle” model we used in the 2D car. Once the new velocity is found, look_at() rotates the body to point in the correct direction. We’re not including drifting/traction here - that will come later.\nWe can also handle reverse by checking the dot product of the new heading (the direction the car is facing) with the velocity.\nfunc calculate_steering(delta): var rear_wheel = transform.origin + transform.basis.z * wheel_base / 2.0 var front_wheel = transform.origin - transform.basis.z * wheel_base / 2.0 rear_wheel += velocity * delta front_wheel += velocity.rotated(transform.basis.y, steer_angle) * delta var new_heading = rear_wheel.direction_to(front_wheel) var d = new_heading.dot(velocity.normalized()) if d \u003e 0: velocity = new_heading * velocity.length() if d \u003c 0: velocity = -new_heading * min(velocity.length(), max_speed_reverse) look_at(transform.origin + new_heading, transform.basis.y) Finally, we’ll have a function to “decide” how the car is controlled. We’ll override this in the individual cars - with key/gamepad input for player-controlled cars, and with AI decision-making in computer-controlled ones.\nfunc get_input(): # Override this in inherited scripts for controls pass Player controls Now we’re ready to add some player controls. Here’s the InputMap setup:\nIf you have a gamepad with an analog stick, it’s highly recommended you use it. With keyboard controls, which can only be pressed or not, you can only turn the “steering wheel” to the maximum value. An analog stick allows for a much better experience. We’ll make sure the code works with both.\nHere’s the script to attach to the car KinematicBody:\nextends \"res://cars/car_base.gd\" func get_input(): var turn = Input.get_action_strength(\"steer_left\") turn -= Input.get_action_strength(\"steer_right\") steer_angle = turn * deg2rad(steering_limit) $tmpParent/sedanSports/wheel_frontRight.rotation.y = steer_angle*2 $tmpParent/sedanSports/wheel_frontLeft.rotation.y = steer_angle*2 acceleration = Vector3.ZERO if Input.is_action_pressed(\"accelerate\"): acceleration = -transform.basis.z * engine_power if Input.is_action_pressed(\"brake\"): acceleration = -transform.basis.z * braking First, we get the input action for steering, which results in a value between -1 and 1. Then we convert that to an angle in radians based on the maximum allowed angle.\nThe next step rotates the wheel meshes to give some visual feedback of the steering. Note that we’re multiplying it by 2 to make it more exaggerated, since you’ll typically be looking at the car from some distance.\nAfter steering, we check the accelerate/brake inputs to set the car’s acceleration.\nWrapping up That’s the bare-bones car controller. Feel free to use this as a starter for your game. If you’re looking to add more, here are some of the topics we’ll address in follow-up recipes:\nTraction and drifting Chase camera and camera control AI/NPC control (steering, obstacle avoidance, track following) Slopes and ramps Note Download the project file here: https://github.com/kidscancode/3d_car_tutorial/releases\nRelated recipes 2D: Car Steering recipe Input Actions 3D: KinematicBody Movement Like video? ","description":"","tags":null,"title":"3D Kinematic Car: Base","uri":"/godot_recipes/3.x/3d/kinematic_car/car_base/"},{"content":"Problem You need a 2D character that has 8-directional movement, including animation.\nSolution For our example, we’ll use the Isometric Mini-Crusader, which contains 8-directional animations for idle, run, attack, and several other states.\nThe animations are organized in folders, with a separate image for each frame. We’ll use an AnimatedSprite and we’ll name each animation based on its direction. For example, idle0 pointing to the right and going clockwise to idle7.\nWhen our character moves, it will pick an animation based on the direction of movement:\nWe’ll use the mouse to move - the character will always face the mouse and run in that direction when we click the mouse button.\nTo choose which animation to play, we need to get the mouse direction and map it to this same range of 0-7. get_local_mouse_position().angle() gives us the angle to the mouse (in radians). Using stepify() to snap this to the closest multiple of 45° (PI/4 radians) gives the following result:\nDivide each by 45° (PI/4 radians), and we have:\nFinally, we need to map the resulting range to 0-7 using the modulus (%) operator, and we’ll have our correct values. Adding that value to the end of the animation name (“idle”, “run”, etc) gives us the correct animation:\nfunc _process(delta): current_animation = \"idle\" var mouse = get_local_mouse_position() a = stepify(mouse.angle(), PI/4) / (PI/4) a = wrapi(int(a), 0, 8) if Input.is_action_pressed(\"left_mouse\") and mouse.length() \u003e 10: current_animation = \"run\" move_and_slide(mouse.normalized() * speed) $AnimatedSprite.animation = current_animation + str(a) Keyboard input If you’re using keyboard controls instead of mouse, you can get the angle of movement based on which keys are being held. The rest works in the same way.\nfunc _process(delta): current_animation = \"idle\" var input_dir = Vector2.ZERO if Input.is_action_pressed(\"right\"): input_dir.x += 1 if Input.is_action_pressed(\"left\"): input_dir.x -= 1 if Input.is_action_pressed(\"down\"): input_dir.y += 1 if Input.is_action_pressed(\"up\"): input_dir.y -= 1 input_dir = input_dir.normalized() if input_dir.length() != 0: a = input_dir.angle() / (PI/4) a = wrapi(int(a), 0, 8) current_animation = \"run\" move_and_slide(input_dir * speed) $AnimatedSprite.animation = current_animation + str(a) Note Related recipes Top-down Movement Like video? ","description":"","tags":null,"title":"8-Directional Movement/Animation","uri":"/godot_recipes/3.x/2d/8_direction/"},{"content":"Problem You’ve tried adding an AudioStreamPlayer to your mob/coin/etc. to play when the object dies or is collected. But the problem is that when you remove the object, the audio player goes with it, chopping off the sound. You need an easier way to manage playing audio.\nSolution We’ll solve this problem with a node that is available from anywhere in the SceneTree. This node manages a set of AudioStreamPlayer nodes and a queue of sound streams to play.\nCreate a new script in the script editor.\nextends Node var num_players = 8 var bus = \"master\" var available = [] # The available players. var queue = [] # The queue of sounds to play. func _ready(): # Create the pool of AudioStreamPlayer nodes. for i in num_players: var p = AudioStreamPlayer.new() add_child(p) available.append(p) p.connect(\"finished\", self, \"_on_stream_finished\", [p]) p.bus = bus func _on_stream_finished(stream): # When finished playing a stream, make the player available again. available.append(stream) func play(sound_path): queue.append(sound_path) func _process(delta): # Play a queued sound if any players are available. if not queue.empty() and not available.empty(): available[0].stream = load(queue.pop_front()) available[0].play() available.pop_front() Set this script as an autoload in Project Settings. Give it an easily recognizable name, such as “AudioStreamManager”.\nAnywhere in your project that you want to play a sound, use:\nAudioStreamManager.play(\"res://path/to/sound\") Note This audio manager is adapted with thanks from [SFXPlayer by TheDuriel] (https://github.com/TheDuriel/DurielsGodotUtilities).\nExample project Below you can download an example project showing the use of the audio manager node. This project reads a folder full of audio files and generates a grid of buttons. Click the button to play the sound.\nAt the top, you can see the audio manager’s live statistics.\nNote Download the project file here: audio_manager.zip\nRelated recipes ","description":"","tags":null,"title":"Audio Manager","uri":"/godot_recipes/3.x/audio/audio_manager/"},{"content":"Problem You need a camera controller, using mouse or keyboard, that remains level while rotating and following a target.\nSolution Try this: take a Camera node and rotate it a small amount around X (the red ring on the gizmo), then a small amount around Z (the blue ring). Now reverse the X rotation and click the “Preview” button. Observe how the camera is now tilted.\nThe solution to this problem is to place the camera on a gimbal - a device designed to keep an object level during movement. We can create a gimbal using two Spatial nodes, which will control the camera’s left/right and up/down rotation respectively.\nThe node setup should look like this:\nSpatial: CameraGimbal Spatial: InnerGimbal Camera Set the Transform/Translation of the Camera to (0, 0, 4).\nHere’s how the gimbal works: the outer spatial node can only be rotated in Y, while the inner one rotates only in X. You can test this out by rotating them manually, but make sure you change to “Local Space Mode” first (that’s the cube icon next to the lock in the menu bar - the keyboard shortcut to toggle is “T”). Remember to only move the green ring of the outer node and only the red ring of the inner one. Don’t touch the camera node at all.\nReset all the rotations to 0 once you’ve finished experimenting.\nKeyboard control We’ll start with the keyboard controls, then add an option to use the mouse as well. Here are the required actions and their assigned inputs:\nAction Name Input \"cam_up\" W \"cam_down\" S \"cam_right\" D \"cam_left\" A \"cam_zoom_in\" Wheel Up \"cam_zoom_out\" Wheel Down Here’s the initial script. Note that we’re making sure to rotate each Spatial in its local space around the specific axis, as described above.\nextends Spatial var rotation_speed = PI/2 func get_input_keyboard(delta): # Rotate outer gimbal around y axis var y_rotation = 0 if Input.is_action_pressed(\"cam_right\"): y_rotation += 1 if Input.is_action_pressed(\"cam_left\"): y_rotation += -1 rotate_object_local(Vector3.UP, y_rotation * rotation_speed * delta) # Rotate inner gimbal around local x axis var x_rotation = 0 if Input.is_action_pressed(\"cam_up\"): x_rotation += -1 if Input.is_action_pressed(\"cam_down\"): x_rotation += 1 $InnerGimbal.rotate_object_local(Vector3.RIGHT, x_rotation * rotation_speed * delta) func _process(delta): get_input_keyboard(delta) Make a test scene with a MeshInstance and instance the CameraGimbal in it to test out the movement.\nYou’ll notice that holding the up/down control will cause the camera to rotate all the way around, eventually becoming upside-down. To prevent this, we can clamp the rotation.\nfunc _process(delta): get_input_keyboard(delta) $InnerGimbal.rotation.x = clamp($InnerGimbal.rotation.x, -1.4, -0.01) The -1.4 value lets it go almost to 90 degrees up, while setting a very small value for the minimum keeps the camera from clipping into the ground. Feel free to experiment with other values.\nMouse control We’ll add a flag called mouse_control to enable easy toggling of mouse/keyboard controls.\n# mouse properties var invert_y = false var invert_x = false var mouse_control = false var mouse_sensitivity = 0.005 func _unhandled_input(event): if mouse_control and event is InputEventMouseMotion: if event.relative.x != 0: var dir = 1 if invert_x else -1 rotate_object_local(Vector3.UP, dir * event.relative.x * mouse_sensitivity) if event.relative.y != 0: var dir = 1 if invert_y else -1 $InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * event.relative.y * mouse_sensitivity) func _process(delta): if !mouse_control: get_input_keyboard(delta) This code works by converting horizontal mouse motion to Y rotation of the outer gimbal and vertical to X rotation for the inner gimbal. We’ve also added invert_x and invert_y flags so that you can flip the motion in either axis - many players prefer one over the other, so it’s best to allow for both options.\nAlso, in _process() we disable keyboard input when using mouse control.\nYou may notice a problem with the up/down movement if you move the mouse too quickly. A large value for event.relative.y results in “skipping” to the opposite side of the clamped value. We can solve this by clamping the vertical mouse movement to a reasonable value. Change the above code for y to this:\nif event.relative.y != 0: var dir = 1 if invert_y else -1 var y_rotation = clamp(event.relative.y, -30, 30) $InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * y_rotation * mouse_sensitivity) Note In your project, you’ll probably also want to capture the mouse during gameplay. See the linked recipe at the end of this document for details.\nCamera zoom Camera zoom works by varying the scale of the gimbal system.\n# zoom settings var max_zoom = 3.0 var min_zoom = 0.5 var zoom_speed = 0.09 var zoom = 1.5 func _unhandled_input(event): if event.is_action_pressed(\"cam_zoom_in\"): zoom -= zoom_speed if event.is_action_pressed(\"cam_zoom_out\"): zoom += zoom_speed zoom = clamp(zoom, min_zoom, max_zoom) func _process(delta): scale = lerp(scale, Vector3.ONE * zoom, zoom_speed) Using lerp() to change the zoom level results in smoother zooming.\nFollowing a target Once you have the camera gimbal set up, it can follow a target by adding the following:\nexport (NodePath) var target func _process(delta): if target: global_transform.origin = get_node(target).global_transform.origin Instance the camera in your scene and use the Inspector to choose the node you want to follow.\nFinal script For completeness, here’s the full script, including export variables for all the camera settings, so that you can configure it in your project.\nextends Spatial export (NodePath) var target export (float, 0.0, 2.0) var rotation_speed = PI/2 # mouse properties export (bool) var mouse_control = false export (float, 0.001, 0.1) var mouse_sensitivity = 0.005 export (bool) var invert_y = false export (bool) var invert_x = false # zoom settings export (float) var max_zoom = 3.0 export (float) var min_zoom = 0.4 export (float, 0.05, 1.0) var zoom_speed = 0.09 var zoom = 1.5 func _unhandled_input(event): if Input.get_mouse_mode() != Input.MOUSE_MODE_CAPTURED: return if event.is_action_pressed(\"cam_zoom_in\"): zoom -= zoom_speed if event.is_action_pressed(\"cam_zoom_out\"): zoom += zoom_speed zoom = clamp(zoom, min_zoom, max_zoom) if mouse_control and event is InputEventMouseMotion: if event.relative.x != 0: var dir = 1 if invert_x else -1 rotate_object_local(Vector3.UP, dir * event.relative.x * mouse_sensitivity) if event.relative.y != 0: var dir = 1 if invert_y else -1 var y_rotation = clamp(event.relative.y, -30, 30) $InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * y_rotation * mouse_sensitivity) func get_input_keyboard(delta): # Rotate outer gimbal around y axis var y_rotation = 0 if Input.is_action_pressed(\"cam_right\"): y_rotation += 1 if Input.is_action_pressed(\"cam_left\"): y_rotation += -1 rotate_object_local(Vector3.UP, y_rotation * rotation_speed * delta) # Rotate inner gimbal around local x axis var x_rotation = 0 if Input.is_action_pressed(\"cam_up\"): x_rotation += -1 if Input.is_action_pressed(\"cam_down\"): x_rotation += 1 x_rotation = -x_rotation if invert_y else x_rotation $InnerGimbal.rotate_object_local(Vector3.RIGHT, x_rotation * rotation_speed * delta) func _process(delta): if !mouse_control: get_input_keyboard(delta) $InnerGimbal.rotation.x = clamp($InnerGimbal.rotation.x, -1.4, -0.01) scale = lerp(scale, Vector3.ONE * zoom, zoom_speed) if target: global_transform.origin = get_node(target).global_transform.origin Related recipes Capturing the Mouse Intro to 3D Like video? ","description":"","tags":null,"title":"Camera Gimbal","uri":"/godot_recipes/3.x/3d/camera_gimbal/"},{"content":"Problem You want an enemy to chase the player.\nSolution The first step in getting an enemy to chase the player is to determine what direction the enemy needs to move. To get the vector pointing from A to B, you subtract: B - A. Normalize the result and you have a direction vector.\nThis makes the solution quite straightforward. Every frame, set the enemy’s velocity to point in the direction of the player.\nvelocity = (player.position - position).normalized() * speed Godot’s Vector2 object has a built-in helper for this:\nvelocity = position.direction_to(player.position) * speed However, this would allow the enemy to chase the player from any distance, even if it’s far away. To fix this, we can add an Area2D to the enemy, and only chase the player when it’s inside this “detect radius”.\nHere’s some example code:\nextends KinematicBody2D var run_speed = 25 var velocity = Vector2.ZERO var player = null func _physics_process(delta): velocity = Vector2.ZERO if player: velocity = position.direction_to(player.position) * run_speed velocity = move_and_slide(velocity) func _on_DetectRadius_body_entered(body): player = body func _on_DetectRadius_body_exited(body): player = null We’ve connected the body_entered and body_exited signals from the Area2D so that the enemy knows whether it’s in range or not.\nNote The above assumes that the player is the only body that will enter/exit, which is usually done by setting the appropriate collision layers/masks.\nThis concept can be extended to other types of games as well. The key is to find the direction vector from the enemy to the player:\n# 2D (player.position - position).normalized() # 3D (player.transform.origin - transform.origin).normalized() If, for example, your game is a side-scroller or has other constraints in movement, you can use only the x component of the resulting vector to determine movement.\nLimitations Note that this method results in very simplistic straight-line movement. The enemy will not move around obstacles such as walls, nor will it stop if it gets too close to the player.\nAnother problem is more apparent with fast-moving enemies. As the player moves, the enemies using this technique will change direction instantly. For a more natural-looking movement, you’ll want to use a steering behavior.\nFor more advanced behaviors, see the other recipes in this chapter.\nRelated recipes Top-down character Homing missile ","description":"","tags":null,"title":"Chasing the player","uri":"/godot_recipes/3.x/ai/chase/"},{"content":"Problem You want to detect when an object enters or exits the screen.\nSolution The engine provides a node for this: VisibilityNotifier2D. Attach this node to your object, and you’ll be able to use its screen_entered and screen_exited signals.\nExample 1 Consider a projectile that travels in a straight line after it’s fired. If we continue firing, eventually we’ll have a large number of objects for the engine to track, event though they’re offscreen, which can cause lag.\nHere’s the movement code for the projectile:\nextends Area2D var velocity = Vector2(500, 0) func _process(delta): position += velocity * delta To have the projectile automatically deleted when it moves offscreen, add a VisibilityNotifier2D and connect its screen_exited signal.\nfunc _on_VisibilityNotifier2D_screen_exited(): queue_free() Example 2 We have an enemy that performs some actions, such as moving along a path or playing an animation. On a large map with many enemies, only a few of them will be onscreen at the same time. We can disable the enemy’s actions while it’s offscreen using VisibilityNotifier2D.\nPartial code:\nvar active = false func _process(delta): if active: play_animation() move() func _on_VisibilityNotifier2D_screen_entered(): active = true func _on_VisibilityNotifier2D_screen_exited(): active = false ","description":"","tags":null,"title":"Entering/Exiting the screen","uri":"/godot_recipes/3.x/2d/enter_exit_screen/"},{"content":"Overview Writing scripts and attaching them to nodes and other objects is how you build behavior and game mechanics into your game. For example, a Sprite node automatically displays an image, but to move it across the screen, you’ll add a script that tells it how fast, in what direction, and so on.\nYou can think of it as the coding version of using the Inspector - GDScript knows all about Godot nodes and how to access them, plus it allows you to change them dynamically.\nGDScript is Godot’s built-in language for scripting and interacting with nodes. The GDScript documentation on the Godot website is a great place to get an overview of the language, and I highly recommend taking the time to read through it.\nIs GDScript Python?\nYou’ll often read comments to the effect that “GDScript is based on Python”. That’s somewhat misleading; GDScript uses a syntax that’s modeled on Python’s, but it’s a distinct language that’s optimized for and integrated into the Godot engine. That said, if you already know some Python, you’ll find GDScript feels very familiar.\nWarning Many tutorials (and Godot in general) assume that you have at least some programming experience already. If you’ve never coded before, you’ll likely find learning Godot to be a challenge. Learning a game engine is a large task on its own; learning to code at the same time means you’re taking on a lot. If you find yourself struggling with the code in this section, you may find that working through an introductory Python lesson will help you grasp the basics.\nStructure of a script The first line of any GDScript file must be extends \u003cClass\u003e, where \u003cClass\u003e is some existing built-in or user-defined class. For example, if you’re attaching a script to a KinematicBody2D node, then your script would start with extends KinematicBody2D. This states that your script is taking all the functionality of the built-in KinematicBody2D object and extending it with additional functionality created by you.\nIn the rest of the script, you can define any number of variables (aka “class properties”) and functions (aka “class methods”).\nCreating a script Let’s make our first script. Remember, any node can have a script attached to it.\nOpen the editor and add a Sprite node to empty scene. Right-click on the new node, and choose “Attach Script”. You can also click the button next to the search box.\nNext you need to decide where you want the script saved and what to call it. If you’ve named the node, the script will automatically be named to match it (so unless you’ve changed anything this script will likely be called “Sprite.gd”).\nNow the script editor window opens up, and this is your new, empty sprite script. Godot has automatically included some lines of code, as well as some comments describing what they do.\nextends Sprite # Declare member variables here. Examples: # var a = 2 # var b = \"text\" # Called when the node enters the scene tree for the first time. func _ready(): pass # Replace with function body. # Called every frame. 'delta' is the elapsed time since the previous frame. #func _process(delta): # pass Since the script was added to a Sprite, the first line is automatically set to extends Sprite. Because this script extends Sprite, it will be able to access and manipulate all the properties and functions that a Sprite node provides.\nAfter that is where you’re going to define all the variables you will use in the script, the “member variables”. You define variables with the ‘var’ keyword - as you can see by the comment examples.\nGo ahead and delete the comments and let’s talk about this next piece.\nNow we see a function called _ready(). In GDScript you define a function with the keyword “func”. The _ready() function is a special one that Godot looks for and runs whenever a node is added to the tree, for example when we hit “Play”.\nLet’s say that when the game starts, we want to make sure the Sprite goes to a particular location. In the Inspector, we want to set the Position property. Notice that it’s in the section called “Node2D” - that means this is a property that any Node2D type node will have, not just Sprites.\nHow do we set the property in code? One way to find the name of the property is by hovering over it in the Inspector.\nGodot has a great built-in help/reference tool. Click on “Classes” at the top of the Script window and search for Node2D and you’ll see a help page showing you all the properties and methods the class has available. Looking down a bit you can see position in the “Member Variables” section - that’s the one we want. It also tells us the property is of the type “Vector2”.\nLet’s go back to the script and use that property:\nfunc _ready(): position = Vector2(100, 150) Notice how the editor is making suggestions as you type. Godot uses vectors for lots of things, and we’ll talk more about them later. For now, let’s type Vector2, and the hint tells us to put two floats for x and y.\nNow we have a script that says “When this Sprite starts, set its position to (100, 150)”. We can try this out by pressing the “Play Scene” button.\nTip When first learning to code, beginners often ask “How do you memorize all these commands?” It’s not a matter of memorization, it’s about practice. As you use things more, the things you do frequently will “stick” and become automatic. Until then, it’s a great idea to keep the reference docs handy. Use the search function whenever you see something you don’t recognize. If you have multiple monitors, keep a copy of the web docs open on the side for quick reference.\nWrapping up Congratulations on making your first script in GDScript! Before moving on, make sure you understand everything we did in this step. In the next part, we’ll add some more code to move the Sprite around the screen.\n","description":"","tags":null,"title":"GDScript: Getting started","uri":"/godot_recipes/3.x/g101/gdscript/gdscript_start/"},{"content":"Linear Interpolation, or its commonly-used abbreviation lerp, is a term that comes up often in game development. If you’ve never come across it before it can seem mysterious and highly-technical, but as you’ll see in this tutorial, it’s actually a straightforward concept with a wide variety of applications in game programming.\nNumeric Interpolation The core formula for linear interpolation is this:\nfunc lerp(a, b, t): return (1 - t) * a + t * b In this formula, a and b represent the two values and t is the amount of interpolation, typically expressed as a value between 0 (which returns a), and 1 (which returns b). The function finds a value the given amount between the two. For example:\nx = lerp(0, 1, 0.75) # x is 0.75 x = lerp(0, 100, 0.5) # x is 50 x = lerp(10, 75, 0.3) # x is 29.5 x = lerp(30, 2, 0.75) # x is 9 It’s called linear interpolation because the path between the two points is a straight line.\nYou can animate a node’s properties with lerp(). For example, if you divide the elapsed time by the desired duration, you’ll get a value between zero and one you can use to alter a property smoothly over time. This script scales a sprite up to five times its starting size while fading it out (using modulate.a) over two seconds:\nextends Sprite var time = 0 var duration = 2 # length of the effect func _process(delta): if time \u003c duration: time += delta modulate.a = lerp(1, 0, time / duration) scale = Vector2.ONE * lerp(1, 5, time / duration) Vector interpolation You can also interpolate between vectors. Both Vector2 and Vector3 provide linear_interpolate() methods for this.\nFor example, to find a vector that’s halfway between a Spatial node’s forward and left direction vectors:\nvar forward = -transform.basis.z var left = transform.basis.x var forward_left = forward.linear_interpolate(left, 0.5) The following example moves a Sprite node towards the mouse click position. Each frame the node moves 10% of the way to the target. This results in an “approach” effect, where the object’s speed becomes slower the closer it gets to the target.\nextends Sprite var target func _input(event): if event is InputEventMouseButton and event.pressed: target = event.position func _process(delta): if target: position = position.linear_interpolate(target, 0.1) For more advanced applications of interpolation, see Tween.\n","description":"","tags":null,"title":"Interpolation","uri":"/godot_recipes/3.x/math/interpolation/"},{"content":"Problem You want to display some text on the screen.\nSolution Sooner or later you’re going to need to display some text on your screen. Examples include a title, countdown timer, score counter, and many others. For the majority of these, Godot’s Label node is the answer.\nWorking with fonts Before you can start, you’re going to need a font. We’ll go into the full details of Godot’s font support in a separate recipe, but for our purposes, let’s assume you have a TTF or OTF font file. For using bitmap fonts, see the associated recipe.\nNote For this example, we’ll use “Roboto” - a popular free font, which you can find on Google Fonts. You can also download here: Roboto_font.zip\nAdding a Label Add a new Label node to your scene. In the Inspector, you’ll see the node’s properties, most of which are self-explanatory (hover them with the mouse to see a description):\nGo ahead and add something in the Text field and experiment with how it looks. You’ll notice there is a default font, but it’s very plain (and small).\nAdding a DynamicFont To add your font in the Inspector, scroll down to and expand the Custom Fonts section. In the empty Font property, choose “New DynamicFont” and then click the new DynamicFont to expand it.\nDrag your font file (in this example we’re using Roboto-Medium.ttf) into the Font Data property (or choose “Load” and navigate to the file). There are several properties to adjust but for now let’s make Size a bit bigger.\nFeel free to tinker with how the others affect the text appearance. For example, in the picture below, the second label has the Filter property enabled:\nAdjusting color You can adjust the label’s font color in the Custom Colors section. Here you can change Font Color as well as add a shadow color. Shadow properties are set in the Custom Constants section.\nDynamically changing text If all you need in your scene is static text, then you’re done. However, if you need to update the label dynamically, you can do so in code by using the text property.\nFor example, if we had a Timer node in our scene, we could do the following:\nextends Control var counter = 0 func _ready(): $Label.text = str(counter) func _on_Timer_timeout(): counter += 1 $Label.text = str(counter) See the “related recipes” section for more examples of using labels and working with UI nodes.\nRelated recipes Like video? ","description":"","tags":null,"title":"Labels","uri":"/godot_recipes/3.x/ui/labels/"},{"content":"Problem You need to make a 2D platform-style character.\nSolution New developers are often surprised at how complex a platform character can be to program. Godot provides some built-in tools to assist, but there are as many solutions as there are games. In this tutorial, we won’t be going in-depth with features like double-jumps, crouching, wall-jumps, or animation. Here we’ll discuss the fundamentals of platformer movement. See the rest of the recipes for other solutions.\nTip While it’s possible to use RigidBody2D to make a platform character, we’ll be focusing on KinematicBody2D. Kinematic bodies are well-suited for platformers, where you are less interested in realistic physics than in responsive, arcade feel.\nStart with a KinematicBody2D node, and add a Sprite and CollisionShape2D to it.\nAttach the following script to the root node of the character. Note that we’re using input actions we’ve defined in the InputMap: \"walk_right\", \"walk_left\", and \"jump\". See InputActions.\nextends KinematicBody2D export (int) var speed = 1200 export (int) var jump_speed = -1800 export (int) var gravity = 4000 var velocity = Vector2.ZERO func get_input(): velocity.x = 0 if Input.is_action_pressed(\"walk_right\"): velocity.x += speed if Input.is_action_pressed(\"walk_left\"): velocity.x -= speed func _physics_process(delta): get_input() velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) if Input.is_action_just_pressed(\"jump\"): if is_on_floor(): velocity.y = jump_speed The values used for speed, gravity, and jump_speed depend greatly on the size of your player sprite. The player’s texture in this example is 108x208 pixels. If your sprite is smaller, you’ll want to use smaller values. We also want high values so that everything feels fast and responsive. A low gravity results in a floaty-feeling game while a high value means you’re soon back on the ground and ready to jump again.\nNote that we’re checking is_on_floor() after using move_and_slide(). The move_and_slide() function sets the value of this method, so it’s important not to check it before, or you’ll be getting the value from the previous frame.\nFriction and acceleration The above code is a great start, and you can use it as the foundation for a wide variety of platform controllers. One problem it has, though, is the instantaneous movement. For a more natural feel, it’s better if the character has to accelerate up to its max speed and that it coasts to a stop when there is no input.\nOne way to add this behavior is to use linear interpolation (“lerp”). When moving, we will lerp between the current speed and the max speed and while stopping we’ll lerp between the current speed and 0. Adjusting the lerp amount will give us a variety of movement styles.\nTip For an overview of linear interpolation, see Gamedev Math: Interpolation.\nexport (float, 0, 1.0) var friction = 0.1 export (float, 0, 1.0) var acceleration = 0.25 func get_input(): var dir = 0 if Input.is_action_pressed(\"walk_right\"): dir += 1 if Input.is_action_pressed(\"walk_left\"): dir -= 1 if dir != 0: velocity.x = lerp(velocity.x, dir * speed, acceleration) else: velocity.x = lerp(velocity.x, 0, friction) Try changing the values for friction and acceleration to see how they affect the game’s feel. An ice level, for example, could use very low values, making it harder to maneuver.\nConclusion This code gives you a starting point for building your own platformer controller. For more advanced platforming features such as wall jumps, see the other recipes in this section.\nDownload an example project using this recipe:\nNote Download the project file here: platform_character.zip\nRelated Recipes Input Intro Kinematic Friction ","description":"","tags":null,"title":"Platform character","uri":"/godot_recipes/3.x/2d/platform_character/"},{"content":"Where to start? Depending on the game, and how fleshed-out your idea is, the answer might be very different. In our case, I’ve cheated a little bit by making a prototype of the game already and working out a few of the ideas ahead of time. Still, it diverged a bit from my initial idea, and so might this series - time will tell.\nIn a bigger project, you might start with design document, which could be as simple as a page of notes or as complex as a 500-page treatise laying out every detail of your game’s world, plot, and mechanics. We’ve no need of anything so involved here, so let’s just go over the gameplan.\nGameplan In this game, the player controls a “character” that jumps from circle to circle. Jumping is initiated by a click or touch, and if you don’t hit another circle, you lose. The score is related to how long you survive, and the difficulty will increase over time with circles that move, shrink, and/or expire. The idea is fast-paced, short games with a “top that” feel. As much as possible, the art will remain simple and clean, with visual and audio effects to add appeal.\nNote We’ll be using GLES 3 to start. It’s not yet clear what if any impact this will have. Once we get to the mobile testing phase, we’ll see if a switch to GLES 2 is warranted.\nYou can also follow this project on Github.\nGetting started Let’s start with the project settings. We need to define our screen size/ behavior. We want this to be a mobile game so it’s going to need to be portrait mode and able to adjust to variable screen sizes, since there are so many phone resolutions available.\nOpen Project Settings and find the Display/Window section. Set the screen size to (480, 854), the Handheld/Orientation to “Portrait”, the Stretch/Mode to “2d”, and the Stretch/Aspect to “Keep”.\nNext, in Input Devices/Pointing enable “Emulate Touch From Mouse”. This will let us write the code only using screen touch events, but still play by using the mouse on PC platforms.\nProject organization To keep things organized, we’re going to make a folder to hold the game objects (objects) and one for UI (gui). The game assets (images, audio, etc.) will go in an assets folder. You can download the starting assets here:\nNote Download the project file here: circle_jump_assets.zip\nOnce we have the folders and the assets set up, we’re ready to start coding!\nGame Objects We have two game objects to make: the player (“jumper”) and the circle.\nJumper For movement and collision, we’re going to use a Area2D. To be fair, we could use KinematicBody2D here too, and it would work just as well. However, we don’t really need collision in this game, we just need to know when the jumper contacts a circle. Let’s add the following nodes:\nArea2D (“Jumper”) Sprite CollisionPolygon2D VisibilityNotifier2D Save the scene in res://objects/ and drag the circle image (res://assets/images/jumper.png) into the Sprite’s Texture. Note that all the game images are flat white. This will make it easier for us to dynamically color them later.\nSince the art is drawn pointing upwards, set the Sprite’s Rotation property to 90.\nSelect the CollisionPolygon2D and add three points to cover the jumper’s triangular shape.\nNow let’s add a script to the body and start coding its behavior:\nFirst, the signals and variables:\nextends Area2D var velocity = Vector2(100, 0) # start value for testing var jump_speed = 1000 var target = null # if we're on a circle Next we’ll detect the screen touch and, if we’re on a circle, call our jump method:\nfunc _unhandled_input(event): if target and event is InputEventScreenTouch and event.pressed: jump() Jumping means leaving a circle and traveling forward at our jump speed:\nfunc jump(): target = null velocity = transform.x * jump_speed We’ll detect hitting a circle with the area_entered signal, so connect it. If we hit a circle, we’ll stop moving forward.\nfunc _on_Jumper_area_entered(area): target = area velocity = Vector2() If we are captured by a circle, we want to rotate around it. We’ll add a pivot on the circle, and match its transform so our orientation will always be facing outwards. Otherwise we move forward in a straight line.\nfunc _physics_process(delta): if target: transform = target.orbit_position.global_transform else: position += velocity * delta Color Shader Tip See the Shaders section for help getting started using shaders.\nWe’re going to use a small shader to the Sprite so that we can customize its color. Select the Sprite and then in the Material property add a new ShaderMaterial. Click on that, and in Shader select “New Shader”, then click on that. The shader editor panel will open at the bottom.\nHere is the code for our color shader. It uses a uniform variable for the color, which allows us to choose a value from the Inspector or from our game script. Then it changes all the visible pixels of the texture into that color, preserving the alpha (transparency) value.\nshader_type canvas_item; uniform vec4 color : hint_color; void fragment() { COLOR.rgb = color.rgb; COLOR.a = texture(TEXTURE, UV).a; } You’ll now see a Shader Params section in the Inspector where you can set a color value:\nWe’ll want to use this same shader elsewhere, so in the Shader property, choose “Save” and save this as res://objects/color.shader.\nCircle The second game object is the circle, which will be instanced many times as the game progresses. Eventually, we’ll add a variety of behaviors such as moving, shrinking, etc., but for this first iteration, we just want it to capture the player.\nHere’s the starting node setup:\nArea2D (“Circle”) Sprite CollisionShape2D Node2D (“Pivot”) Position2D (“OrbitPosition”) The “Pivot” node is how we’ll make the player orbit the circle. The “OrbitPosition” will be offset by whatever the size of the circle is, and the player will follow it.\nUse res://assets/images/circle1_n.png as the Sprite’s texture. While we’re here, add a ShaderMaterial and choose “Load” to use the saved color.shader we made earlier.\nAdd a circle shape to the CollisionShape2D and attach a script to the root node.\nextends Area2D onready var orbit_position = $Pivot/OrbitPosition var radius = 100 var rotation_speed = PI func _ready(): init() func init(_radius=radius): radius = _radius $CollisionShape2D.shape = $CollisionShape2D.shape.duplicate() $CollisionShape2D.shape.radius = radius var img_size = $Sprite.texture.get_size().x / 2 $Sprite.scale = Vector2(1, 1) * radius / img_size orbit_position.position.x = radius + 25 func _process(delta): $Pivot.rotation += rotation_speed * delta In the init() function, we’re setting up the size of the circle, based on the given radius. We need to size the collision shape as well as scaling the texture to match.\nTry running the scene with different values of radius to test. (Later we’ll stop calling init() in _ready()).\nMain Scene Now we can test out the interaction.\nCreate a “Main” scene using a Node2D and instance both the Jumper and the Circle in it. Arrange them so the jumper will hit the Circle (Jumper’s default velocity is (100, 0)).\nTry running. You should see the jumper get captured by the circle and start orbiting it. Clicking the mouse should then send the jumper flying off in whatever direction it’s pointing.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nLike video? ","description":"","tags":null,"title":"Project setup","uri":"/godot_recipes/3.x/games/circle_jump/circle_jump_01/"},{"content":"Problem You want to allow the player to “wrap around” the screen, teleporting from one side of the screen to the other. This is a common feature, especially in old-school 2D games (think Pac-man).\nSolution Get your screen (viewport) size\nonready var screen_size = get_viewport_rect().size get_viewport_rect() is available to any CanvasItem derived node.\nCompare your player’s position\nif position.x \u003e screen_size.x: position.x = 0 if position.x \u003c 0: position.x = screen_size.x if position.y \u003e screen_size.y: position.y = 0 if position.y \u003c 0: position.y = screen_size.y Note that this is using the node’s position, which is usually the center of your sprite and/or body.\nSimplifying with wrapf()\nThe above code can be simplified using GDScript’s wrapf() function, which “loops” a value between the given limits.\nposition.x = wrapf(position.x, 0, screen_size.x) position.y = wrapf(position.y, 0, screen_size.y) ","description":"","tags":null,"title":"Screen wrap","uri":"/godot_recipes/3.x/2d/screen_wrap/"},{"content":"Problem You want to get started coding shaders.\nSolution A shader is a special program that runs on the computer’s GPU (graphics card). The GPU is optimized to perform certain types of math very efficiently. Shader code can be attached to objects to affect how they’re rendered on the screen.\nThe output of a shader program is the color of the set of pixels of the object. Shaders can be used in 2d (canvas_item shaders) and 3D (spatial shaders).\nThe most difficult part for newcomers to understand about shaders is that they run in parallel. A shader runs simultaneously on all pixels. This allows for great speed, but also limits what information you have access to in the shader.\nTo add a shader to an object, find its Material property and select “New ShaderMaterial”. Click the new material to open it, and select “New Shader”. Click that, and you’ll see a shader editor open at the bottom of the screen.\nThe first line of the shader must specify its type. If the node it’s attached to is a 2D node:\nshader_type canvas_item; Or for a 3D node:\nshader_type spatial; For these first examples, let’s stick to 2D. Add a Sprite node and add shader following the steps above. You can use the Godot icon for its texture.\nThere are two basic types of shader we’ll discuss here: vertex and fragment.\nFragment shader Fragment shaders calculate the color of the pixel. Let’s look at an example:\nvoid fragment() { COLOR = vec4(1.0, 0.0, 0.0, 1.0); } Every pixel is red. COLOR is the output of the fragment shader and is applied to every pixel simultaneously. But what if we want some variation?\nUV coordinates In shaders, the pixel coordinates are specified in UV notation. These are normalized values ranging from (0, 0) (top-left) to (1, 1) (bottom-right).\nNote Shaders use vectors (vec4) to represent RGBA colors. Individual compenents can be accessed using e.g. color.r. Treating colors as vectors allows for a variety of interesting effects based on vector math.\nvoid fragment() { COLOR = vec4(UV.x, 0.0, 0.0, 1.0); } Now the red channel ranges from 0 on the left to 1.0 on the right, varying along with the UV.\nAnother example:\nvoid fragment() { COLOR = vec4(UV.x, 1.0 - UV.y, 0.5, 1.0); Textures Notice that since we’re setting the pixel color directly, we’ve thrown away the Godot icon’s data. You can access that texture data using the TEXTURE input and texture() function:\nvoid fragment() { COLOR = texture(TEXTURE, UV); } Now we’re back to the original image. Each pixel’s color is being set to the color value of the texture at the same UV position.\nIt’s also possible to change only one channel of the COLOR output:\nvoid fragment() { COLOR = texture(TEXTURE, UV); COLOR.a = 1.0 - UV.x; } This ramps the alpha channel down, resulting in a fade-out effect.\nVarying with time Another useful built-in shader property is TIME, which gives an ever-increasing value representing the current elapsed time. If we also use the sin() function, which returns a value between -1 and 1, we can produce this effect:\nvoid fragment() { COLOR = texture(TEXTURE, UV); COLOR.a = abs(sin(TIME * 0.5)); } Or this one:\nvoid fragment() { COLOR = texture(TEXTURE, UV); COLOR.a = max(0.0, UV.x - abs(sin(TIME))); } Vertex shader Vertex shaders alter the vertices of the object, allowing for deformations and scaling. Just as fragment shaders run on every pixel, vertex shaders run on every vertex of an object. In a canvas_item shader, this typically means the four corners of the texture. In a spatial shader, it’s each vertex of the mesh.\nFor example, observe what happens with the following:\nvoid vertex() { VERTEX.x += UV.x * 10.0; } In this shader, the two left vertices (0, 0) and (0, 1) are unchanged, but the right vertices become (10, 0) and (10, 1).\nVarying the vertex positions over time can produce a variety of interesting effects:\nvoid vertex() { VERTEX.y += sin(UV.x * TIME) * 10.0; } Uniforms To pass a value to the shader, you need a variable declared with the uniform keyword. Once you do this, the variable appears in the Inspector in much the same way an export variable. However, a uniform’s value can not be changed in the shader!\nUniform values are global to the shader and can be accessed from any function.\nHints You can also use optional hints to assist in setting the value in the Inspector.\nuniform float radius : hint_range(0, 1); Hints are available for a variety of data types. See the Shader Language Reference for a full list.\nWrapping up This is just a tiny introduction to what’s possible with shaders. See the rest of the recipes in this section for more examples you can use in your projects.\nRelated Recipes ","description":"","tags":null,"title":"Shaders: intro","uri":"/godot_recipes/3.x/shaders/intro/"},{"content":"Introduction In this demo, we’ll consider a local multiplayer game - a topdown-style maze game with two players (one using arrow keys and the other using WASD controls). This is not a problem if our game world all fits on one screen, but if the map is large, we’ll want to have a “split screen” view tracking the two players separately.\nWe’ll also look at a quick way to set up a minimap display.\nGame setup We won’t spend a lot of time on the setup of the game world. The two players are KinematicBody2D objects using no-frills 8-way movement.\nNote If you need help setting up this part, see the following section in the official Godot docs: 2D Movement Overview.\nEach player has its input actions set up in the Project Settings -\u003e Input Map section: “right_1” to Right Arrow, “right_2” to D, etc. Note that by naming them this way, we can save time in the code by using:\nexport var id = 0 func get_input(): velocity = Vector2() if Input.is_action_pressed('right_%s' % id): velocity.x += 1 # etc. This way both characters can use the same script for movement. Just assign the appropriate value to id for each player.\nThe two players are added to a “World” scene containing a TileMap:\nIf you like, you can download the starting project, with the world already set up, here:\nsplitscreen_start.zip\nNote that the map is much larger than the game screen, but aside from that everything works as intended. Setting up your game “world” separately like this will make setting up the viewports much easier and more flexible.\nViewports, Cameras, and Worlds We’re going to start with a new scene that’s going to contain our two viewports. Create a node to serve as the root. I like to use Node since it has no properties of its own - it’s just there to contain the rest of the scene.\nBy themselves, Viewport nodes don’t have position information (they don’t inherit from Spatial or Node2D). We’re going to use ViewportContainer, a Control node, to hold each viewport. To keep them arranged side-by-side, we’ll use an HBoxContainer.\nSet the HBoxContainer’s Alignment to “Center” and to have a small gap between the two viewports, set Custom Constants/Separation to 5. In the “Layout” menu, choose “Full Rect”.\nNow add two ViewportContainers as children, naming them with a 2 and 1 (to match the player they’ll display). Set the Size Flags on both to “Fill, Expand” so that they will each expand to fill half of the screen. Also, check the Stretch property so that the Viewport will automatically be set to the size of the container.\nInside each of these containers add a Viewport. Note that if you set the viewport’s Size property, it will be reset by the container.\nIn order for a Viewport to display anything, we’ll need a Camera2D which will render onto the Viewport. Add one to each viewport. Don’t forget to check the Current property to activate the camera. We can also set each camera’s Zoom to (0.75, 0.75) to get a better view of the area around the player.\nYour node setup should look like this:\n┖╴Main (Node) ┖╴Viewports (HBoxContainer) ┠╴ViewportContainer2 ┃ ┖╴Viewport2 ┃ ┖╴Camera2D ┖╴ViewportContainer1 ┖╴Viewport1 ┖╴Camera2D Note Note that we’ve put ViewportContainer1 second in the HBoxContainer. This will place it on the right side since Player 1 uses the arrow keys.\nAdding the World When we run the scene we won’t see anything because the viewports don’t have any “world” to render. A viewport’s world (for 3D) or world_2d property represent the source for the viewport’s environment and determine what will be rendered by its camera. The world can be set in code, but for 2D it will also display any child 2D nodes we add to it.\nLet’s instance the “World” scene as a child of Viewport1. Now when we play the scene we see the world inside the left viewport.\nWe also need to add a world to Viewport2, but we want it to use the same one. We can handle this in code. Attach a script to Main and add the following:\nextends Node onready var viewport1 = $Viewports/ViewportContainer1/Viewport1 onready var viewport2 = $Viewports/ViewportContainer2/Viewport2 onready var camera1 = $Viewports/ViewportContainer1/Viewport1/Camera2D onready var camera2 = $Viewports/ViewportContainer2/Viewport2/Camera2D onready var world = $Viewports/ViewportContainer1/Viewport1/World func _ready(): viewport2.world_2d = viewport1.world_2d The onready node references are for convenience - we’ll be using them as we move forward. Remember that when you type “$” Godot will autosuggest node paths so you don’t have to type them. You can also drag a node from the scene tree into the script editor and you’ll get the node’s path.\nWhen we run the scene now, we see the world rendered in both viewports. However, neither camera is moving so we only see a small part of the world.\nSetting up the cameras Attach the following script to each camera:\nextends Camera2D var target = null func _physics_process(delta): if target: position = target.position Now we can assign a target to each camera and it will follow that node’s position. We’ll do that in the Main script:\nfunc _ready(): viewport2.world_2d = viewport1.world_2d camera1.target = world.get_node(\"Player_1\") camera2.target = world.get_node(\"Player_2\") When we run the scene now, each player is centered in its viewport and our splitscreen setup works!\nTip I find it looks best if you disable the Drag Margin properties of the cameras.\nCamera limits Next, let’s add some limits to the player cameras so that they don’t scroll outside the bounds of the map. Add this function to the main script and call it in _ready():\nfunc set_camera_limits(): var map_limits = world.get_used_rect() var map_cellsize = world.cell_size for cam in [camera1, camera2]: cam.limit_left = map_limits.position.x * map_cellsize.x cam.limit_right = map_limits.end.x * map_cellsize.x cam.limit_top = map_limits.position.y * map_cellsize.y cam.limit_bottom = map_limits.end.y * map_cellsize.y Minimap Let’s add one more fun feature: a minimap showing a zoomed-out view of the entire map so the players can orient themselves.\nWe’ll need another ViewportContainer, this one a child of Main. This time, we don’t want to use Stretch. Add a Viewport and set its Size to (340, 200) then add a Camera2D. We’ll set the Camera2D’s Position to (512, 300) to center it on the screen. We’ll zoom out by setting Zoom to (9, 9). Don’t forget to click Current on this camera as well.\nIn the _ready(), set the minimap to use the same world as the other two viewports:\n$Minimap/Viewport.world_2d = viewport1.world_2d Use the “Layout” menu to align the Minimap container at “Center Bottom”. Let’s see what it looks like:\nWe need to get rid of that grey area around the edges. We could find the precise zoom level that matches our desired minimap size, but instead, we’ll check the Transparent Bg on the Viewport. Now our non-map areas aren’t visible and the minimap appears floating directly on top of the main viewports.\nConclusion Viewports can be very powerful, but also confusing. One way of managing them is to try to keep them separate from the game logic and only use them as displays.\n","description":"","tags":null,"title":"Splitscreen multiplayer","uri":"/godot_recipes/3.x/2d/splitscreen_demo/"},{"content":"Problem You want to use a spritesheet containing 2D animations.\nSolution Spritesheets are a common way for 2D animations to be distributed. In a spritesheet, all of the animation frames are packed into a single image.\nFor this demo, we’ll be using the excellent “Adventurer” sprite by Elthen. You can get this and lots of other great art athttps://elthen.itch.io/.\nWarning Make sure the images in your spritesheet are laid out in a constant-sized grid. This will enable Godot to automatically slice them. If they’re packed irregularly, you will not be able to use the following technique.\nNode setup This animation technique uses a Sprite node to display the texture, and then we animate the changing frames with AnimationPlayer. This can work with any 2D node, but for this demo, we’ll use a KinematicBody2D.\nAdd the following nodes to your scene:\nKinematicBody2D: Player Sprite CollisionShape2D AnimationPlayer Drag the spritesheet texture into the Texture property of the Sprite. You’ll see the entire spritesheet displayed in the viewport. To slice it up into individual frames, expand the “Animation” section in the Inspector and set the Hframes to 13 and Vframes to 8. Hframes and Vframes are the number of horizontal and vertical frames in your spritesheet.\nTry changing the Frame property to see the image change. This is the property we’ll be animating.\nAdding animations Select the AnimationPlayer and click the “Animation” button followed by “New\" . Name the new animation “idle”. Set the animation length to 2 and click the “Loop” button so that our animation will repeat (see below).\nWith the scrubber at time 0, select the Sprite node. Set its Animation/Frame to 0, then click the key icon next to the value.\nIf you try playing the animation, you’ll see it doesn’t appear to do anything. That’s because the last frame (12) looks the same as the first (0), but we’re not seeing any of the frames in-between (1-11). To fix this, change the “Update Mode” of the track from its default value of “Discrete” to “Continuous”. You can find this button at the end of the track on the right side.\nNote that this will only work for spritesheets where the frames are already in order. If they are not, you’ll have to keyframe each Frame seperately along the timeline.\nFeel free to add the other animations yourself. For example, the “jump” animation is on frames 65 through 70.\nRelated recipes Top-down character Platform character Controlling animation states ","description":"","tags":null,"title":"Spritesheet animation","uri":"/godot_recipes/3.x/animation/spritesheet_animation/"},{"content":"Problem You have a KinematicBody2D character colliding with a TileMap, and you want to know which tile it collided with.\nSolution When a KinematicBody2D collides, the collision data is returned in a KinematicCollision2D object. The TileMap acts as a single collider, so if you reference the collider property, it will be the TileMap node.\nYou then need to find out which tile in the TileMap is at the collision location.\nAssume you’ve obtained a KinematicCollision2D object stored in the variable collision:\n# Confirm the colliding body is a TileMap if collision.collider is TileMap: # Find the character's position in tile coordinates var tile_pos = collision.collider.world_to_map(position) # Find the colliding tile position tile_pos -= collision.normal # Get the tile id var tile_id = collision.collider.get_cellv(tile_pos) Once you have the tile_id, you can get the tile properties from the TileSet resource, found in the TileMap’s tile_set property. For example, to get the name of the tile:\nvar tile_name = collision.collider.tile_set.tile_get_name(tile_id) You can also change the tile by setting it to a new id:\ncollision.collider.set_cellv(tile_pos, new_id) Related recipes TileMap: using autotile TileMap: animated tiles Like video? ","description":"","tags":null,"title":"TileMap: detecting tiles","uri":"/godot_recipes/3.x/2d/tilemap_collision/"},{"content":"Problem You’re making a 2D top-down game, and you want to control a character’s movement.\nSolution For this solution, we’ll assume you have the following input actions defined:\nAction Name Key(s) \"up\" W,↑ \"down\" S,↓ \"right\" D,→ \"left\" A,← \"click\" Mouse button 1 We will also assume you’re using a KinematicBody2D character.\nWe can solve this problem in many ways, depending on what type of behavior you’re looking for.\nOption 1: 8-way movement In this scenario, the player uses the four directional keys to move (including diagonals).\nextends KinematicBody2D var speed = 200 # speed in pixels/sec var velocity = Vector2.ZERO func get_input(): velocity = Vector2.ZERO if Input.is_action_pressed('right'): velocity.x += 1 if Input.is_action_pressed('left'): velocity.x -= 1 if Input.is_action_pressed('down'): velocity.y += 1 if Input.is_action_pressed('up'): velocity.y -= 1 # Make sure diagonal movement isn't faster velocity = velocity.normalized() * speed func _physics_process(delta): get_input() velocity = move_and_slide(velocity) Option 2: Rotate and move In this scenario, the left/right actions rotate the character and up/down move the character forward and back in whatever direction it’s facing. This is sometimes referred to as “Asteroids-style” movement.\nextends KinematicBody2D var speed = 200 var rotation_speed = 1.5 var velocity = Vector2.ZERO var rotation_dir = 0 func get_input(): rotation_dir = 0 velocity = Vector2.ZERO if Input.is_action_pressed('right'): rotation_dir += 1 if Input.is_action_pressed('left'): rotation_dir -= 1 if Input.is_action_pressed('down'): velocity -= transform.x * speed if Input.is_action_pressed('up'): velocity += transform.x * speed func _physics_process(delta): get_input() rotation += rotation_dir * rotation_speed * delta velocity = move_and_slide(velocity) Option 3: Aim with mouse Similar to option 2, but this time the character rotation is controlled with the mouse (ie the character always points towards the mouse). Forward/back movement is done with the keys as before.\nextends KinematicBody2D var speed = 200 var velocity = Vector2.ZERO func get_input(): velocity = Vector2.ZERO if Input.is_action_pressed(\"forward\"): velocity += transform.x * speed if Input.is_action_pressed(\"back\"): velocity -= transform.x * speed func _physics_process(delta): look_at(get_global_mouse_position()) get_input() velocity = move_and_slide(velocity) Option 4: Click and move In this option, the character moves to the clicked location.\nextends KinematicBody2D var speed = 200 var target = null var velocity = Vector2.ZERO func _input(event): if event.is_action_pressed('click'): target = event.position func _physics_process(delta): if target: look_at(target) velocity = transform.x * speed # stop moving if we get close to the target if position.distance_to(target) \u003e 5: velocity = move_and_slide(velocity) Option 5: Adding friction All of the movement methods above move and change direction instantly - there’s no acceleration or friction. What if we want to ramp our velocity up from or down to zero? Let’s add some code to interpolate or “lerp” the velocity after getting the input.\nWe’ll use the code from Option 1: 8-way movement movement.\nextends KinematicBody2D export var speed = 200 export var friction = 0.01 export var acceleration = 0.1 var velocity = Vector2() func get_input(): var input = Vector2() if Input.is_action_pressed('right'): input.x += 1 if Input.is_action_pressed('left'): input.x -= 1 if Input.is_action_pressed('down'): input.y += 1 if Input.is_action_pressed('up'): input.y -= 1 return input func _physics_process(delta): var direction = get_input() if direction.length() \u003e 0: velocity = lerp(velocity, direction.normalized() * speed, acceleration) else: velocity = lerp(velocity, Vector2.ZERO, friction) velocity = move_and_slide(velocity) Now our input isn’t applied directly to the velocity but rather used to “push” the velocity towards the input direction. If there’s no input, we ramp down towards zero.\n","description":"","tags":null,"title":"Top-down movement","uri":"/godot_recipes/3.x/2d/topdown_movement/"},{"content":"Problem You need to understand in what order Godot handles nodes in the scene tree.\nSolution “Tree order” is mentioned often in the Godot docs and in tutorials. However, it is not always obvious to a beginner what is meant by this. Generally speaking, the order in which nodes are handled in the tree is in top-down fashion, starting at the root and going down each branch in turn.\nScene tree order is something that can cause a great deal of confusion for Godot beginners. In this example, we’ll illustrate in what order things happen.\nHere’s our sample node setup:\nOn each node, we have the following script attached:\nextends Node func _init(): # Note: a Node doesn't have a \"name\" yet here. print(\"TestRoot init\") func _enter_tree(): print(name + \" enter tree\") func _ready(): print(name + \" ready\") # This ensures we only print *once* in process(). var test = true func _process(delta): if test: print(name + \" process\") test = false Before we talk about the results, let’s review what each of these callback functions represents:\n_init() is called when the object is first created. It now exists in the computer’s memory.\n_enter_tree() is called when the node first enters the tree. This can be when instancing or when add_child() is used, for example.\n_ready() is called when the node and its children have all been added to the tree and are ready.\n_process() is called every frame (typically 60 times per second) on every node in the tree.\nIf we ran this on a single node all by itself, the order would be as you might expect:\nTestRoot init TestRoot enter tree TestRoot ready TestRoot process Once we add children to the mix, it becomes a bit more complex, and probably needs some clarification:\nTestRoot init TestChild1 init TestChild3 init TestChild2 init TestRoot enter tree TestChild1 enter tree TestChild3 enter tree TestChild2 enter tree TestChild3 ready TestChild1 ready TestChild2 ready TestRoot ready TestRoot process TestChild1 process TestChild3 process TestChild2 process As you can see, all of these nodes printed their messages in tree order, from top to bottom, following branches first - with the exception of the _ready() code.\nHere’s a quote from the Node reference:\nCalled when the node is “ready”, i.e. when both the node and its children have entered the scene tree. If the node has children, their _ready callbacks get triggered first, and the parent node will receive the ready notification afterwards.\nThis leads to an important rule-of-thumb to remember when setting up your node structure:\nTip Parent nodes should manage their children, not vice-versa.\nThis means any code in the parent must be able to fully access any data in its children. For that reason, _ready() must be processed in reverse tree order.\nRemember this when trying to access other nodes in _ready(). If you need to go up the tree to a parent (or grandparent), you should probably run that code in the parent rather than the child.\nRelated recipes Understanding node paths ","description":"","tags":null,"title":"Understanding tree order","uri":"/godot_recipes/3.x/basics/tree_ready_order/"},{"content":"Project Manager The Project Manager is the first thing you’ll see when opening Godot.\nIn this window you can see a list of your Godot projects. You can choose an existing project and click “Run” to play the game or click “Edit” to work on it in the Godot editor. Since you probably don’t have any projects yet, let’s start by clicking the “New Project” button.\nHere you can give the project a name and create a folder to store it in.\nNote Every Godot project is contained in its own folder. This has many benefits, including making it easy to move, share, and backup projects. It also means that all the project’s files (images, sounds, etc.) must be in the project folder.\nWhen you’re naming your project, try to choose a name that describes the project. “New Game Project #23” is not going to help you remember what that project was. You should also think about compatibility: some operating systems are case-sensitive, and some are not. This can lead to problems if you move or share your project from one computer to another. For this reason, many programmers develop a standardized naming scheme. For example: “No spaces, use ‘_’ between words.”\nLet’s name this new project “getting_started”. Type this name, click “Create Folder”, and then click “Create \u0026 Edit”.\nYou’re now looking at the Godot editor window. This is where you’ll spend most of your time when working in Godot. The editor is divided into sections.\nViewport: This is where you’ll see the parts of your game as you’re working on them. Main Menu: Here you can save and load files, edit project settings, and search for help. Workspaces: At the center-top, you can switch between working in the 2D, 3D, or Script workspaces. You start in 3D. Playtest Buttons: These buttons let you launch and control your game when testing. Docks: On both sides are a number of docks where you can view game items and set their properties. Project Settings Now we’ve talked about the main parts of the Godot window and how they work, let’s spend a little time talking about our Project settings. Usually one of the first tasks when starting a new project is make sure it’s all set up correctly.\nSo let’s click on “Project” in the menu and select “Project Settings”.\nThis is the Project settings window. On the left is a list of categories. For most projects, the default settings will be fine, and you shouldn’t worry about changing them unless you have a very specific need. For now, we’re just going to look at two of the sections. First, “Application/Config”.\nIn here, you can set your game’s title, choose which scene is the “main scene” (more about that in a bit), and change the icon.\nSecond, let’s look at the “Display” section. This is where you set up your game’s display. width \u0026 height let you set the size of the game window. If, for example, you were making a mobile game, you’d want to set this to the resolution and proportions of your target device. There are also settings for scaling, stretching, fullscreen mode, and more. For now, we’ll leave the default size - later on we’ll talk about how to adjust these to get our game running on different devices.\nThere are also some tabs across the top. We’ve been looking at the “General” tab. I’ll also point out briefly, the “Input Map”. This is where you can define different input actions for keyboard control, gamepad, mouse, and so on. In your game, you’ll just worry about the action, not what individual key or button was pressed. This is a very powerful and flexible way of handling player input.\nWe also have localization options, if you plan to support multiple languages. Autoloading, which we’ll get to later, and plugins. The Godot community has created a variety of useful plugins that you can download and add to supply more features, different tools, and so on.\nWe’ll come back to the project settings window later. Let’s close it for now and we’re ready to move on to the next step: working with nodes.\n","description":"","tags":null,"title":"Godot's Editor: Finding your way around","uri":"/godot_recipes/3.x/g101/start/101_02/"},{"content":" Basics Basic Godot tips and tricks that apply to any project.\nIn this section: Understanding tree order Node communication (the right way) Understanding node paths Understanding 'delta' Saving/loading data Circular movement Using Custom Resources ","description":"","tags":null,"title":"Basics","uri":"/godot_recipes/3.x/basics/"},{"content":"In the last part, we started a 3D project and looked at how to navigate and create 3D objects. In this part, you’ll learn how to import existing 3D objects that you’ve made or downloaded and how to use more of Godot’s 3D nodes.\nImporting 3D Objects If you’re familiar with 3D modeling software such as Blender, you can make your own models to use in your game. If not, there are many sources where you can download objects or even collections of objects for particular game types. One of our favorite makers of free game art is Kenney.nl.\nFor our tutorials, we’re going to use Kenney’s Platformer Kit, which you can download here: https://kenney.nl/assets/platformer-kit\nThis kit has a wide selection of objects that we can use to practice our Godot 3D skills. Here’s a sample showing what the kit looks like:\nOnce you’ve downloaded the kit, you’ll find that the objects inside are provided in a variety of different formats. Godot is able to use several of these, but since GLTF is available in this pack, it’s preferred over the others. Copy the “GLTF Format” folder into your Godot project’s folder and rename it to “platformer kit”.\nTip If you’re interested in the differences between the formats, here’s a brief summary: OBJ files are the simplest, each representing a mesh which you can load into a MeshInstance node. This is likely the most common file type you’ll find online. DAE (Collada) files are more robust - Godot loads them as individual scenes, and they can include additional data along with the mesh such as animations. GLTF files are similar, but represent a more modern format with additional features.\nWhen you switch back to your Godot window, you’ll see progress bar while Godot scans the folder and imports all of the objects. Let’s click on one of them to see what’s going on. In the “FileSystem” tab, select the “crate.glb” and then click on the “Import” tab:\nHere you can see the cube object will be imported as a scene, with its root type set to Spatial and named “Scene Root”. Let’s change these: set the root type to RigidBody and the root name to “Crate”, then click the “Reimport” button.\nNow double-click on “crate.glb” and confirm that you want to make a new inherited scene. Here we have a classic game object: the crate. The root node of the scene is a RigidBody named “Crate” just as we wanted. However, there’s one small problem: it seems Kenney exported this model with an offset:\nIt would much better if the crate were centered relative to the parent node, so that when the RigidBody rotates about its center, so will the mesh. To fix this, select the MeshInstance node and set its Translation property to (-0.5, -0.25, 0.5).\nFinally, we need to add a collision shape to the body. Add a CollisionShape node as a child of the Crate. In its Shape property, choose “New BoxShape”. Use the three handles (they look like orange circles) to size the box to fit the mesh. You can also set the extents directly in the Inspector:\nNote that since the crate is 0.5 units wide, the Extents, which represent the distance from the center, becomes 0.25 units.\nNow we’re finished setting up the object. Save your Crate scene and let’s see how we can use it.\nBuilding a 3D Scene Create a new scene with a Spatial root. The first child we’ll add is one to give us a “ground” to stack some crates on. Add a StaticBody called “Ground”, and to that add a MeshInstance. In the Mesh property, select “New PlaneMesh” and then click it to open its properties. Set Size to (10, 10) so that we have a nice large surface. However, it would look better if it weren’t plain white.\nAlso in the mesh properties is a Material property. Materials are how you define the appearance of an object. Select “New SpatialMaterial” and then click it to open a large list of properties. To set the color of the mesh, we need the Albedo property. Choose a color, such as brown or dark green.\nIf we add a crate, it will fall right through the mesh, so we also need to give it a collision shape. With the crate, we added a CollisionShape node and assigned a shape. That’s one way to add collision, let’s look at another: select the mesh and in the menu at the of the viewport, choose “Create Convex Collision Sibling”. This will automatically create a CollisionShape node as a sibling of the mesh and assign it a shape that matches the mesh.\nNow instance a few crates in the scene and arrange them in a rough stack. Add a Camera and place it where it has a good view of the crates. Run the scene and watch your crates go tumbling!\nRotating Camera Let’s make the camera a little more dynamic by having it slowly orbit around the scene. Add a Spatial, which will be located at (0, 0, 0) and name it “CameraHub”. In the scene tree, drag the camera to make it a child of this new Spatial. Now, if the Spatial rotates around the y axis, it will drag the camera along with it.\nAdd a script to the root node and add the following:\nextends Spatial func _process(delta): $CameraHub.rotate_y(0.01) Run the scene to see what happens.\nLighting There’s another thing we can add to the scene to improve how it looks: light. There are multiple light nodes available in 3D, but we’re going to start with DirectionalLight. Add one to the scene and use the green (Y) arrow to pull it up into the air.\nA DirectionalLight simulates an infinite number of parallel rays of light, as if from a distant source like the sun. It will not cast shadows by default; to add shadows, click Enabled in the “Shadow” section. There is also a “DirectionalShadow” section, which contains a number of advanced properties for fine-tuning the shadow appearance. For full details see this document.\nNote that it really doesn’t matter where you place the node - only the direction of the light arrow matters.\nWrapping Up In this tutorial you learned how to import 3D objects from outside sources, and how to combine them into a simple scene. We also investigated lights and moving cameras.\nIn the next part, we’ll look at how to build a more complex scene and include a player-controlled character.\nYou can also find a video version of this lesson here:\n","description":"","tags":null,"title":"Importing 3D Objects","uri":"/godot_recipes/3.x/g101/3d/101_3d_02/"},{"content":"Problem You’ve got a kinematic car, but you don’t like the “on rails” feeling, especially at high speeds. You’d like to have some “slip” so that you can have drifting and loss of traction.\nSolution When the car is drifting, the heading of the car (the direction it’s pointing) may not be the same as its velocity (the direction it’s moving). Turning the wheel will make the car turn, but the velocity will not instantly “catch up” - instead, we’ll use lerp() (linear interpolation) to gradually move the velocity to the desired direction.\nAdd the following new variables to car_base.gd:\nexport var slip_speed = 9.0 export var traction_slow = 0.75 export var traction_fast = 0.02 var drifting = false slip_speed is how fast the car needs to be going before losing traction. You’ll need to adjust this based on the car’s other parameters.\ntraction_slow and traction_fast represent the traction when below or above the slip_speed, ranging from 0 - 1. Smaller numbers mean the car will feel more “slippery”. Setting them to 1 will be “on rails” with no sliding at all.\ndrifting is a boolean variable to keep track of the drifting state.\nNext, add this code to the calculate_steering() function in car_base.gd, right after calculating the new_heading:\n# traction if not drifting and velocity.length() \u003e slip_speed: drifting = true if drifting and velocity.length() \u003c slip_speed and steer_angle == 0: drifting = false var traction = traction_fast if drifting else traction_slow This code sets the drifting state as appropriate, and then selects which traction value to use.\nThe last piece of the puzzle is to interpolate the velocity to the new heading. Change this line:\nvelocity = new_heading * velocity.length() to this:\nvelocity = lerp(velocity, new_heading * velocity.length(), traction) Wrapping up At this point, we have a large number of parameters to adjust, giving us a very wide range of behavior for the car. Depending on the style of driving you’re going for, your number might be very different from the ones used here.\nIf you’re looking to add more, here are some of the topics we’ll address in follow-up recipes:\nChase camera and camera control AI/NPC control (steering, obstacle avoidance, track following) Slopes and ramps Related recipes Kinematic Car: Base 2D: Car Steering recipe Input Actions 3D: KinematicBody Movement Like video? ","description":"","tags":null,"title":"3D Kinematic Car: Traction/Drifting","uri":"/godot_recipes/3.x/3d/kinematic_car/car_traction/"},{"content":"Problem Your game has data that is needed by more than one scene. Your player’s score, for example, needs to be accessed by various game objects (to increase it) and by the HUD (to display it). Furthermore, if you’re changing scenes using change_scene(), you don’t want that data to be lost when the old scene is freed.\nSolution To solve this problem, Godot provides the concept of an Autoload. This is a scene (or script) that you want the engine to automatically load at runtime. This scene’s node(s) will be added to the root viewport before any other scenes are loaded.\nNote If you autoload a script, Godot will create a Node and attach the script to it.\nAdding Autoloads You can create any number of autoloads in your game by opening Project Settings and clicking the “AutoLoad” tab:\nClick the folder button to navigate to the file you want to autoload, set an optional “Node Name” (the name it’ll have in the scene tree), and click the “Add” button.\nFor example, as described in the Audio Manager recipe, here’s the audio manager scene added as an autoload:\nTip If you have multiple autoloads they’ll be added in the order listed. You can drag-and-drop them to change the order.\nAnd when the game is run, looking at the remote scene tree will show you where the autoload was added, as a direct child of the root viewport:\nSingleton As an option when adding an autoload, you can declare it as a singleton by checking the “Enable” box. This makes the Name of the autoload a globally-registered value, so that you can refer to it from anywhere in your game.\nFor example, by loading the audio manager above and choosing the singleton option, you can now access it in any script:\nAudioManager.play(\"res://path/to/sound\") Wrapping up Autoloads/singletons are useful in many situations you may encounter. For example:\nMaking your UI an autoload lets you keep it always present, hiding/showing it whenever needed, regardless of what scene you currently have loaded. Persistent data, such as player score can be kept as a property of your singleton and accessed from anywhere. Keep global configuration data in a singleton so that any node can easily find it upon being instanced. Related recipes Audio Manager Displaying Debug Data ","description":"","tags":[],"title":"Autoloads/ Singletons","uri":"/godot_recipes/3.x/recipes/singleton/"},{"content":"Problem Your UI has problem(s): it’s become overcomplicated, it doesn’t resize well, and/or you can’t keep track of how everything fits together.\nSolution For many developers, building a UI is their least favorite part. It’s very easy for a complex UI to spiral out of control and become impossibly painful to fix or modify. Godot provides some great tools for building UI - and if you take the time to learn to use them, you’ll find that they take away a lot of that pain.\nThe solution is the Container. Containers provide a lot of power in building your UI’s layout.\nWhen a Control node is added to a Container, the container takes over all the control’s positioning information. You can no longer set the size, position, or other layout properties of the container’s children.\nThis is the key thing to remember about containers:\nWarning A Container node automatically arranges its children. You cannot directly control the position of a child UI node.\nLet’s look at some of the most commonly used containers:\nCenterContainer\nThis container places keeps its children centered.\nMarginContainer\nThis container maintains a margin, preventing children from getting too close to the edges of the container. Margin values can be set in the “Custom Constants” section of the properties.\nVBoxContainer/ HboxContainer\nThese containers keep their contents aligned vertically or horizontally, respectively. In the “Custom Constants” section you can also set a Separation property to increase spacing between elements.\nGridContainer\nThis container arranges its children in a grid pattern.\nSize flags The way a container handles its children is mainly controlled by their “Size Flags” properties.\nFill\nWhen this option is checked, the control fills its assigned location in the container. This option is enabled by default.\nExpand\nIf this option is checked, the control tries to use as much space as it can. Nodes without Expand selected are pushed by those that do.\nShrink Center\nWhen Fill is disabled and Expand is enabled, the control remains at the center of its area, rather than the beginning.\nShrink End\nSame as above, except the control stays to the end rather than the beginning.\nStretch Ratio\nThis ratio sets the amount that expanding controls take up relative to each other.\nA good way to experiment with these settings is to set up a test scene like the following:\nTry adjusting the “Size Flags” properties of the different buttons and see how it affects their positioning in the HBoxContainer.\nNesting Containers For more complex UI setups, you’ll need to use containers holding other containers. Each item in a GridContainer, for example, may itself be a VBoxContainer, with all of it inside a MarginContainer.\nAll these containers inside containers can cause your scene tree to become quite large and hard to manage, especially if you have a lot of repeated elements, such as buttons and labels. It’s recommended that you break your UI into pieces and save each part as a separate scene that you can instance in the larger scene.\nRelated recipes Labels ","description":"","tags":null,"title":"Containers","uri":"/godot_recipes/3.x/ui/containers/"},{"content":"Problem You need a 2D character that moves in a grid pattern.\nSolution Grid- or tile-based movement means the character’s position is restricted. They can only stand on a particular tile - never between two tiles.\nCharacter setup Here are the nodes we’ll use for the player:\nArea2D (“Player”): Using an Area2D means we can detect overlap (for picking up objects or colliding with enemies). Sprite: You can use a sprite sheet here (we’ll set up the animation below). CollisionShape2D: Don’t make the hitbox too big. Since the player will be standing on the center of a tile, overlaps will be from the center. RayCast2D: For checking if movement is possible in the given direction. Tween: For interpolating movement from tile to tile. AnimationPlayer: For playing the character’s walk animation(s). Add some input actions to the Input Map. We’ll use “up”, “down”, “left”, and “right” for this example.\nBasic movement We’ll start by setting up the tile-by-tile movement, without any animations or interpolation.\nextends Area2D var tile_size = 64 var inputs = {\"right\": Vector2.RIGHT, \"left\": Vector2.LEFT, \"up\": Vector2.UP, \"down\": Vector2.DOWN} tile_size should be set to match the size of your tiles. In a larger project, this can be set by your main scene when instancing the player. We’re using 64x64 tiles in the example below.\nThe inputs dictionary maps the input action names to direction vectors. Make sure you have the names spelled the same here and in the Input Map (capitalization counts!).\nfunc _ready(): position = position.snapped(Vector2.ONE * tile_size) position += Vector2.ONE * tile_size/2 snapped() allows us to “round” the position to the nearest tile increment, and adding a half-tile amount makes sure the player is centered on the tile.\nfunc _unhandled_input(event): for dir in inputs.keys(): if event.is_action_pressed(dir): move(dir) func move(dir): position += inputs[dir] * tile_size Here’s the actual movement code. When an input event occurs, we check the four directions to see which one matched, then pass it to move() to change the position.\nCollision Now we can add some obstacles. You can add StaticBody2Ds to manually add some obstacles (enable snapping to make sure they’re aligned with the grid) or use a TileMap (with collisions defined), as in the example below.\nWe’ll use the RayCast2D to determine whether a move to the next tile is allowed.\nonready var ray = $RayCast2D func move(dir): ray.cast_to = inputs[dir] * tile_size ray.force_raycast_update() if !ray.is_colliding(): position += inputs[dir] * tile_size When changing a raycast’s cast_to property, the physics engine won’t recalculate its collisions until the next physics frame. force_raycast_update() lets you update the ray’s state immediately. If it’s not colliding, then we allow the move.\nNote Another common method is to use 4 separate raycasts, one for each direction.\nAnimating movement Lastly we can interpolate the position between tiles, giving a smooth feel to the movement. We’ll use the Tween node to animate the position property.\nonready var tween = $Tween export var speed = 3 Add a reference to the Tween node and a variable to set our movement speed.\nfunc _unhandled_input(event): if tween.is_active(): return for dir in inputs.keys(): if event.is_action_pressed(dir): move(dir) We’ll ignore any input while the tween is running.\nfunc move(dir): ray.cast_to = dir * tile_size ray.force_raycast_update() if !ray.is_colliding(): #\tposition += dir * tile_size move_tween(dir) Remove the direct position change and call a function to activate the tween:\nfunc move_tween(dir): tween.interpolate_property(self, \"position\", position, position + dir * tile_size, 1.0/speed, Tween.TRANS_SINE, Tween.EASE_IN_OUT) tween.start() Experiment with different tween transitions for different movement effects.\nYou can download a complete project of this example: grid_based_movement.zip\nRelated Recipes Input Actions Interpolation ","description":"","tags":null,"title":"Grid-based movement","uri":"/godot_recipes/3.x/2d/grid_movement/"},{"content":"Problem You want to understand Godot’s “input action” system.\nSolution Let’s say you’re making a top-down character and you write code using InputActionKey that uses the arrow keys for movement. You’ll quickly find that many players prefer to use “WASD” style controls. You can go back into your code and add the additional key checks, but this would result in duplicated/redundant code.\nInput actions can help to make your code more configurable. Rather than hard-coding specific keys, you’ll be able to modify and customize them without changing the code.\nCreating inputs You define input actions in the “Project Settings” under the “Input Map” tab. Here, you can create new actions and/or assign inputs to them.\nYou’ll see when you click on the tab there are already some default actions configured. They are all named “ui_*” to indicate that they are the default interface actions. “Tab” for next UI element, for example.\nGenerally speaking, you should create your own actions for your game, rather than use the existing ones.\nFor this example, let’s say you want to allow the player to control the game with the keyboard or the mouse. They need to be able to shoot by pressing either the left mouse button or the spacebar.\nCreate the new action “shoot” by typing the name in the “Action” field at the top and clicking “Add” (or pressing enter). Scroll to the bottom and you’ll see the new action has been added to the list.\nNow you can assign inputs to this action by clicking the “+” sign to the right. Inputs can be keys, mouse buttons, or joy/gamepad inputs. Choose “Key” and you can press the key on the keyboard you want to assign - let’s press the spacebar - and click “OK”.\nClick “+” to add another input, and this time choose “Mouse Button”. The default of “Device 0” and “Left Button” is fine, but you can select others if you like.\nUsing input actions You can check for the action either by polling the Input singleton every frame:\nfunc _process(delta): if Input.is_action_pressed(\"shoot\"): # This will execute every frame as long as the input is held. This is best for continuous actions - i.e. those you want to check constantly, such as movement.\nIf instead you want to detect the action at the moment it occurs, you can use the _input() or _unhandled_input() callbacks:\nfunc _unhandled_input(event): if event.is_action_pressed(\"shoot\"): # This will run once on the frame when the action is first pressed There are several functions you can use for checking input state:\nis_action_pressed(): This function returns true if the action is currently in the pressed state.\nis_action_released(): This function returns true if the action is not In the pressed state.\nis_action_just_pressed() / is_action_just_released(): These methods work like the above, but only return true on the single frame after the event occurs. This is useful for non-recurring actions like shooting or jumping where the user needs to let go and then press the key again to repeat the action.\nRelated Recipes Inputs: Introduction ","description":"","tags":null,"title":"Input Actions","uri":"/godot_recipes/3.x/input/input_actions/"},{"content":"Problem You want to interact with a Godot shader from GDScript.\nSolution To access the uniform’s value from GDScript, you can use set_shader_param() on the object’s material property. If the attached material is a ShaderMaterial, then you can access it like so:\nnode.material.set_shader_param(\"param_name\", value) You can also get the value with get_shader_param().\nFor an example of this, see the Blur Shader recipe.\nRelated Recipes Shaders: Intro ","description":"","tags":null,"title":"Interacting with Shaders","uri":"/godot_recipes/3.x/shaders/interacting/"},{"content":"Problem You need a 3D camera that smoothly follows a target (interpolates).\nSolution Info Godot’s built-in InterpolatedCamera node is deprecated and will be removed in the release of Godot 4.0.\nAttach the script below to a Camera node in your scene. The three export properties let you choose:\nlerp_speed - the camera’s movement speed. Lower values result in a “lazier” camera. target_path - choose the camera’s target node. offset - position of the camera relative to the target. See below for some examples of the camera in action.\nextends Camera export var lerp_speed = 3.0 export (NodePath) var target_path = null export (Vector3) var offset = Vector3.ZERO var target = null func _ready(): if target_path: target = get_node(target_path) func _physics_process(delta): if !target: return var target_pos = target.global_transform.translated(offset) global_transform = global_transform.interpolate_with(target_pos, lerp_speed * delta) look_at(target.global_transform.origin, Vector3.UP) In the _physics_process() function we interpolate the camera’s position with the target’s (plus offset).\nExamples lerp_speed: 3.0 offset: (0, 7, 5) ","description":"","tags":null,"title":"Interpolated Camera","uri":"/godot_recipes/3.x/3d/interpolated_camera/"},{"content":" Know Your Nodes In the “Know Your Nodes” series, we go in-depth with a single one of Godot’s nodes. Learn what makes it tick and see some examples of how it’s used.\nIn this section: Label Path2D \u0026 PathFollow2D RayCast2D RigidBody2D YSort ","description":"","tags":null,"title":"Know Your Nodes","uri":"/godot_recipes/3.x/kyn/"},{"content":"Problem You want to detect mouse input.\nSolution InputEventMouse is the base class for mouse events. It contains position and global_position properties. Inheriting from it are two classes: InputEventMouseButton and InputEventMouseMotion.\nNote You can assign mouse button events in the InputMap, so you can use them with is_action_pressed().\nInputEventMouseButton @GlobalScope.ButtonList contains a list of BUTTON_* constants for each possible button, which will be reported in the event’s button_index property. Note that the scrollwheel also counts as a button - two buttons, to be precise, with both BUTTON_WHEEL_UP and BUTTON_WHEEL_DOWN being separate events.\nTip Unlike regular buttons, mouse wheel clicks only produce pressed events. There is no concept of a mouse wheel click being “released”.\nfunc _unhandled_input(event): if event is InputEventMouseButton: if event.button_index == BUTTON_LEFT: if event.pressed: print(\"Left button was clicked at \", event.position) else: print(\"Left button was released\") if event.button_index == BUTTON_WHEEL_DOWN: print(\"Wheel down\") InputEventMouseMotion These events occur whenever the mouse moves. You can find the distance moved (in screen coordinates) with the relative property.\nHere’s an example using mouse movement to rotate a 3D character:\n# Converts mouse movement (pixels) to rotation (radians). var mouse_sensitivity = 0.002 func _unhandled_input(event): if event is InputEventMouseMotion: rotate_y(-event.relative.x * mouse_sensitivity) ","description":"","tags":null,"title":"Mouse Input","uri":"/godot_recipes/3.x/input/mouse_input/"},{"content":" Info Many thanks to @TheDuriel on the Godot Discord for the original diagram that inspired this article. Save this and keep it handy.\nProblem Your project has started getting complex. You have multiple scenes, instances, and a lot of nodes. You’ve probably found yourself writing code like the following:\nget_node(\"../../SomeNode/SomeOtherNode\") get_parent().get_parent().get_node(\"SomeNode\") get_tree().get_root().get_node(\"SomeNode/SomeOtherNode\") If you do this, you’ll soon find that node references like this break easily. As soon as you change one thing about your scene tree, none of those references may be valid anymore.\nCommunication between nodes and scenes doesn’t have to be complicated. There is a better way.\nSolution As a general rule, nodes should manage their children, not the other way around. If you’re using get_parent() or get_node(\"..\"), then you’re probably headed for trouble. Node paths like this are brittle, meaning they can break easily. The three main problems with this arrangement:\nYou can’t test a scene independently. If you run the scene by itself or in a test scene that doesn’t have the exact same node setup, get_node() will cause a crash.\nYou can’t change things easily. If you decide to rearrange or redesign your tree, paths will no longer be valid.\nReady order is children-first, parent-last. This means that trying to access a parent’s property in a node’s _ready() can fail because the parent isn’t ready yet.\nTip See Understanding tree order for an explanation of how nodes enter the tree and become ready.\nGenerally speaking, a node or scene should be able to be instanced anywhere in your game, and it should make no assumptions about what its parent is going to be.\nWe’ll go into detailed examples later in this tutorial, but for now, here’s the “golden rule” of node communication:\nCall down, signal up.\nIf a node is calling a child (i.e. going “down” the tree), then get_node() is appropriate.\nIf a node needs to communicate “up” the tree, it should probably use a signal.\nIf you keep this rule in mind when designing your scene setup, you’ll be well on your way to a maintainable, well-organized project. And you’ll avoid using the cumbersome node paths that lead to problems.\nNow, let’s look at each of these strategies along with some examples.\n1. Using get_node() get_node() traverses the scene tree using a given path to find the named node.\nTip See Understanding node paths for a more detailed explanation of node paths.\nget_node() example Let’s consider the following common configuration:\nThe script in the Player node needs to notify the AnimatedSprite which animation to play, based on the player’s movement. In this situation, get_node() works well:\nextends KinematicBody2D func _process(delta): if speed \u003e 0: get_node(\"AnimatedSprite\").play(\"run\") else: get_node(\"AnimatedSprite\").play(\"idle\") Tip In GDScript you can use $ as a shorthand for get_node(), writing $AnimatedSprite instead.\n2. Using signals Signals should be used to call functions on nodes that are higher in the tree or at the same level (i.e. “siblings”).\nYou can connect a signal in the editor (most often for nodes that exist before the game starts) or in code (for nodes that you’re instancing at runtime). The syntax for connecting a signal is:\nsource_node.connect(\"\u003csignal_name\u003e\", target_node, \"\u003ctarget_function\"\u003e)\nLooking at this, you may be thinking “Wait, if I’m connecting to a sibling, won’t I need a node paths like ../Sibling?”. While you could do this, it breaks our rule above. The answer to this puzzle is to make sure that connections are made by the common parent.\nFollowing the rule of calling down the tree, a node that’s a common parent to the signaling and receiving nodes will by definition know where they are and be ready after both of them.\nSignal example A very common use case for signals is updating your UI. Whenever the player’s health variable changes, you want to update a Label or ProgressBar display. However, your UI nodes are completely separated from your player (as they should be). The player knows nothing about where those nodes are and how to find them.\nHere’s our example setup:\nNote that the UI is an instanced scene, we’re just showing the contained nodes. This is where you often see things like get_node(\"../UI/VBoxContainer/HBoxContainer/Label).text = str(health), which is what we want to avoid.\nInstead the player emits a health_changed signal whenever it adds/loses health. We need to send that signal to the UI’s update_health() function, which handles setting the Label value. In the Player script we use this code whenever the player’s health is changed:\nemit_signal(\"health_changed\", health) In the UI script we have:\nonready var label = $VBoxContainer/HBoxContainer/Label func update_health(value): label.text = str(value) Now we just need to connect the signal to the function. The perfect place to do that is in World, which is the common parent, and knows where both nodes are:\nfunc _ready(): $Player.connect(\"health_changed\", $UI, \"update_health\") 3. Using groups Groups are another way to decouple, especially when you have a lot of similar objects that need to do the same thing. A node can be added to any number of groups and membership can be changed dynamically at any time with add_to_group() and remove_from_group().\nA common misconception about groups is that they are some kind of object or array that “contains” node references. Groups are a tagging system. A node is “in” a group if it has that tag assigned from it. The SceneTree keeps track of the tags and has functions like get_nodes_in_group() to help you find all nodes with a particular tag.\nGroup example Let’s consider a Galaga-style space shooter where you have a lots of enemies flying around. These enemies may have different types and behaviors. You’d like to add a “smart bomb” upgrade that, when activated, destroys all enemies on the screen. Using groups, you can implement this with a minimal amount of code.\nFirst, add all enemies to an “enemies” group. You can do this in the editor using the “Node” tab:\nYou can also add nodes to the group in your script:\nfunc _ready(): add_to_group(\"enemies\") Let’s assume every enemy has an explode() function that handles what happens when it dies (playing an animation, spawning dropped items, etc). Now that every enemy is in the group, we can implement our smart bomb function like this:\nfunc activate_smart_bomb(): get_tree().call_group(\"enemies\", \"explode\") 4. Using owner owner is a Node property that’s set automatically when you save a scene. Every node in that scene will have its owner set to the scene’s root node. This makes for a convenient way to connect child signals up to the main node.\nowner example In a complex UI, you often find yourself with a very deep, nested hierarchy of containers and controls. Nodes that the user interacts with, such as Button, emit signals, and you may want to connect those signals to the script on the UI’s root node.\nHere’s an example setup:\nThe script on the root CenterContainer has the following function, which we want to call whenever any button is pressed:\nextends CenterContainer func _on_button_pressed(button_name): print(button_name, \" was pressed\") The buttons here are instances of a Button scene, representing an object which may contain dynamic code that sets the button’s text or other properties. Or perhaps you have buttons that are dynamically added/removed from the container depending on the game state. Regardless, all we need to connect the button’s signal is the following:\nextends Button func _ready(): connect(\"pressed\", owner, \"_on_button_pressed\", [name]) No matter where you place the buttons in the tree - if you add more containers, for example - the CenterContainer remains the owner.\nRelated recipes Understanding tree order Understanding node paths ","description":"","tags":null,"title":"Node communication (the right way)","uri":"/godot_recipes/3.x/basics/node_communication/"},{"content":"Problem You want a character to follow a pre-defined path, such as a guard patrolling or a car following the road.\nSolution There are many ways to approach this problem. In this solution, we’ll use Godot’s Path2D node (or Path for 3D) as a convenient way to draw paths in the editor.\nYou can add the Path2D as a child of your main scene, your map, or another location that makes sense. Don’t make it a child of the patrolling entity, though - or the path will move along with the player!\nDrawing the path After adding the Path2D node, you’ll see some new buttons appear above the viewport:\nSelect the “Add points” button and click to start adding. If you want a closed curve, the “Close curve” button will connect the last point to the first one.\nUse the “Control points” mode to adjust the “curviness” of the line.\nMoving along the path You can use PathFollow2D to automatically move along a path. However, if you’re using a kinematic body, this will cause problems with collisions, because you’re not using the body’s movement methods. For this reason, we’ll instead use the path’s points as “targets” for the body to move towards.\nextends KinematicBody2D var move_speed = 100 export (NodePath) var patrol_path var patrol_points var patrol_index = 0 var velocity = Vector2.ZERO func _ready(): if patrol_path: patrol_points = get_node(patrol_path).curve.get_baked_points() Exporting the patrol_path lets us assign the path node directly in the Inspector. Then, if it’s assigned, we can get the points that make up the line in _ready().\nNext, we can use the currently selected point in the path as our target for movement. If we get close enough to it, we advance to the next point in the curve, using wrapi() to loop around to the first point when we reach the end.\nfunc _physics_process(): if !patrol_path: return var target = patrol_points[patrol_index] if position.distance_to(target) \u003c 1: patrol_index = wrapi(patrol_index + 1, 0, patrol_points.size()) target = patrol_points[patrol_index] velocity = (target - position).normalized() * move_speed velocity = move_and_slide(velocity) Related recipes ","description":"","tags":null,"title":"Path following","uri":"/godot_recipes/3.x/ai/path_follow/"},{"content":"In the previous part, we created the Jumper and Circle object that make up the bulk of the game. Now we need to add the progression: a continuous series of spawned circles as long as the player doesn’t miss.\nExpanding the Main scene Let’s add some more nodes to Main:\nPosition2D (“StartPosition”)\nThis will mark the starting position for the game. Place it near the bottom-center of the screen.\nCamera2D\nThe camera will follow the player as it moves.\nLet’s also configure the camera. Set its Offset to (0, -200) - this will ensure we can see more of the world ahead of us. Also set Current to “On”.\nScripting the Main scene Remove the jumper and circle instances we manually created. We’ll add them in code moving forward.\nAdd the following to Jumper.gd:\nsignal captured We’ll emit this signal when the jumper hits a circle:\nfunc _on_Jumper_area_entered(area): target = area velocity = Vector2.ZERO emit_signal(\"captured\", area) And let’s change the init() function on the circle to also accept a position:\nfunc init(_position, _radius=radius): position = _position Now let’s add a script to the Main scene:\nextends Node var Circle = preload(\"res://objects/Circle.tscn\") var Jumper = preload(\"res://objects/Jumper.tscn\") var player We need references to both objects so that we can instance them when needed.\nfunc _ready(): randomize() new_game() This is temporary - later we’ll have a UI with a start button to call the new game function.\nfunc new_game(): $Camera2D.position = $StartPosition.position player = Jumper.instance() player.position = $StartPosition.position add_child(player) player.connect(\"captured\", self, \"_on_Jumper_captured\") spawn_circle($StartPosition.position) The new_game() function initializes the game - spawning a player and a circle at the start position, and setting the camera.\nfunc spawn_circle(_position=null): var c = Circle.instance() if !_position: var x = rand_range(-150, 150) var y = rand_range(-500, -400) c.position = player.target.position + Vector2(x, y) add_child(c) c.init(_position) Here’s our spawn_circle() function. If it’s passed a position, it’ll use it, otherwise we pick a random one some distance away from the current target. These are temporary numbers - once we’ve got more of the gameplay up and running, we’ll see how much they need to be adjusted.\nfunc _on_Jumper_captured(object): $Camera2D.position = object.position call_deferred(\"spawn_circle\") Finally, we need the function that processes the jumper’s captured signal. We’re going to move the camera to the new circle and spawn another. Note that because this function is called during physics processing, we’ll get an error if we try and add to the scene tree. Using call_deferred() tells the engine to execute that function as soon as it’s safe to do so.\nTry it out. You should be able to jump from circle to circle - how many did you get?\nOne jarring thing is that the camera “teleports” when it moves to the next circle. We can improve this by enabling Smoothing on the camera. The Smoothing/Speed controls how quickly the camera interpolates to the new position. Try something between 5 and 10.\nAdjustments It’s also jarring that when we hit a circle we don’t start rotating at the place we hit. Add this to the jumper’s _on_Jumper_area_entered() function:\ntarget.get_node(\"Pivot\").rotation = (position - target.position).angle() Let’s also add this to the circle’s init():\nrotation_speed *= pow(-1, randi() % 2) This randomly flips the rotation speed to positive or negative, so we won’t always orbit in the same direction.\nTrail Add these nodes to the jumper:\nNode (“Trail”) Line2D (“Points”) We’re going to use this to make a trail that streams out behind the player. Later we’ll make it more visually appealing, but for now, let’s stick with a simple gradient. In the Fill add a new Gradient, and go from transparent to a color of your choosing:\nNow in the jumper’s script, let’s add the following:\nonready var trail = $Trail/Points var trail_length = 25 And then in the _physics_process():\nif trail.points.size() \u003e trail_length: trail.remove_point(0) trail.add_point(position) IMAGE/GIF\nCircle animations Finally, we’ll add some visuals to the circles. First, we’ll add an effect when the player jumps off and the circle disappears. Then, we’ll add a capture effect for when we hit a circle.\nAdd an AnimationPlayer node to the Circle.\n“Implode” animation Add a new animation called “implode”. Set the length to 0.4 and keyframe two properties of the root Area2D node: Scale at (1, 1) and Modulate at its default ((1, 1, 1, 1)). Then move the scrubber all the way to the end and key the values (0.1, 0.1) and (1, 1, 1, 0) (that’s the “alpha” value of the color).\nCapture animation The capture animation is a little more complex. Duplicate the Sprite and call it SpriteEffect. Set its Visible property off. We’re going to animate this second ring zooming in on the main circle.\nHere are the functions to add to the circle script:\nfunc capture(): $AnimationPlayer.play(\"capture\") func implode(): if !$AnimationPlayer.is_playing(): $AnimationPlayer.play(\"implode\") yield($AnimationPlayer, \"animation_finished\") queue_free() And then in Jumper.gd, our jump function becomes:\nfunc jump(): target.implode() target = null velocity = transform.x * jump_speed And in Main, our capture method calls the capture:\nfunc _on_Jumper_captured(object): $Camera2D.position = object.position object.capture() call_deferred(\"spawn_circle\") GIF\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video? ","description":"","tags":null,"title":"Spawning Circles","uri":"/godot_recipes/3.x/games/circle_jump/circle_jump_02/"},{"content":"Problem It’s probably the most common problem seen in the Godot help channels: an invalid node reference. Most often, it appears as the following error message:\nInvalid get index ‘position’ (on base: ’null instance’).\nSolution It’s that last part, the “null instance”, that’s the source of this problem, and the main source of confusion for Godot beginners.\nThe way to avoid this problem is to understand the concept of node paths.\nUnderstanding node paths The scene tree is made of nodes, which are connected together in parent-child relationships. A node path is the path it takes to get from one node to another by moving through this tree.\nAs an example, let’s take a simple “Player” scene:\nThe script for this scene is on the Player node. If the script needs to call play() on the AnimatedSprite node, it needs a reference to that node:\nget_node(\"AnimatedSprite\").play() The argument of the get_node() function is a string representing the path to the desired node. In this case, it’s a child of the node the script is on. If the path you give it is invalid, you’ll get the dreaded null instance error (as well as “Node not found”).\nGetting a node reference with get_node() is such a common situation that GDScript has a shortcut for it:\n$AnimatedSprite.play() Info get_node() returns a reference to the desired node.\nLet’s look at a more complex scene tree:\nIf the script on Main needs to access ScoreLabel it can do so with this path:\nget_node(\"HUD/ScoreLabel\").text = \"0\" # or using the shortcut: $HUD/ScoreLabel.text = \"0\" Tip When using $ notation, the Godot editor will autocomplete paths for you. You can also right-click on a node in the Scene tab and choose “Copy Node Path”.\nWhat if the node you want to access is higher in the tree? You can use get_parent() or \"..\" to reference the parent node. In the above example tree, to get the Player node from the ScoreLabel:\nget_node(\"../../Player\") Let’s break that down. The path \"../../Player\" means “get the node that’s up one level (HUD), then one more level (Main), then its child Player”.\nTip Does this seem familiar? Node paths work exactly like directory paths in your operating system. The / character indicates the parent-child relationship, and .. means “up one level”.\nRelative vs absolute paths The above examples all use relative paths - meaning they start at the current node and follow the path to the destination. Node paths can also be absolute, starting from the root node of the scene.\nFor example, the absolute path to the player node is:\nget_node(\"/root/Main/Player\") /root, which can also be accessed with get_tree().root is not the root node of your scene. It’s the Viewport node that is always present by default in the SceneTree.\nA warning While the above examples work just fine, there are some things you should be aware of that may cause problems later. Imagine the following situation: the Player node has a health property, which you want to display in a HealthBar node somewhere in your UI. You might write something like this in the player’s script:\nfunc take_damage(amount): health -= amount get_node(\"../Main/UI/HealthBar\").text = str(health) While this may work fine at first, it is brittle, meaning it can break easily. There are two main problems with this kind of arrangement:\nYou can’t test the player scene independently. If you run the player scene by itself or in a test scene that doesn’t have a UI, the get_node() line will cause a crash. You can’t change your UI. If you decide to rearrange or redesign your UI, the path will no longer be valid and you have to change it. For this reason, you should try to avoid using node paths that go up the scene tree. In the above situation, if the player instead emitted a signal when the health changed, the UI could listen for that signal to update itself. You could then rearrange and separate nodes without fear of breaking your game.\nWrapping up Once you understand how to use node paths, you’ll see how easy it is to reference any node you need. And put a stop to seeing those null instance error messages.\n","description":"","tags":null,"title":"Understanding node paths","uri":"/godot_recipes/3.x/basics/getting_nodes/"},{"content":"Nodes are the basic building blocks for creating games in Godot. A node is an object that can represent some kind of specialized game function. A given type of node might display graphics, play an animation, or represent a 3D model of an object. The node also contains a collection of properties, allowing you to customize its behavior. Which nodes you add to your project will depend on what functionality you need. It’s a modular system designed to give you flexibility in building your game objects.\nWorking with Nodes Nodes are objects, in the programming sense. They encapsulate data and behavior, and they can inherit properties from other nodes. Rather than use one of the default suggestions, let’s click the “Add/Create a New Node” button in the scene dock.\nHere you’ll see the whole hierarchy of node types available in the engine. For example, the nodes with the bluish-purple icons all fall under the “Node2D” category, meaning they will all have the properties of a Node2D. More about that in a moment.\nThe list is long, and it would be frustrating to have to drill down every time to find the node you need. Instead, you can use the search function to find it using a small number of characters. We’re looking for the “Sprite” node, so I’ll just type “sp” and we’ll jump right to it. Click “Create” to add the node.\nNow we have this Sprite node in our “Scene” dock. Make sure it’s selected, and then look at the Inspector dock on the right side. Over here, you’ll see all the properties of whatever node you have selected. Notice that the properties are organized by where they come from. The Sprite node inherits from Node2D, which inherits from CanvasItem, which inherits from the plain old Node.\nOver in the viewport, the sprite doesn’t look like much. A sprite’s purpose is to display an image, or texture. As you can see in the Inspector, the texture property is currently empty. Fortunately, every new Godot project comes with an image we can use: the Godot icon. Drag the icon from the Filesystem dock and drop it in the texture property.\nIn the Inspector, click to expand the “Transform” section, and type (50, 50) in the Position property.\nYou can also click and drag the sprite around in the viewport, and you’ll see the Position values changing as you move.\nOne important property of nodes is that they can be arranged in a parent-child hierarchy. Make sure you have the Sprite selected and press the add button again. Add another Sprite and also drag the icon into its texture.\nThis new sprite is a child of the first. This means that it’s “attached” to its parent. If the parent sprite moves, so will the child. Click on the child sprite and set its Position to (50, 50). Now click and drag the parent sprite to move it around the screen.\nNotice that the Position of the parent is changing as you move it around. Now check the child: it’s still (50, 50). That’s because its “Transform” properties are relative to its parent.\nScenes Grouping nodes together like this is a powerful tool, enabling you to construct complex objects out of node “building blocks”. For example, a “Player” node in your game might have many child nodes attached to it: a Sprite for display, an AnimationPlayer to animate it, a Camera to follow it around, and so on.\nA group of nodes arranged in a “tree” structure like this is called a Scene. In the next part, we’ll look at how you can use scenes to organize your game’s objects into independent parts that all work together. You’ll see this in practice was you work through the examples in later lessons.\n","description":"","tags":null,"title":"Nodes: Godot's building blocks","uri":"/godot_recipes/3.x/g101/start/101_03/"},{"content":" 2D Tips, tricks, and tutorials on the 2D side of game development.\nIn this section: 8-Directional Movement/Animation Entering/Exiting the screen Platform character Screen wrap Splitscreen multiplayer TileMap: detecting tiles Top-down movement Grid-based movement Car steering TileMap: using autotile KinematicBody2D: align with surface Moving Platforms Shooting projectiles TileMap: animated tiles Screen Shake Multitarget Camera Ballistic bullet Line2D Collision Touchscreen Camera Draw trajectory ","description":"","tags":null,"title":"2D","uri":"/godot_recipes/3.x/2d/"},{"content":"Before reading this, make sure you have an understanding of vectors and how they’re used in game development. If you don’t, I recommend you read this introduction I wrote for the Godot documentation: Vector Math.\n2D Transforms In 2D space, we use the familiar X-Y coordinate plane. Remember that in Godot, as in most computer graphics applications, the Y axis points downward:\nTo begin, let’s consider this spaceship floating in space:\nThe ship is pointing in the same direction as the X axis. If we wanted it to move forward, we could add to its X coordinate and it would move to the right: position += Vector2(10, 0).\nBut what happens when the ship rotates?\nHow do we move the ship forward now? If you remember Trigonometry from school, you might be starting to think about angles, sin and cos and doing something like position += Vector2(10 * cos(angle), 10 * sin(angle)). While this would work, there’s a much more convenient way: the Transform.\nLet’s look at the rotated ship again, but this time, let’s also imagine that the ship has its own X and Y axes that it carries with it, independent of the global axes:\nThese “local” axes are a part of the transform called the basis.\nKnowing this, we can move the ship forward by moving it along its own X axis and we won’t have to worry about angles and trig functions. To do this in Godot, we can use the transform property, which is available to all Node2D derived nodes.\nposition += transform.x * 10 This code says “Add the transform’s x vector multiplied by 10.” Let’s break down what that means. The transform contains x and y properties that represent those local axes. They are unit vectors, which means their length is 1. Another term for unit vector is direction vector. They tell us the direction the ship’s x axis is pointing. We then multiply by 10 to scale it to a longer distance.\nTip The transform property of a node is relative to its parent node. If you need to get the global value, it’s available in global_transform.\nIn addition to the basis, the transform also contains a component called the origin. The basis represents the body’s rotation, while the origin represents the translation, or change in position.\nIn this picture, the blue vector is the transform.origin. It is equal to the object’s position vector.\nConverting Between Local and Global Space You can convert coordinates from local to global by applying the transform. To apply a transform, use xform():\nvar global_position = transform.xform(local_position) For convenience, Node2D and Spatial include helper functions for this. Instead of using transform.xform(), you can call to_global():\nvar global_position = to_global(local_position) To convert from global to local coordinates, you can use the opposite (inverse) of the transform with xform_inv().\nLet’s use the example of an object in the 2D plane and convert mouse clicks (global space) into coordinates relative to the object:\nextends Sprite func _unhandled_input(event): if event is InputEventMouseButton and event.pressed: if event.button_index == BUTTON_LEFT: printt(event.position, transform.xform_inv(event.position)) As with the previous operation, there are helper functions for this. Instead of using transform.xform_inv(), you can call to_local():\nprintt(event.position, to_local(event.position)) See the Transform2D docs for a list of the available properties and methods.\n3D Transforms In 3D space, the concept of transforms applies in the same way as in 2D. In fact, it becomes even more necessary, as using angles in 3D can lead to a variety of problems, as we’ll see in a bit.\n3D nodes inherit from the base node Spatial, which contains the transform information. The 3D transform requires more information than the 2D version. Position is still held in the origin property, but rotation is in a property called basis, which contains three unit vectors representing the body’s local X, Y, and Z axes.\nNote In the editor, you can see and manipulate the body’s local orientation by clicking the “Local Space Mode” button. As in 2D, we can use the local axes to move an object forward. In Godot’s 3D orientation (Y-up), this means that by default the body’s -Z axis is the forward direction:\ntranslation += -transform.basis.z Tip Godot has default vector values defined, for example: Vector3.FORWARD == Vector3(0, 0, -1). See Vector2 and Vector3 for details.\n","description":"","tags":null,"title":"Transforms","uri":"/godot_recipes/3.x/math/transforms/"},{"content":"In the last part, we covered how to import 3D objects and how to arrange them in a scene. In this installment, we’ll add more objects to the scene, including a user-controlled character.\nBuilding the Scene We’re going to continue using the Kenney Platformer Kit we downloaded last time. Select all the “block*.glb” files and in the “Import” tab set their “Root Type” to StaticBody and click “Reimport”. Select “blockLarge.glb” and make a new inherited scene. Add a “Convex Collision Sibling” to the mesh using the menu as you did in the last tutorial. Rename the root node to “BlockLarge” and save the scene - I recommend making a separate folder for this, as soon you’re going to have a bunch of scenes representing the differently shaped platform parts.\nYou can download a starter project with all the block objects already configured and ready to use here: LINK\nOpen the scene from the last tutorial with the “Ground” plane and the crates. Delete the crates and add an instance of the large block. We want to be able to place these blocks so that they line up. To do this, select “Configure Snap” from the “Transform” menu at the top of the Viewport and set Translate Snap to 0.5. Then click on the “Snap Mode” button (or press the Y key). Now duplicate the block a few times and drag them to arrange.\nIf you like, go ahead and add scenes for some of the other platform blocks and arrange them into a pleasing level. Be creative!\nAdding a Character Now we’re going to make a character so we can walk around on the platforms. Open a new scene and start with a KinematicBody named “Character”. This PhysicsBody node behaves very much like its 2D equivalent (you’ve already done the 2D tutorials, right?). It has a move_and_slide() method that we’ll use to perform the movement and collision detection. Gravity will be added manually each frame, accelerating in the -Y direction.\nAdd a sphere-shaped MeshInstance and a matching CollisionShape. Remember, you can add a SpatialMaterial to the mesh and set its Albedo property to change the color.\nThe sphere is nice, but it’s going to be hard to tell what direction it’s facing. Let’s add another MeshInstance, this time with a PrismMesh shape. Set its Size to (0.5, 0.5, 0.1) and then its x rotation to -90 degrees. Arrange it so it’s pointing along the negative z axis. (You can tell which way is negative because the gizmo arrows point in the positive direction).\nLet’s also add a Camera to the scene, so it will follow the player around. Position the camera behind and above the character, angling it down a bit. Click the “Preview” button to check the camera’s view.\nBefore we add a script, open the “Project Settings” and add the following inputs on the “Input Map” tab:\nInput Action Key move_forward W move_back S strafe_right D strafe_left A jump Space Now let’s add a script to the body.\nextends KinematicBody var gravity = Vector3.DOWN * 12 # strength of gravity var speed = 4 # movement speed var jump_speed = 6 # jump strength var spin = 0.1 # rotation speed var velocity = Vector3.ZERO var jump = false func get_input(): velocity.x = 0 velocity.z = 0 if Input.is_action_pressed(\"move_forward\"): velocity.z -= speed if Input.is_action_pressed(\"move_back\"): velocity.z += speed if Input.is_action_pressed(\"strafe_right\"): velocity.x += speed if Input.is_action_pressed(\"strafe_left\"): velocity.x -= speed func _physics_process(delta): velocity += gravity * delta get_input() velocity = move_and_slide(velocity, Vector3.UP) The code in _physics_process() is pretty straightforward: add gravity to accelerate in the positive Y direction (downward), call get_input() to check for input, and then use move_and_slide() to move in the direction of the velocity vector.\nIn get_input() we check to see which key is pressed and then move in that direction. Run the program and test:\nThis is all good, but we need to be able to rotate. Let’s add a camera to the body and we’ll use the mouse to rotate. Place the camera above and behind the character so you have a good view, then add the following code to the character’s script:\nfunc _unhandled_input(event): if event is InputEventMouseMotion: if event.relative.x \u003e 0: rotate_y(-lerp(0, spin, event.relative.x/10)) elif event.relative.x \u003c 0: rotate_y(-lerp(0, spin, event.relative.x/10) This will convert any mouse motion in the x direction into a rotation around the y axis. We use lerp() to smooth it out based on how fast you move the mouse.\nRun the scene and confirm that moving the mouse rotates the character:\nHowever, there’s a problem. No matter which way we’re facing, pressing W moves us along the Z axis. Our movement is using global coordinates, but we need to move in the object’s forward direction.\nThe Power of Transforms This is where transforms come in. A transform is a mathematical matrix that contains the object’s translation, rotation, and scale information all in one. In Godot it’s stored in the Transform data type. The position information is called the transform.origin and the orientation information is in the transform.basis.\nRemember how the 3D gizmo can be set to “Local Space Mode”? When in this mode, the gizmo’s X/Y/Z axes point along the object’s axes. This is the basis of the transform. The basis contains three Vector3 objects callsd x, y, and z that represent these directions. We can use this to ensure that pressing the W key will always move us in the object’s forward direction.\nChange the get_input() function like so:\nfunc get_input(): var vy = velocity.y velocity = Vector3() if Input.is_action_pressed(\"move_forward\"): velocity += -transform.basis.z * speed if Input.is_action_pressed(\"move_back\"): velocity += transform.basis.z * speed if Input.is_action_pressed(\"strafe_right\"): velocity += transform.basis.x * speed if Input.is_action_pressed(\"strafe_left\"): velocity += -transform.basis.x * speed velocity.y = vy Now forward and back will always move along the object’s Z axis, and the strafe keys along its X.\nJumping Let’s add one more movement to the player: jumping.\nAdd these lines to the end of get_input(): jump = false if Input.is_action_just_pressed(\"jump\"): jump = true\nAnd add these to the end of _physics_process(): if jump and is_on_floor(): velocity.y = jump_speed\nWrapping Up In this tutorial you learned how to build a more complex scene, and how to write movement code for a user-controlled character. You also learned about transforms, which are a very important concept in 3D - you’re going to be using a lot in the future.\nIn the next part, we’ll add some more objects to our 3D world.\nYou can also find a video version of this lesson here:\n","description":"","tags":null,"title":"Creating a 3D Character","uri":"/godot_recipes/3.x/g101/3d/101_3d_03/"},{"content":"Problem You want a “chase camera” that can follow your car (or any other object).\nSolution Note Godot has a built-in InterpolatedCamera node that does most of what’s described here. However, we’re not going to use it for two reasons: first, it has a tendency to stutter when following kinematic bodies, and second, it’s getting removed in Godot 4.0. Setting up our own is really easy though, so don’t worry. Setting up the camera Add a new scene with a Camera. Name it ChaseCamera, save it, and add a script.\nThe ChaseCamera will have a target - the thing it’s following. We’re also going to include the ability to change that target.\nextends Camera export var lerp_speed = 10.0 var target = null func _physics_process(delta): if !target: return global_transform = global_transform.interpolate_with(target.global_transform, lerp_speed * delta) func _on_change_camera(t): target = t The only parameter to set here is the lerp_speed, which controls how quickly the camera updates its position. Set it low, and the camera will “lag” behind the car. Set it high, and it will remain locked on.\nSetting up the target(s) We want to be able to have a few different chase camera positions. One close and one far, for example, or perhaps one looking straight down. Add a Spatial to the car and name it CameraPositions. Add a few Position3Ds to this - as many as you would like.\nMove and orient each Position3D in a different location of your choosing. The position’s -Z axis should point at the car.\nTip You may find it helpful to temporarily attach a Camera to the position and use its “Preview” mode to help aim the Position3D so that it’s pointing directly where you want (you can remove the camera once you’re done). To communicate to the camera, we’ll emit a signal whenever we want it to change position. Add the following code to the car’s script:\nextends \"res://cars/car_base.gd\" signal change_camera var current_camera = 0 onready var num_cameras = $CameraPositions.get_child_count() func _ready(): emit_signal(\"change_camera\", $CameraPositions.get_child(current_camera)) func _input(event): if event.is_action_pressed(\"change_camera\"): current_camera = wrapi(current_camera + 1, 0, num_cameras) emit_signal(\"change_camera\", $CameraPositions.get_child(current_camera)) Add an action in the InputMap for changing the camera. Here, we’re using Tab and the right shoulder button:\nConnecting it together Add a ChaseCamera instance to your main scene and set it Current. Then connect the car’s change_camera signal to the camera’s _on_change_camera() function.\nRun the game and press the camera change button to try it out:\nRelated recipes Kinematic Car: Base 2D: Car Steering recipe Input Actions 3D: KinematicBody Movement Like video? ","description":"","tags":null,"title":"3D Kinematic Car: Chase Camera","uri":"/godot_recipes/3.x/3d/kinematic_car/car_camera/"},{"content":"Problem You need to add actions to the InputMap at runtime.\nSolution Typically, you’ll add actions to the InputMap via Project Settings, as shown in Recipe: Input Actions. However, you may find yourself needing to add one or more actions directly in a script. The InputMap singleton has methods to help you do this.\nHere’s an example that would add a new action called “attack” using the space key:\nfunc _ready(): InputMap.add_action(\"attack\") var ev = InputEventKey.new() ev.scancode = KEY_SPACE InputMap.action_add_event(\"attack\", ev) If you also wanted to add the left mouse button to the same action:\nev = InputEventMouseButton.new() ev.button_index = BUTTON_LEFT InputMap.action_add_event(\"attack\", ev) Note InputMap.add_action() will produce an error if the action already exists. You should check first with InputMap.has_action() before attempting to add a new action.\nPractical Example Let’s say you’ve made the platform character from Recipe: Platform character and you want to re-use it in another project. If you saved the scene, script, and assets in a single folder, you need only copy that folder to your new project. But you’d still need to edit the Input Map in order for the inputs to work.\nInstead, you could add the following code to the player script and be sure that the necessary input actions will be added automatically:\nvar controls = {\"walk_right\": [KEY_RIGHT, KEY_D], \"walk_left\": [KEY_LEFT, KEY_A], \"jump\": [KEY_UP, KEY_W, KEY_SPACE]} func _ready(): add_inputs() func add_inputs(): var ev for action in controls: if not InputMap.has_action(action): InputMap.add_action(action) for key in controls[action]: ev = InputEventKey.new() ev.scancode = key InputMap.action_add_event(action, ev) Related recipes Input Actions Platform Character ","description":"","tags":null,"title":"Adding Input Actions in code","uri":"/godot_recipes/3.x/input/custom_actions/"},{"content":"Problem You want to hide the mouse cursor and keep the mouse from leaving the game window. This is common in many 3D games (and some 2D ones).\nSolution You can set the mouse state using Input.set_mouse_mode(). There are four possible mouse modes:\nMOUSE_MODE_VISIBLE: The mouse is visible and can move freely into and out of the window. This is the default state.\nMOUSE_MODE_HIDDEN: The mouse cursor is invisible, but the mouse can still move outside the window.\nMOUSE_MODE_CAPTURED: The mouse cursor is hidden and the mouse is unable to leave the game window.\nMOUSE_MODE_CONFINED: The mouse is visible, but cannot leave the game window.\n“Captured” is the most commonly used option. You can set the mouse mode at runtime using:\nfunc _ready(): Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) When the mouse is captured, mouse input events will still be passed as normal. However, you will find there is a problem. If you want to close the game or switch to another window, you can’t. For this reason, you will want to also include a way to “release” the mouse. For example, to release when the player pressed the Escape key:\nfunc _input(event): if event.is_action_pressed(\"ui_cancel\"): Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE) So that the game doesn’t respond to mouse movement when you’re in another window, you can test for the capture state in your character controller using:\nif Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED: Once the mouse is released, that leaves the need to re-capture it to continue playing. Assuming you have an event in the Input Map for a mouse click, you can do the following:\nif event.is_action_pressed(\"click\"): if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE: Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) Since you may also be using a mouse click to shoot or perform some other action, it’s probably a good idea to stop the event from propagating. Add this after setting the mouse mode:\nget_tree().set_input_as_handled() ","description":"","tags":null,"title":"Capturing the Mouse","uri":"/godot_recipes/3.x/input/mouse_capture/"},{"content":"Problem You need to create a 2D top-down car controller.\nSolution When approaching this problem, beginners often wind up creating something that handles nothing like a real car. Some common mistakes you’ll find in amateur car games:\nA car doesn’t rotate around its center. Put another way, a car’s rear wheels don’t slide side-to-side. (Unless it’s drifting, but we’ll talk about that later.) A car can only turn when it’s moving - it can’t spin in place. A car isn’t a train; it’s not on rails. Turning at high speeds should involve some sliding (drifting). There are many approaches to 2D car physics, mainly depending on how “realistic” you want to be. For this solution, we’re going for an “arcade” level of realism, meaning we’ll prioritize action over realism.\nNote The method below is based on the algorithm found here: http://engineeringdotnet.blogspot.com/2010/04/simple-2d-car-physics-in-games.html\nThe recipe below is broken into 5 parts, each adding a different feature to the car’s movement. Feel free to mix-and-match for your needs.\nScene setup Here’s the car scene setup:\nKinematicBody2D Sprite CollisionShape2D Camera2D Add whatever sprite texture you like. For this demo, we’ll use art from Kenney’s Racing Pack. CapsuleShape2D is a good choice for the collision, so that the car won’t have sharp corners to get caught on obstacles.\nWe’ll also use four input actions: “steer_right”, “steer_left”, “accelerate”, and “brake”.\nPart 1: Movement The first step is to code the movement based on the algorithm described above.\nStart with a few variables:\nextends KinematicBody2D var wheel_base = 70 # Distance from front to rear wheel var steering_angle = 15 # Amount that front wheel turns, in degrees var velocity = Vector2.ZERO var steer_angle Set wheelbase to a value that works with your sprite.\nNote Since we’re using keyboard controls, turning is all-or-nothing. If you’re using an analog joystick, you can instead vary this value based on the distance the stick moves.\nfunc _physics_process(delta): get_input() calculate_steering(delta) velocity = move_and_slide(velocity) Each frame, we need to check for input and calculate steering. Then we pass the resulting velocity to move_and_slide(). We’ll define those two function next:\nfunc get_input(): var turn = 0 if Input.is_action_pressed(\"steer_right\"): turn += 1 if Input.is_action_pressed(\"steer_left\"): turn -= 1 steer_angle = turn * deg2rad(steering_angle) velocity = Vector2.ZERO if Input.is_action_pressed(\"accelerate\"): velocity = transform.x * 500 Here we check for user input and set the velocity. Note: the speed of 500 is temporary so that we can test movement. We’ll address it in the next part.\nfunc calculate_steering(delta): var rear_wheel = position - transform.x * wheel_base / 2.0 var front_wheel = position + transform.x * wheel_base / 2.0 rear_wheel += velocity * delta front_wheel += velocity.rotated(steer_angle) * delta var new_heading = (front_wheel - rear_wheel).normalized() velocity = new_heading * velocity.length() rotation = new_heading.angle() Here is where we implement the algorithm from the link:\nFind the wheel positions. Move the wheels forward. Find the new direction vector. Set the velocity and rotation to the new direction. Run the project and the car should move and turn. It’s still very unnatural though - the car starts and stops instantly. To fix that, we’ll add acceleration into the calculation.\nPart 2: Acceleration We’ll need another setting variable and one to track the car’s overall acceleration:\nvar engine_power = 800 # Forward acceleration force. var acceleration = Vector2.ZERO Change the input code to apply acceleration instead of directly changing the car’s velocity.\nfunc get_input(): var turn = 0 if Input.is_action_pressed(\"steer_right\"): turn += 1 if Input.is_action_pressed(\"steer_left\"): turn -= 1 steer_angle = turn * steering_angle if Input.is_action_pressed(\"accelerate\"): acceleration = transform.x * engine_power Once we’ve got our acceleration, we can apply it to the velocity like so:\nfunc _physics_process(delta): acceleration = Vector2.ZERO get_input() calculate_steering(delta) velocity += acceleration * delta velocity = move_and_slide(velocity) Now when you run, the car should gradually increase its speed. Careful: we don’t have any way to slow down yet!\nPart 3: Friction/drag A car experiences two different deceleration forces: friction and drag.\nFriction is the force applied by the ground. It’s high if driving on sand, but low if driving on ice. Friction is proportional to velocity - the faster you’re going the stronger the force.\nDrag is the force resulting from wind resistance. It’s based on the car’s cross-section - a large truck or van experiences more drag than a sleek race car. Drag is proportional to the velocity squared.\nThis means that friction is more significant when moving slowly, but drag becomes dominant at high speeds. We’ll add both of these forces to our calculation. As a bonus, the values of these quantities will also give our car a maximum speed - the point where the force from the engine can’t overcome the drag force any longer.\nHere are our starting values for these quantities:\nvar friction = -0.9 var drag = -0.0015 As you can see in this graph, these values mean that at a speed of 600 the drag force overcomes the friction force.\nYou can play with the values here to see how they change: https://www.desmos.com/calculator/e4ayu3xkip\nIn _physics_process() we’ll call a function to calculate the current friction and apply it to the acceleration force.\nfunc _physics_process(delta): acceleration = Vector2.ZERO get_input() apply_friction() calculate_steering(delta) velocity += acceleration * delta velocity = move_and_slide(velocity) func apply_friction(): if velocity.length() \u003c 5: velocity = Vector2.ZERO var friction_force = velocity * friction var drag_force = velocity * velocity.length() * drag if velocity.length() \u003c 100: friction_force *= 3 acceleration += drag_force + friction_force First, we’ll set a minimum speed. This will ensure that the car doesn’t keep creeping forward at very low speeds as friction never quite reaches zero.\nThen we calculate the two forces and add them to the total acceleration.\nPart 4: Reverse/Brake We’ll need two more settings variables:\nvar braking = -450 var max_speed_reverse = 250 Add the input to get_input():\nif Input.is_action_pressed(\"brake\"): acceleration = transform.x * braking This is fine for coming to a stop, but we also want to be able to put the car in reverse. Currently, that won’t work, because the acceleration is always being applied in the “heading” direction, which is forward. When we’re reversing, we need to accelerate backward.\nfunc calculate_steering(delta): var rear_wheel = position - transform.x * wheel_base / 2.0 var front_wheel = position + transform.x * wheel_base / 2.0 rear_wheel += velocity * delta front_wheel += velocity.rotated(steer_angle) * delta var new_heading = (front_wheel - rear_wheel).normalized() var d = new_heading.dot(velocity.normalized()) if d \u003e 0: velocity = new_heading * velocity.length() if d \u003c 0: velocity = -new_heading * min(velocity.length(), max_speed_reverse) rotation = new_heading.angle() We can find whether we’re accelerating forward or backward using the dot product. If the two vectors are aligned, the result will be greater than 0. If the movement is in the opposite direction the car’s facing, then the dot product will be less than 0 and we must be moving backward.\nPart 5: Drift/slide We could stop here and you’d have a satisfactory driving experience. However, the car still feels like it’s “on rails”. Even at top speed, the turns are perfect, as if the tires have perfect “grip”.\nAt high speeds (or even low ones, if desired), the turning force should cause the tires to slip and result in a fishtailing/sliding motion.\nvar slip_speed = 400 # Speed where traction is reduced var traction_fast = 0.1 # High-speed traction var traction_slow = 0.7 # Low-speed traction We’ll apply these values when calculating the steering. Currently, the velocity is instantly set to the new heading. Instead, we’ll use linear_interpolate() to cause it to only “turn” partway towards the new direction. The “traction” values will determine how “sticky” the tires are - a value of 1.0 would represent no sliding.\nfunc calculate_steering(delta): var rear_wheel = position - transform.x * wheel_base / 2.0 var front_wheel = position + transform.x * wheel_base / 2.0 rear_wheel += velocity * delta front_wheel += velocity.rotated(steer_angle) * delta var new_heading = (front_wheel - rear_wheel).normalized() var traction = traction_slow if velocity.length() \u003e slip_speed: traction = traction_fast var d = new_heading.dot(velocity.normalized()) if d \u003e 0: velocity = velocity.linear_interpolate(new_heading * velocity.length(), traction) if d \u003c 0: velocity = -new_heading * min(velocity.length(), max_speed_reverse) rotation = new_heading.angle() Here, we select which traction value to use and apply linear_interpolate() to the velocity.\nAdjustments At this point, we have a large number of settings that control the car’s behavior. Adjusting them can drastically change how the car drives. To make experimenting with different values easier, download the project for this recipe below. When you run the game, you’ll see a set of sliders you can use to change the car’s behavior as you drive (press \u003cTab\u003e to show/hide the slider panel).\nNote Download the project file here: car_steering.zip\nRelated recipes Gamedev Math: Interpolation Like video? ","description":"","tags":null,"title":"Car steering","uri":"/godot_recipes/3.x/2d/car_steering/"},{"content":"Problem You want a shader to convert an image to greyscale.\nSolution Let’s start with a canvas_item (2D) shader. To convert to greyscale but also preserve pixel contrast, we need to average the pixel’s color value. Add the color channels together and divide by 3:\nshader_type canvas_item; void fragment() { COLOR = texture(TEXTURE, UV); float avg = (COLOR.r + COLOR.g + COLOR.b) / 3.0; COLOR.rgb = vec3(avg); } You can apply this to the whole screen by adding a ColorRect (placed in a CanvasLayer to ignore camera movement) and scaling it to cover the screen.\nChange the texture() function to sample the screen instead of the object’s pixels:\nCOLOR = texture(SCREEN_TEXTURE, SCREEN_UV); Related Recipes Shaders: Intro ","description":"","tags":null,"title":"Greyscale (monochrome) shader","uri":"/godot_recipes/3.x/shaders/greyscale/"},{"content":"Problem You want to add friction and acceleration to your kinematic character, giving it a smoother feel.\nSolution For most games, we’re not necessarily interested in a perfect physics simulation. We want action, responsiveness, and arcade feel. This is why you choose a kinematic body over a rigid one: so that you can control its behavior directly. However, some amount of physics is good - it means an object doesn’t instantly change direction or come to a stop.\nBelow is the code for a no-frills kinematic platformer character:\nextends KinematicBody2D var speed = 1200 var jump_speed = -1800 var gravity = 4000 var velocity = Vector2.ZERO func get_input(): velocity.x = 0 if Input.is_action_pressed(\"ui_right\"): velocity.x += speed if Input.is_action_pressed(\"ui_left\"): velocity.x -= speed func _physics_process(delta): get_input() velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP) if Input.is_action_just_pressed(\"ui_select\"): if is_on_floor(): velocity.y = jump_speed If you run this code, you’ll see that the character’s x velocity changes instantaneously. To fix this, we’ll use lerp() to gradually increase/decrease the velocity.\nUsing lerp lerp(start_value, end_value, amount) lerp(), aka linear interpolate, finds a “blended” value between two given numbers. See Interpolation for details.\nIn the code below, friction represents how quickly the character comes to a stop, while acceleration determines how quickly it gets up to full speed. Both are values between 0.0 and 1.0.\nReplace the get_input() code with the following:\nvar friction = 0.1 var acceleration = 0.5 func get_input(): var input_dir = 0 if Input.is_action_pressed(\"ui_right\"): input_dir += 1 if Input.is_action_pressed(\"ui_left\"): input_dir -= 1 if dir != 0: # accelerate when there's input velocity.x = lerp(velocity.x, dir * speed, acceleration) else: # slow down when there's no input velocity.x = lerp(velocity.x, 0, friction) Explanation We’re using friction and acceleration as the amount to blend. For acceleration, we want to find a value between the current speed and the maximum, speed. When decelerating, we’re ramping the current speed down to 0.\nTip Using values of 1.0 would recreate the “instant” movement we started with.\nRelated Recipes Platform Character ","description":"","tags":null,"title":"Kinematic Friction","uri":"/godot_recipes/3.x/physics/kinematic_friction/"},{"content":"Problem Your KinematicBody slides down slopes.\nSolution We’ve started with a no-frills KinematicBody, using move_and_slide(), using the script below:\nextends KinematicBody export var gravity = -10.0 export var speed = 5.0 export var rot_speed = 4.0 export var jump_speed = 5.0 var velocity = Vector3.ZERO var jumping = false func get_input(delta): var input = Vector3.ZERO if Input.is_action_pressed(\"forward\"): input += -transform.basis.z * speed if Input.is_action_pressed(\"back\"): input += transform.basis.z * speed if Input.is_action_pressed(\"right\"): rotate_y(-rot_speed * delta) if Input.is_action_pressed(\"left\"): rotate_y(rot_speed * delta) velocity.x = input.x velocity.z = input.z func _physics_process(delta): get_input(delta) velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector3.UP) if jumping and is_on_floor(): jumping = false if Input.is_action_just_pressed(\"jump\"): if is_on_floor(): jumping = true velocity.y = jump_speed We see the problem if we stop moving on a slope:\nThis is move_and_slide() doing what it’s supposed to do.\nThe downward velocity caused by gravity is being slid along the surface.\nChecking the move_and_slide() documentation, we see there’s a parameter called stop_on_slope, which defaults to false:\nIf stop_on_slope is true, body will not slide on slopes when you include gravity in linear_velocity and the body is standing still.\nSo we can change our movement to this instead:\nvelocity = move_and_slide(velocity, Vector3.UP, true) Now we stop sliding down slopes!\nBut there is still a problem, which is easier to see if you use a low value for gravity:\nWhen we come to a stop, we have a little bit of upward momentum, which causes the small “hop”. We can solve this by switching to the move_and_slide_with_snap() method.\nIn order to ensure we can still jump, we also need to disable snapping during a jump, or we’ll remain “snapped” to the ground:\nvar snap = Vector3.DOWN if not jumping else Vector3.ZERO velocity = move_and_slide_with_snap(velocity, snap, Vector3.UP, true) Now the “hop” is gone, and everything works as expected.\nFinally, you may notice that on very steep slopes, you still have a problem:\nThis is because the default value of the floor_max_angle parameter is 45°, and the slope shown is greater. Any angle above this value does not count as a floor. Increasing the value makes this slope behave like the others:\nvelocity = move_and_slide_with_snap(velocity, snap, Vector3.UP, true, 4, deg2rad(52)) Related recipes Godot 101: Intro do 3D KinematicBody: Movement Like video? ","description":"","tags":[],"title":"KinematicBody: Stopping on Slopes","uri":"/godot_recipes/3.x/physics/kinematicbody_slopes/"},{"content":"In the first two parts, we got the basic gameplay working. Now we’re going to start adding some different modes to the circles.\nCircle modes Eventually, we’ll have many different modes, but we’re going to start with the “limited” mode: the circle only allows a given number of orbits before disappearing. First, let’s add a Label node to show the number of remaining orbits. Type a number (1) in the text field so we can see how it looks.\nIn the Custom Fonts section, add a new DynamicFont, load the Font Data from the assets folder, and set the Size to 64. To align the label, in the “Layout” menu, choose “Center”.\nAdd the following new variables at the top of the Circle.gd:\nenum MODES {STATIC, LIMITED} var mode = MODES.STATIC var num_orbits = 3 # Number of orbits until the circle disappears var current_orbits = 0 # Number of orbits the jumper has completed var orbit_start = null # Where the orbits started Next we need a way to set the mode:\nfunc set_mode(_mode): mode = _mode match mode: MODES.STATIC: $Label.hide() MODES.LIMITED: current_orbits = num_orbits $Label.text = str(orbits_left) $Label.show() Right now we have these two modes defined, but later we’ll be adding more.\nLet’s also add to the init() method a way to pass a mode. The default should be STATIC, but we’re going to use LIMITED now so we can test:\nfunc init(_position, _radius=radius, _mode=MODES.LIMITED): set_mode(_mode) The jumper is setting the rotation position when it’s captured. Remove the line from Jumper.gd and put it in the circle’s capture() method:\nfunc capture(target): jumper = target $AnimationPlayer.play(\"capture\") $Pivot.rotation = (jumper.position - position).angle() orbit_start = $Pivot.rotation Note that we’re now sending a reference to the jumper, so add var jumper = null at the top, and in the Main.gd script update the call to read object.capture(player).\nNow we can check to see if the jumper has gone full circle, and if so, decrement current_orbits:\nfunc _process(delta): $Pivot.rotation += rotation_speed * delta if mode == MODES.LIMITED and jumper: check_orbits() func check_orbits(): # Check if the jumper completed a full circle if abs($Pivot.rotation - orbit_start) \u003e 2 * PI: current_orbits -= 1 $Label.text = str(current_orbits) if orbits_left \u003c= 0: jumper.die() jumper = null implode() orbit_start = $Pivot.rotation In order for this to work, we need to add a die() method to the jumper:\nfunc die(): target = null queue_free() func _on_VisibilityNotifier2D_screen_exited(): if !target: die() We’ve also connected the jumper’s VisibilityNotifier2D signal so that we can remove the player when it exits the screen.\nIf we try it out, everything looks good so far:\nCircle effect The last thing we’ll do for this part is add a “fill” effect to the circle to show that the orbits are running out. To begin, we’ll use some drawing code from the official docs:\nfunc draw_circle_arc_poly(center, radius, angle_from, angle_to, color): var nb_points = 32 var points_arc = PoolVector2Array() points_arc.push_back(center) var colors = PoolColorArray([color]) for i in range(nb_points + 1): var angle_point = angle_from + i * (angle_to - angle_from) / nb_points - PI/2 points_arc.push_back(center + Vector2(cos(angle_point), sin(angle_point)) * radius) draw_polygon(points_arc, colors) We’ll call this function in _draw():\nfunc _draw(): if jumper: var r = ((radius - 50) / num_orbits) * (1 + num_orbits - current_orbits) draw_circle_arc_poly(Vector2.ZERO, r, orbit_start + PI/2, $Pivot.rotation + PI/2, Color(1, 0, 0)) Lastly, add update() to the _physics_process so that it will be called after every call to check_orbits().\nIn the next part we’ll start adding some UI.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video? ","description":"","tags":null,"title":"Limited circles","uri":"/godot_recipes/3.x/games/circle_jump/circle_jump_03/"},{"content":"Problem You want to implement a melee attack, such as a sword or punch.\nSolution For this example, we’ll assume we have already set up a character with one or more attack animations. To illustrate, we’ll use these two attacks:\nWe can detect the sword hitting the target using an Area2D, but we only want that area to be active during the swing. In order for this activation to be in sync with the animation, we’ll use the AnimationPlayer to control it.\nAdd an Area2D and CollisionShape2D to the scene. We’ll use a rectangle shape for the hitbox and size it so that it covers the sword during the swing frame.\nMove the animation to the first frame and check the Disabled property of the area. Click the keyframe icon to add a track to the animation. Then advance the animation to the frame where the sword is extended, and add another keyframe with Disabled unchecked. Finally, advance to the end of the swing and keyframe Disabled on once more.\nNow connect this new area’s area_entered signal (or, depending on how your game is set up, body_entered). For the purposes of this demo, let’s assume that any body that can take damage has an Area2D defined and placed in a group called “hurtbox”.\nfunc _on_SwordHit_area_entered(area): if area.is_in_group(\"hurtbox\"): area.take_damage() Now you should be able to try it out and see the attack doing damage if the target is inside the sword’s hitbox.\nChanging the hitbox size When you have more than one attack animation, the size of the affected area may not be the same. In the above attack animations, the first one is an upward sweeping attack that covers more area. To handle this, we also need to add an animation track for the collision shape’s Extents property. Set this and keyframe it at the start of each animation.\nRelated recipes Top-down character Controlling animation states Like video? ","description":"","tags":null,"title":"Melee attacks","uri":"/godot_recipes/3.x/animation/melee_attacks/"},{"content":"Problem The delta or “delta time” parameter is a frequently-misunderstood concept in game development. In this tutorial, we’ll explain how it’s used, the importance of frame-rate independent movement, and practical examples of its use in Godot.\nSolution To illustrate the problem, let’s consider a Sprite node moving across the screen. If our screen is 600 pixels wide and we want the sprite to take 5 seconds to cross the screen, we can use the following calculation to find the necessary speed:\n600 pixels / 5 seconds = 120 pixels/second We’ll move the sprite every frame using the _process() function. If the game is running at 60 frames per second, we can find the per-frame movement like so:\n120 pixels/second * 1/60 second/frame = 2 pixels/frame Tip Notice the units are consistent in all the calculations above. Always pay attention to the units in your calculations - it’ll save you from making mistakes.\nHere’s the necessary code:\nextends Node2D # Desired movement in pixels/frame var movement = Vector2(2, 0) func _process(delta): $Sprite.position += movement Run this code and you’ll see the sprite takes 5 seconds to cross the screen.\nMaybe. The trouble begins if there is something else occupying the computer’s time. This is called lag and can come from a variety of sources - the cause could be your code or even other applications running on your computer. If this happens, then the length of a frame might increase. As an extreme example, imagine that the frame rate is halved - each frame took 1/30 instead of 1/60 of a second. Moving at 2 px/frame, it’s now going to take twice as long for the sprite to reach the edge.\nEven small frame rate fluctuations will result in inconsistent movement speed. If this were a bullet or other fast-moving object, we wouldn’t want it slowing down like this. We need the movement to be frame rate independent.\nFixing the frame rate problem When using the _process() function, it automatically includes a parameter called delta that’s passed in from the engine (so does _physics_process(), which is used for physics-related code). This is a floating point value representing the length of time since the previous frame. Typically, this will be approximately 1/60 or 0.0167 seconds.\nWith this information, we can stop thinking about how much to move each frame, and only consider our desired speed in pixels/second (120 from the above calculation).\nMultiplying the engine’s delta value by this number will give us how many pixels to move each frame. The number will automatically adjust if the frame time fluctuates.\n# 60 frames/second 120 pixels/second * 1/60 second/frame = 2 pixels/frame # 30 frames/second 120 pixels/second * 1/30 second/frame = 4 pixels/frame Note that if the frame rate decreases by half (meaning the frame time doubles), then our per-frame movement must also double to keep the desired speed.\nLet’s change the code to use this calculation:\nextends Node2D # Desired movement in pixels/second. var movement = Vector2(120, 0) func _process(delta): $Sprite.position += movement * delta Now when running at 30 frames per second, the travel time is consistent:\nIf the frame rate gets very low, the movement is no longer smooth, but the time remains the same.\nUsing delta with motion equations What if your movement is more complex? The concept remains the same. Keep your units in seconds, not frames, and multiply by delta each frame.\nTip Working in pixels and seconds is much easier to conceptualize too, since it relates to how we measure these quantities in the real world. “Gravity is 100 pixels/second/second, so after the ball falls for 2 seconds, it’s traveling at 200 pixels/second.” If you’re working with frames, then you have to think about acceleration in units of pixels/frame/frame. Go ahead and try - it’s not very natural.\nFor example, if you are applying a gravity, that’s an acceleration - each frame it will increase the velocity by some amount. As in the above example, the velocity then changes the node’s position.\nTry adjusting delta and target_fps in the following code to see the effect:\nextends Node2D # Acceleration in pixels/sec/sec. var gravity = Vector2(0, 120) # Acceleration in pixels/frame/frame. var gravity_frame = Vector2(0, .033) # Velocity in pixels/sec or pixels/frame. var velocity = Vector2.ZERO var use_delta = false var target_fps = 60 func _ready(): Engine.target_fps = target_fps func _process(delta): if use_delta: velocity += gravity * delta $Sprite.position += velocity * delta else: velocity += gravity_frame $Sprite.position += velocity Note that we’re multiplying by our timestep each frame to update both velocity and position. Any quantity that is updated every frame should be multiplied by delta to ensure it changes independent or frame rate.\nUsing kinematic functions In the above examples, we’ve used a Sprite to keep things simple, updating the position every frame. If you’re using a kinematic body (in 2D or 3D), you’ll instead be using one of its movement methods. Specifically in the case of move_and_slide(), there tends to be some confusion, because it automatically applies delta to the movement vector. This means you won’t multiply your velocity by delta . But you will still need to apply it on the acceleration. For example:\n# Sprite movement code: velocity += gravity * delta position += velocity * delta # Kinematic body movement code: velocity += gravity * delta velocity = move_and_slide(velocity) If you don’t use delta when applying acceleration to your velocity, then your acceleration will be subject to fluctuations in frame rate. This can have a_much more subtle effect on movement - it will be inconsistent, but much more difficult to diagnose.\nTip When using move_and_slide() you still need to apply delta to any other quantities such as gravity, friction, etc.\nRelated Recipes Using KinematicBody2D ","description":"","tags":null,"title":"Understanding 'delta'","uri":"/godot_recipes/3.x/basics/understanding_delta/"},{"content":" 3D Tips, tricks, and tutorials on the 3D side of game development.\nFor a gentle introduction to working in 3D, see: Intro to 3D\nIn this section: Camera Gimbal Interpolated Camera KinematicBody: Movement 3D Unit Healthbars Shooting projectiles Rolling Cube Align Movement with Camera Simplified Airplane Controller Arcade-style Spaceship Drawing Vectors in 3D Click to move Quick Arcade-style Car Smooth rotation KinematicBody: align with surface 3D Kinematic Car ","description":"","tags":null,"title":"3D","uri":"/godot_recipes/3.x/3d/"},{"content":"In the last part, we learned about transforms, a very important concept in 3D that records an object’s local orientation in space, and used it to move our KinematicBody character. This time, we’re going to look at another type of 3D node: the Area.\nAreas Area nodes are used for detection and influence. They can detect when objects overlap, and when an object enters or exits a region. An Area can also be used to override physics properties, such as gravity or damping, in a region.\nWe’re going to use Area to create three types of objects:\nA coin the character can pick up A bullet the character can shoot Spikes that damage the character To begin, let’s set up some collision layers so that we can more easily control what objects the areas can interact with. Open the Project Settings and find the “Layer Names/3D Physics” section. Name the first three layers “environment”, “player”, and “pickups”.\nCoin Create a new inherited scene from the CoinGold.glb object in the Kenney Platformer Kit (see Part 03). Right-click on the root node, choose “Change Type”, and pick Area. In the Inspector, set the collision mask and layer so that the coin is in “pickups” and scans “player”.\nNow we need a collision shape, so add a CollisionShape node and choose a CylinderShape for it. If you rotate it 90 degrees around z, it will fit the coin shape pretty well.\nAdd a script to the Area and connect its body_entered signal, which we’ll use to remove the coin:\nextends Area func _on_Coin_body_entered(body): queue_free() Add a few coins to your scene and see if you can pick them up:\nBullets Make a new scene with an Area root, and name it “Bullet”. Add a MeshInstance, a CollisionShape, and a Timer. I’m using a sphere shape for the mesh and collision, scaled to a radius of 0.2 so that it won’t be too big compared with the character. The Timer is to give the bullet a time limit. Set its One Shot and Autostart properties both on.\nAdd a script and connect the Timer’s timeout signal and the Area’s body_entered signal. Then add the following:\nextends Area var speed = 15 var velocity = Vector3() func start(xform): transform = xform velocity = -transform.basis.z * speed func _process(delta): transform.origin += velocity * delta func _on_Timer_timeout(): queue_free() func _on_Bullet_body_entered(body): if body is StaticBody: queue_free() Since we want the bullet to start at a certain location and travel directly ahead of the player, we’ll pass the player’s transform to start() and use it to orient the bullet and make it move forward (remember in Godot’s orientation, “forward” is along the negative z axis).\nNow we can go to the character scene and add a Position3D node, placing it at the tip of the character’s “arrow” mesh. Name this node “Muzzle”. Next, add the following code to the character’s script:\nvar Bullet = preload(\"res://Bullet.tscn\") func _unhandled_input(event): if event.is_action_pressed(\"shoot\"): var b = Bullet.instance() b.start($Muzzle.global_transform) get_parent().add_child(b) Spikes Finally, we’re going to add some danger to the environment. Make in instance of the spikes.glb object and make it an Area like we did with the coin. Add a script and connect the body_entered signal, but this time, we want the object to do something to the character:\nextends Area func _on_Spikes_body_entered(body): if body.has_method(\"take_damage\"): body.take_damage() Now we need to define how the character reacts to taking “damage”. Since we haven’t really built a health system, we’re just going to “bounce” the character as if it got hurt. We need to add the following to the character script:\nvar can_move = true func take_damage(): velocity *= -1 velocity.y = jump_speed can_move = false yield(get_tree().create_timer(1), \"timeout\") can_move = true The purpose of this code is to disable input temporarily so the player will fly backwards from the spikes. If we just tried to set the velocity, it would immediately be overridden by the velocity set by the key inputs. So add this at the beginning of get_input():\nif !can_move: return Add a spike instance to your level and try it out:\nWrapping Up In this tutorial you learned how to use Area nodes to detect and react to 3D bodies.\nIn the next part: a collection of small improvements.\nYou can also find a video version of this lesson here:\n","description":"","tags":null,"title":"Using Areas","uri":"/godot_recipes/3.x/g101/3d/101_3d_04/"},{"content":"Problem Your Kinematic Car climbs slopes, but it doesn’t look quite right:\nSolution Kinematic bodies don’t automatically rotate on collision. When the wheels aren’t both touching the ground, as in the image above, we’ll need to align the car manually.\nTo begin, we need to detect when the wheel isn’t on the ground. Add two RayCast nodes to the car and align them with the front and rear wheels like so:\nFor both, set the Cast To to (0, -0.25, 0) and don’t forget to check the “Enabled” box.\nAligning a 3D object We’re going to reuse the code from the KinematicBody: Align with Surface recipe. Add this to car_base.gd:\nfunc align_with_y(xform, new_y): xform.basis.y = new_y xform.basis.x = -xform.basis.z.cross(new_y) xform.basis = xform.basis.orthonormalized() return xform Now, in the _physics_process() function, right after calling move_and_slide_with_snap(), we’ll check to see if we need to align the car:\n# If either wheel is in the air, align to slope. if $FrontRay.is_colliding() or $RearRay.is_colliding(): # If one wheel is in air, move it down var nf = $FrontRay.get_collision_normal() if $FrontRay.is_colliding() else Vector3.UP var nr = $RearRay.get_collision_normal() if $RearRay.is_colliding() else Vector3.UP var n = ((nr + nf) / 2.0).normalized() var xform = align_with_y(global_transform, n) global_transform = global_transform.interpolate_with(xform, 0.1) How it works When neither wheel is on the ground, we don’t rotate the car at all.\nOtherwise, we’re going to use an average of the front and rear rays’ results. When the ray is colliding, the collider’s surface normal is used. This way, if the two wheels are touching different slopes (like on a curved hill, for example), the result will be to try and get both wheels on the surface, like so:\nIn this image, you can see the car isn’t aligned with either surface, but is halfway between.\nIf the ray is not hitting anything, then we’ll assume a horizontal surface. That will bring the front or rear down when the other wheel is touching.\nRelated recipes Kinematic Car: Base KinematicBody: Align with Surface Like video? ","description":"","tags":null,"title":"3D Kinematic Car: Slopes \u0026 Ramps","uri":"/godot_recipes/3.x/3d/kinematic_car/car_slopes/"},{"content":"Problem You want a shader to blur an object or the screen.\nSolution shader_type canvas_item; uniform float blur_amount : hint_range(0, 5); void fragment() { COLOR = textureLod(SCREEN_TEXTURE, SCREEN_UV, blur_amount); } For example, to gradually blur the entire screen, such as for a scene transition effect:\nYou can also animate the blurring:\nextends Node # Add a ColorRect or other Control set to fill the screen # Place it lower in the tree and/or place in CanvasLayer # so it's on top of the rest of the scene. onready var blur = $Blur var blur_amount = 0 func _process(delta): blur_amount = wrapf(blur_amount + 0.05, 0.0, 5.0) blur.material.set_shader_param(\"blur_amount\", blur_amount) Related Recipes Shaders: Intro Interacting with Shaders ","description":"","tags":null,"title":"Blur shader","uri":"/godot_recipes/3.x/shaders/blur/"},{"content":"Problem You want your AI-controlled entity to switch between different behaviors.\nSolution For this example, we’ll assume an enemy with the following behaviors. See the individual recipes for how to make each behavior work.\nPatrol\nThe “Patrol” state moves along a pre-defined path (or stands still if there’s no path assigned). See Recipe: Path following for details.\nChase\nThe “Chase” state moves the enemy towards the player. See Recipe: Chasing the player for how to make this behavior.\nAttack\nIn this state, the player is in range of a melee attack, so the enemy stops moving and executes its attack. See Recipe: Melee attacks for how to make melee attacks.\nThese behaviors are states - the enemy can only be in one of these states at a time, and certain events, such as the player getting near, will cause a transition to another state.\nTo determine the state transitions, we have two Area2D nodes on the enemy: an outer one called “DetectRadius” and an inner called “AttackRadius”. The player entering or exiting these areas will trigger the related behavior.\nWe’ve chosen a rectangular shape for AttackRadius in this example due to the shape of the enemy’s attack. Any shape is fine as long as it’s smaller than the DetectRadius.\nConnect the body_entered and body_exited signals of both these areas. If you’re using collision layers (and you should be), set them so that they can only detect the player (or any other body you want to be chased/attacked).\nNow let’s examine the enemy’s script:\nextends KinematicBody2D enum states {PATROL, CHASE, ATTACK, DEAD} var state = states.PATROL We start with an enum to give us a way to reference our states by name, and a variable to hold the current state.\n# For setting animations. var anim_state var run_speed = 25 var attacks = [\"attack1\", \"attack2\"] # For path following. export (NodePath) var patrol_path var patrol_points var patrol_index = 0 # Target for chase mode. var player = null var velocity = Vector2(run_speed, 0) The other variables needed for the individual behaviors and animations. See the referenced behavior links above for details.\nfunc _physics_process(delta): choose_action() # Changing the x scale flips the sprite and its attack area. if velocity.x \u003e 0: $Sprite.scale.x = 1 elif velocity.x \u003c 0: $Sprite.scale.x = -1 # If we're moving, show the run animation. if velocity.length() \u003e 0: anim_state.travel(\"run\" ) # Show the idle animation when coming to a stop (but not attacking). if anim_state.get_current_node() == \"run\" and velocity.length() == 0: anim_state.travel(\"idle\") velocity = move_and_slide(velocity) We’ll handle movement as normal in _physics_process(), calling choose_action() (see below) to decide what the resulting movement will be.\nfunc choose_action(): velocity = Vector2.ZERO var current = anim_state.get_current_node() # If we're currently attacking, don't move or change state. if current in attacks: return # Depending on the current state, choose a movement target. var target match state: states.DEAD: set_physics_process(false) # Move along assigned path. states.PATROL: if !patrol_path: return target = patrol_points[patrol_index] if position.distance_to(target) \u003c 1: patrol_index = wrapi(patrol_index + 1, 0, patrol_points.size()) target = patrol_points[patrol_index] velocity = (target - position).normalized() * run_speed # Move towards player. states.CHASE: target = player.position velocity = (target - position).normalized() * run_speed # Make an attack. states.ATTACK: target = player.position if target.x \u003e position.x: $Sprite.scale.x = 1 elif target.x \u003c position.x: $Sprite.scale.x = -1 anim_state.travel(\"attack\") In choose_action() we determine the target and move toward it.\nfunc _on_DetectRadius_body_entered(body): state = states.CHASE player = body func _on_DetectRadius_body_exited(body): state = states.PATROL player = null func _on_AttackRadius_body_entered(body): state = states.ATTACK func _on_AttackRadius_body_exited(body): state = states.CHASE Finally, the functions connected to the area signals change the state accordingly.\nExpanding This example is intentionally kept as simplified as possible, while still demonstrating complete behaviors. In a larger project, there would likely be a greater number of behaviors, as well as more complex conditions for deciding which one to apply.\nRelated recipes Top-down character Spritesheet animation Controlling animation states Path following Chasing the player ","description":"","tags":null,"title":"Changing behaviors","uri":"/godot_recipes/3.x/ai/changing_behaviors/"},{"content":"Problem A common situation: you have a large number of animations, and it’s becoming difficult to manage transitions between them. Your code has become full of if statements, and every time you change something, it all breaks.\nSolution Use an AnimationTree to create an animation state machine. This will allow us to organize our animations and most importantly, control the transitions between them.\nGetting started For this demo, we’ll be using the excellent “Adventurer” sprite by Elthen. You can get this and lots of other great art at https://elthen.itch.io/.\nWe’ll also assume you’ve already set up the character’s animations using AnimationPlayer. Using the above spritesheet, we have the following animations: “idle”, “run”, “attack1”, “attack2”, “hurt”, and “die”.\nAnimationTree Add an AnimationTree node to the scene. In its Tree Root property, choose “New AnimationNodeStateMachine”.\nAn AnimationTree is a node that controls animations created in AnimationPlayer. To let it access the existing animations, click “Assign” in the Anim Player property and select your animation node.\nNow we can begin to set up our state machine in the AnimationTree panel:\nNote the warning. Set the Active property to “On” in the Inspector.\nRight-click and choose “Add Animation”. Choose “idle”, and you’ll see a small box representing that animation. Press its “Play” button and you should see the animation play. Do the same to add boxes for the other animations.\nNow we can add connections. Click the “Connect nodes” button and drag between nodes to connect them.\nWhen you select an animation, the tree will follow the connected path from the current node to the destination. However, in the configuration above, if you play “attack2” you won’t see “attack1” along the way. That’s because the default “switch mode” for a connection is “Immediate”. Click the “Move/select” button and then click on the connection from “attack1” to “attack2”. In the Inspector, change Switch Mode to “AtEnd”. Do the same with “attack2” to “idle”. The connection icon changes from to .\nNow, with “idle” playing, if you click “attack2”, you’ll see the two attacks play in sequence.\nBut now the animation stops on “attack2”. On its connection, set the Auto Advance property to “On”. This will make the tree go back to “idle” after playing both animations. Note that the connection icon turns green to show this.\nCalling states in code Here is the full tree for all of the animations:\nWe’ve set the “die” node as the end, so when that one is reached, there will be no further animation. In the bottom-left, we have a double-attack sequence.\nNow let’s set up the character to use these animations in a script.\nextends KinematicBody2D var state_machine var run_speed = 80 var attacks = [\"attack1\", \"attack2\"] var velocity = Vector2.ZERO func _ready(): state_machine = $AnimationTree.get(\"parameters/playback\") state_machine holds a reference to the state machine, which is an AnimationNodeStateMachinePlayback. To call a specific animation, you use travel(), which will follow the connections to the given animation.\nfunc _physics_process(delta): get_input() velocity = move_and_slide(velocity) func hurt(): state_machine.travel(\"hurt\") func die(): state_machine.travel(\"die\") set_physics_process(false) Here we have examples of functions we would call if the player is hurt or killed. For the other animations (running, attacking, etc.), we’ll need to combine them with our input and movement code. velocity determines whether we should be showing “run” or “idle”.\nfunc get_input(): var current = state_machine.get_current_node() velocity = Vector2.ZERO if Input.is_action_just_pressed(\"big_attack\"): state_machine.travel(\"attack1 2\") return if Input.is_action_just_pressed(\"attack\"): state_machine.travel(attacks[randi() % 2]) return if Input.is_action_pressed(\"move_right\"): velocity.x += 1 $Sprite.scale.x = 1 if Input.is_action_pressed(\"move_left\"): velocity.x -= 1 $Sprite.scale.x = -1 if Input.is_action_pressed(\"move_up\"): velocity.y -= 1 if Input.is_action_pressed(\"move_down\"): velocity.y += 1 velocity = velocity.normalized() * run_speed if velocity.length() != 0: state_machine.travel(\"run\") if velocity.length() == 0: state_machine.travel(\"idle\") Note that we’re using return after traveling to the attack animations. This is so that we won’t instead travel to the “run” or “idle” animations further down in the function.\nRelated recipes Spritesheet animation Top-down character Like video? ","description":"","tags":null,"title":"Controlling animation states","uri":"/godot_recipes/3.x/animation/animation_state_machine/"},{"content":"Problem You need a “homing missile” - a projectile that will seek a moving target.\nSolution For this example, we’ll use an Area2D node for the projectile. Areas are typically good choices for bullets because we need to detect when they contact something. If you also need a bullet that bounces/ricochets, one of the PhysicsBody type node might be a better choice.\nThe node setup and behavior of the missile is the same you would use for a “dumb” bullet. If you’re creating many bullet types, you can use inheritance to base all your projectiles on the same core setup.\nThe nodes we’ll use:\nArea2D: Missile Sprite CollisionShape2D Timer: Lifetime For the texture, you can use any image you like. Here’s an example one:\nSet up the nodes and configure the sprite’s texture and the collision shape. Make sure to rotate the Sprite node by 90° so that it’s pointing to the right, ensuring it matches the parent’s “forward” direction.\nAdd a script and connect the Area2D’s body_entered signal and the Timer’s timeout signal.\nHere’s the starting script:\nextends Area2D export var speed = 350 var velocity = Vector2.ZERO var acceleration = Vector2.ZERO func start(_transform): global_transform = _transform velocity = transform.x * speed func _physics_process(delta): velocity += acceleration * delta velocity = velocity.clamped(speed) rotation = velocity.angle() position += velocity * delta func _on_Missile_body_entered(body): queue_free() func _on_Lifetime_timeout(): queue_free() This creates a “dumb” bullet that travels in a straight line when fired. To use this projectile, instance it and call its start() method with the desired Transform2D to set its position and direction.\nSee the related recipes section below for more information.\nTo change the behavior to seek a target, we’ll use the acceleration. However, we don’t want the missile to “turn on a dime”, so we’ll add a variable to control its “steering” force. This will give the missile a turning radius that can be adjusted for different behavior. We also need a target variable so that the missile knows what to chase. We’ll set that in start() as well:\nexport var steer_force = 50.0 var target = null func start(_transform, _target): # add this line: target = _target To change the missile’s direction to move toward the target, it needs to accelerate in that direction (acceleration is change in velocity). The missile “wants” to move straight towards the target, but its current velocity is pointing in a different direction. Using a little vector math, we can find that difference:\nThe green arrow represents the needed change in velocity (i.e. acceleration). However, if we turn instantly, that will look unnatural, so the “steering” vector’s length needs to be limited. This is the purpose of the steer_force variable.\nThis is the function to calculate that acceleration. Note that if there’s no target, there will be no steering, so the missile remains traveling in a straight line.\nfunc seek(): var steer = Vector2.ZERO if target: var desired = (target.position - position).normalized() * speed steer = (desired - velocity).normalized() * steer_force return steer Finally, the resulting steer force must be applied in _physics_process():\nfunc _physics_process(delta): acceleration += seek() velocity += acceleration * delta velocity = velocity.clamped(speed) rotation = velocity.angle() position += velocity * delta Here’s an example of the results, with a little extra visual flair such as particle smoke and explosions:\nHere’s the full script, including the above effects. See related recipes for details.\nextends Area2D export var speed = 350 export var steer_force = 50.0 var velocity = Vector2.ZERO var acceleration = Vector2.ZERO var target = null func start(_transform, _target): global_transform = _transform rotation += rand_range(-0.09, 0.09) velocity = transform.x * speed target = _target func seek(): var steer = Vector2.ZERO if target: var desired = (target.position - position).normalized() * speed steer = (desired - velocity).normalized() * steer_force return steer func _physics_process(delta): acceleration += seek() velocity += acceleration * delta velocity = velocity.clamped(speed) rotation = velocity.angle() position += velocity * delta func _on_Missile_body_entered(body): explode() func _on_Lifetime_timeout(): explode() func explode(): $Particles2D.emitting = false set_physics_process(false) $AnimationPlayer.play(\"explode\") yield($AnimationPlayer, \"animation_finished\") queue_free() Note Download the project file here: homing_missiles.zip\nRelated recipes Spritesheet animation Top-down character Transforms Like video? ","description":"","tags":null,"title":"Homing missile","uri":"/godot_recipes/3.x/ai/homing_missile/"},{"content":"Problem You need a player-controlled 3D kinematic body.\nSolution For this recipe, we’ll be using this adorable tank model:\nYou can grab this model on Itch.io: https://gtibo.itch.io/mini-tank or use any other model you’d like. We won’t be doing anything that’s tank-specific here.\nWe can add the model to the scene, but we’ll need a couple of additional nodes:\nFor the collision shape, we’re just going to use a BoxShape aligned and sized with the tank’s treads. CamPos is a Position3D we’ll use to place our following camera. It’s placed behind and above the tank, angled down.\nWe’ve also rotated the individual MeshInstance nodes 180 degrees around the Y axis. This is because they were modeled facing towards +Z, but -Z is the forward direction in Godot, and we don’t want our tank to look like it’s backwards.\nBefore we add a script, open the “Project Settings” and add the following inputs on the “Input Map” tab:\nInput Action Key forward W back S right D left A Now let’s add a script, starting with the required variables:\nextends KinematicBody export var gravity = Vector3.DOWN * 10 export var speed = 4 export var rot_speed = 0.85 var velocity = Vector3.ZERO speed is the tank’s movement speed (forward and back), while rot_speed defines how fast it can turn.\nTip Declaring properties with export makes it easy to adjust them in the Inspector.\nUsing the KinematicBody.move_and_slide() method makes our movement code quite simple:\nfunc _physics_process(delta): velocity += gravity * delta get_input(delta) velocity = move_and_slide(velocity, Vector3.UP) With this code, we add the downward acceleration of gravity to the current velocity, get the user’s input (more about that below), and call move_and_slide(). We pass the velocity and a direction vector of (0, 1) for the up_direction parameter.\nTip Don’t forget to capture the returned velocity vector from move_and_slide(). If you don’t do this, you won’t get the benefits of the movement being slid along the surface.\nNext we need to define get_input(), where we’ll process and apply the input actions:\nfunc get_input(delta): var vy = velocity.y velocity = Vector3.ZERO if Input.is_action_pressed(\"forward\"): velocity += -transform.basis.z * speed if Input.is_action_pressed(\"back\"): velocity += transform.basis.z * speed if Input.is_action_pressed(\"right\"): rotate_y(-rot_speed * delta) if Input.is_action_pressed(\"left\"): rotate_y(rot_speed * delta) velocity.y = vy Let’s examine this more closely. Player input should affect horizontal movement: forward/back along the ground, and rotation around the tank’s center. Movement in the Y direction should only be affected by gravity, which means we don’t want to set it to 0 every frame. This is why we’re using the vy variable to temporarily hold that value while we assign a new velocity vector for the horizontal movement, then add it back in at the end.\nFor the forward and back movement, we’re using transform.basis.z so that we’ll move in our body’s local forward direction.\nHere’s the tank in action. We’ve made a test scene with a StaticBody plane for the ground and an InterpolatedCamera with its Target set to the tank’s CamPos.\nWrapping up This is the basis of movement for any kind of kinematic character. From here you can add jumping, shooting, AI behavior, etc. See the related recipes for examples that build on this recipe.\nRelated recipes Intro to 3D Input Actions Like video? ","description":"","tags":null,"title":"KinematicBody: Movement","uri":"/godot_recipes/3.x/3d/kinematic_body/"},{"content":"Now that we’ve got the basic gameplay, it’s time to start working on the UI. We’re going to need menu screens for the title, settings, and game over.\nMenu screens The three screens will share a common layout and some functionality, so we’ll start with a base scene they can all inherit from. In the new scene, start with a CanvasLayer and name it BaseScreen. Save this scene in the “UI” folder.\nCanvasLayer (“BaseScreen”) MarginContainer VBoxContainer Label HBoxContainer (“Buttons”) Tween The MarginContainer will ensure that none of our UI elements get too close to the edge of the screen. Set all four of its Custom Constants properties to 20.\nNext is a VBoxContainer to organize the main elements. Set its Custom Constants/Separation to 150.\nThe Label node displays the screen’s title. Put “Title” in its Text field and load the same font resource we used for the circles.\nFinally, add an HBoxContainer named “Buttons” which will hold the buttons we add to the screens. Set its Separation to 75. Then duplicate the node so that we have another row of buttons.\nThe screen should start offscreen, so set the Offset on the root node to (500, 0). Then add a script to the scene:\nextends CanvasLayer onready var tween = $Tween func appear(): tween.interpolate_property(self, \"offset:x\", 500, 0, 0.5, Tween.TRANS_BACK, Tween.EASE_IN_OUT) tween.start() func disappear(): tween.interpolate_property(self, \"offset:x\", 0, 500, 0.4, Tween.TRANS_BACK, Tween.EASE_IN_OUT) tween.start() This script sets up the animations we can call to make the screen appear and disappear.\nNow we can make our three inherited scenes. For each, name the root node, change the Label text, and add TextureButtons to the “Buttons” containers. Use the images from the assets folder for each button’s Normal texture. Name each button for its function (“Play”, “Settings”, etc.) and add it to the group “buttons”.\nHere is what the three scenes should look like, using the indicated button names:\nMake one more scene with a Node root named “Screens” and instance the three screens in it. Add the following script, which will handle scene transitions and state.\nextends Node signal start_game var current_screen = null func _ready(): register_buttons() change_screen($TitleScreen) func register_buttons(): var buttons = get_tree().get_nodes_in_group(\"buttons\") for button in buttons: button.connect(\"pressed\", self, \"_on_button_pressed\", [button.name]) func _on_button_pressed(name): match name: \"Home\": change_screen($TitleScreen) \"Play\": change_screen(null) yield(get_tree().create_timer(0.5), \"timeout\") emit_signal(\"start_game\") \"Settings\": change_screen($SettingsScreen) func change_screen(new_screen): if current_screen: current_screen.disappear() yield(current_screen.tween, \"tween_completed\") current_screen = new_screen if new_screen: current_screen.appear() yield(current_screen.tween, \"tween_completed\") func game_over(): change_screen($GameOverScreen) This script connects up all our buttons by linking the pressed signal and passing along the button’s name as a parameter. This lets our _on_button_pressed() method decide what each button should do.\nThe change_screen() method handles transition to the selected screen, including the null option for when we don’t want to display a screen at all.\nRun it to test out the screen transitions:\nInstance this scene in Main, then connect its start_game signal to the new_game() function in main. Don’t forget to remove new_game() from the _ready(). Try running the game and you should be able to start. The last part will be to connect up the game over condition.\nIn the Jumper, add a signal called died and emit that signal in the visibility notifier’s method.\nAdd this to the new_game() function:\nplayer.connect(\"died\", self, \"_on_Jumper_died\") Then add this new function, which will ensure all the circles are removed when the player dies.\nfunc _on_Jumper_died(): get_tree().call_group(\"circles\", \"implode\") $Screens.game_over() Our menu screens are basic and no-frills, but they’re functional. In the next part, we’ll continue the UI work with our score counter and other in-game displays.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video? ","description":"","tags":null,"title":"Menus","uri":"/godot_recipes/3.x/games/circle_jump/circle_jump_04/"},{"content":"Problem You want to pick up and move rigid bodies with the mouse.\nSolution Working with rigid bodies can be tricky. Godot’s physics engine controls their movements, and interfering with that can often lead to unexpected results. The key is to make use of the body’s mode property. This applies equally well in 2D or 3D.\nBody setup We’ll start with our rigid body object, adding a Sprite and CollisionShape2D. You can also add a PhysicsMaterial if you want to set Bounce and Friction properties.\nPlace the body in a group called “pickable”. We’ll use this to allow for multiple instances of the pickable object in the main scene. Attach a script and connect the body’s _input_event signal.\nextends RigidBody2D signal clicked var held = false func _input_event(viewport, event, shape_idx): if event is InputEventMouseButton: if event.button_index == BUTTON_LEFT and event.pressed: emit_signal(\"clicked\", self) We’ll emit a signal when a mouse click is detected. Since there can be many bodies, we’ll let the main scene manage whether a body can be dragged or if there’s already one in the held state.\nfunc _physics_process(delta): if held: global_transform.origin = get_global_mouse_position() If the body is being dragged, we update its position to follow the mouse.\nfunc pickup(): if held: return mode = RigidBody2D.MODE_STATIC held = true func drop(impulse=Vector2.ZERO): if held: mode = RigidBody2D.MODE_RIGID apply_central_impulse(impulse) held = false Finally, these are the two functions to call when the body is picked up and dropped. Changing the mode to MODE_STATIC removes the body from physics engine processing. Note that other objects can still collide with it. If you don’t want that, you can disable the collision_layer and/or collision_mask here as well. Just remember to re-enable them when dropping.\nIn the drop function, when we change back to MODE_RIGID, the body will be asleep. A sleeping body can be awoken by applying an impulse to it (even a zero magnitude impulse is fine). However, by passing in an optional impulse value, we can “throw” the object on release.\nMain scene Create a main scene with some static body obstacles or a TileMap and instance a few copies of the pickable body.\nHere’s the script for the main scene:\nextends Node2D var held_object = null func _ready(): for node in get_tree().get_nodes_in_group(\"pickable\"): node.connect(\"clicked\", self, \"_on_pickable_clicked\") func _on_pickable_clicked(object): if !held_object: held_object = object held_object.pickup() Here’s where we connect up the signal from the rigid body instances. The connected function sets held_object so that we know something is currently being dragged, and calls the body’s pickup() method.\nfunc _unhandled_input(event): if event is InputEventMouseButton and event.button_index == BUTTON_LEFT: if held_object and !event.pressed: held_object.drop(Input.get_last_mouse_speed()) held_object = null Lastly, when the mouse is released during dragging, we can perform the reverse actions. Note the use of get_last_mouse_speed() - be careful with this! You may find yourself launching the rigid bodies at high speeds, especially if the bodies have low mass values. It’s probably a good idea to clamp() this to a reasonable value. Experiment to find out what works for you.\nNote Download the project file here: rigidbody_drag_and_drop.zip\nRelated recipes Using Rigid Bodies Kinematic to Rigid Body Interaction ","description":"","tags":null,"title":"RigidBody2D: Drag and Drop","uri":"/godot_recipes/3.x/physics/rigidbody_drag_drop/"},{"content":"Problem You need to save and load local data between game sessions.\nSolution Godot’s file I/O (input/output) system is based around the File object. You open a file by creating a new File object and calling open().\nvar file = File.new() file.open(\"user://myfile.name\", File.READ) Warning User data should only be stored in the user:// path. While res:// can be used when running from the editor, when your project is exported, the res:// path becomes read-only.\nThe second argument after the file path is the “Mode Flag”, which can be one of the following:\nFile.READ - Open for reading. File.WRITE - Open for writing. Creates the file if it doesn’t exist and truncates if it does. File.READ_WRITE - Open for reading and writing. Doesn’t truncate the file. File.WRITE_READ - Open for reading/writing. Creates the file if it doesn’t exist and truncates if it does. Storing data You can save data using its specific data type (store_float(), store_string(), etc.), or using the generic store_var(), which will use Godot’s built-in serialization to encode your data, including complex data like objects (more on this later).\nLet’s start with a small example: saving the player’s high score. We can write a function that we can call whenever the score needs to be saved:\nvar score_file = \"user://score.save\" func save_score(): var file = File.new() file.open(score_file, File.WRITE) file.store_var(highscore) file.close() Tip Don’t forget to close() the file when you’re finished accessing it.\nWe’re saving our score, but we need to be able to load it when the game starts:\nfunc load_score(): var file = File.new() if file.file_exists(score_file): file.open(score_file, File.READ) highscore = file.get_var() file.close() else: highscore = 0 Don’t forget to check for the file’s existence before attempting to read from it - it may not be there! If that’s the case, you can use a default value.\nSaving objects You can save more than just basic data types. Using store_var()’s full_objects parameter you can save any object, including custom ones. For example, let’s say you have a custom object defined:\nextends Node class_name CustomObject var a = 10 func say_hello(): print(\"hello\") And then your save/load code would look like this:\nvar score_file = \"user://score.save\" var c = CustomObject.new() func save_to_file(): var file = File.new() file.open(score_file, File.WRITE) file.store_var(c, true) file.close() func load_from_file(): var file = File.new() if file.file_exists(score_file): file.open(score_file, File.READ) c = file.get_var(true) file.close() var c func _ready(): load_from_file() c.say_hello() What about JSON? I see it very often (and some readers may be asking it already): “What if I want to use JSON to save my data?” This is my response:\nDon’t use JSON for your save files!\nWhile Godot has JSON support, saving game data is not what JSON is for. JSON is a data interchange format - its purpose is to allow systems using different data formats and/or languages to exchange data between each other.\nThis means JSON has limitations that are negatives for you when it comes to saving your game data. JSON doesn’t support many data types (no int vs. float, for example) so you have to do a lot of converting and validating to try and save/load your data. It’s cumbersome and time consuming.\nDon’t waste your time. Using Godot’s built-in serialization, you can store native Godot objects - Nodes, Resources, even Scenes - without any effort, which means less code and fewer errors.\nWrapping up This article just scratches the surface of what you can do with the File object. For the full list of available File methods, see the File documentation.\n","description":"","tags":null,"title":"Saving/loading data","uri":"/godot_recipes/3.x/basics/file_io/"},{"content":"Problem You are using a TileMap, and want to use autotiling to more quickly draw your levels.\nSolution For this demo, we’ll be using the following tileset:\nNote These tiles are from Kenney’s “Topdown Shooter” art pack, which you can find here:https://kenney.nl/assets/topdown-shooter\nCreating a map from these tiles, if you were adding them one-by-one, would be a tedious process. You would be constantly changing between tiles to line up corners, intersections, and endpoints.\nUsing autotiling, you to draw the walls freely, and the autotiling algorithm selects the correct tiles to make everything line up.\nHere’s an example:\nHow autotiling works The tiles we’re using are designed for a 3x3 (minimal) tiling. Consider a single tile divided into a 3x3 grid:\nWe can mark the “active” portions of the tile (i.e. the parts that are not the wall):\nIf we were to do this with each tile, the computer can then make sure that whatever tile is placed adjacent to this one will match up.\nIn a 3x3 grid there are 512 possible combinations (2^9). We can discard most of these, as they don’t make sense for making continuous walls. It turns out, to properly cover the wall combinations, you need 48 tiles, which we have in our tileset. We’ll be ignoring the 7 tiles in the bottom-right (the ones with the white background).\nMaking the TileSet In your TileMap’s Tile Set property, select “New TileSet” and click on it to open. You’ll see the TileSet editor panel open:\nClick the ⊞ button to add a texture, choosing the tile set from above. Then click “New Autotile” and drag to select the whole image. You will probably need to enable snap and adjust the options. The tiles in this tilest are 64x64 and have a 10 pixel separation. If you’re using your own art, you’ll need to enter your own values.\nNow that you have selected the set of tiles to make up the autotile group, it’s time to set the bitmasks. Click the “Bitmask” button at the top and start clicking in the tiles. The masked area will appear red. When you’re done it should look like this:\nRemember, we’re not using the tiles in the lower-right corner.\nLastly, click the “Icon” button and select a tile you’d like to use as the icon for the autotile group. This is the tile that will show under the cursor as you’re drawing.\nSwitch back to the TileMap, and you should be able to start drawing. If something is wrong, check your bitmasks and make sure you didn’t miss a square on any of the tiles. Compare with the picture above.\nFull TileSet You can also add collision, navigation, or occlusion to your autotile set. If you download the example project below, you’ll find a complete tileset with polygons defined on all the tiles.\nNote Download the project file here: autotile_intro.zip\n","description":"","tags":null,"title":"TileMap: using autotile","uri":"/godot_recipes/3.x/2d/autotile_intro/"},{"content":" Input Handling input - from keyboard and mouse to game controllers and touchscreens.\nIn this section: Input Actions Mouse Input Adding Input Actions in code Capturing the Mouse Customizing the Mouse Cursor Mouse: Drag-select multiple units ","description":"","tags":null,"title":"Input","uri":"/godot_recipes/3.x/input/"},{"content":" Animation Using Godot’s animation system.\nIn this section: Spritesheet animation Melee attacks Controlling animation states ","description":"","tags":null,"title":"Animation","uri":"/godot_recipes/3.x/animation/"},{"content":" GDScript GDScript is Godot’s built-in scripting language. Its syntax is based on Python, so if you’re familiar with that language, you’ll feel right at home. In this chapter, we’ll introduce the language and get you up to speed with how it works.\nIn this section: GDScript: Getting started ","description":"","tags":null,"title":"GDScript","uri":"/godot_recipes/3.x/g101/gdscript/"},{"content":" Intro to 3D A gentle introduction to the 3D side of Godot development.\nIn this section: The 3D Editor Importing 3D Objects Creating a 3D Character Using Areas Edge Detection \u0026 Mouse Capture Using CSG First-person Character ","description":"","tags":null,"title":"Intro to 3D","uri":"/godot_recipes/3.x/g101/3d/"},{"content":" UI Building user interfaces.\nIn this section: Labels Containers Cooldown Button Heart Containers: 3 Ways Displaying debug data Object Healthbars Floating combat text Level Select Menu Minimap/radar Radial Popup Menu ","description":"","tags":null,"title":"UI","uri":"/godot_recipes/3.x/ui/"},{"content":"In the last part, we learned how to use Area nodes to detect contact between objects, making coin, bullet, and spike objects for our character to interact with. In this part, we’ll look at a few small improvements: capturing the mouse, animating the coins, and detecting edges so our character doesn’t fall.\nCapturing the Mouse One issue with our mouse-based controls is that as you move the mouse from side to side, it eventually moves out of the game window and hits the edge of your screen. To solve this, we need to “capture” the mouse. However, if we do that, we won’t be able to close the window or anything else - our mouse will be gone! We’ll need a way to release the mouse again.\nFirst, to capture the mouse, add the following to the main scene:\nfunc _ready(): Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) This takes care of the first part: the mouse will now be captured by our game window. Now we need it to be released when we press the “Escape” key. Let’s put this in the main script as well:\nfunc _input(event): if event.is_action_pressed(\"ui_cancel\"): Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE) Run the game and try it out.\nLet’s also ignore mouse motion when it’s not captured. In the character script, change this line in _unhandled_input():\nif event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED: Now we have another issue: once you’ve pressed “Escape”, we don’t have a way to go back to being captured. Let’s do that if we click on the window:\nfunc _input(event): if event.is_action_pressed(\"ui_cancel\"): Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE) if event.is_action_pressed(\"shoot\"): if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE: Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) This works OK, but when we click to recapture the mouse, we also fire a bullet, since the mouse click does that as well. We can solve this by marking the input as “handled”, so that Godot won’t send it on to any other nodes:\nif event.is_action_pressed(\"shoot\"): if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE: Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) get_tree().set_input_as_handled() Now that first click capturing the mouse won’t also fire a bullet.\nAnimated Coins Now we’re going to make the coins from the last part a bit more dynamic and appealing. Open Coin.tscn and add an AnimationPlayer to the scene.\nClick the “Animation” button and select “New” to create a new animation called “bounce”. A duration of 1 second is fine, but make sure to enable looping.\nWe’re going to animate two properties of the coin: position (on the Y axis, up and down) and rotation. Ensure the scrubber is at time 0 and add a keyframe for both Translation and Rotation Degrees.\nMove the scrubber to the 0.5 second mark, change the Y component of the translation to 0.3, and click the keyframe button. Then move the scrubber all the way to 1.0 and keyframe the rotation at 180 degrees in Y.\nPress “Play” to see how your animation looks. Try clicking on the individual translation keyframes and adjusting the Easing value.\nFinally, click the “Autoplay” button to ensure the animation will automatically start when the game is run.\nEdge Detection Finally, let’s see if we can keep our character from running off a cliff and falling to its death.\nStart by adding a RayCast node to the player. It appears as a thin blue line. By default, its Cast To property is set to (0, -1, 0), which is pointing down. This is good, but we also need to move it forward so that it’s pointing down at the front of the character:\nAlso, make sure to check the Enabled property, or the RayCast won’t work.\nNow, in our character script, we need to check that when moving forward, if the RayCast is colliding, it’s safe to move.\nRight now, we have the following:\nif Input.is_action_pressed(\"move_forward\"): velocity += -transform.basis.z * speed Let’s try only adding to the velocity if the ray is colliding:\nif Input.is_action_pressed(\"move_forward\") and $RayCast.is_colliding(): velocity += -transform.basis.z * speed Try it out. When you run up to an edge, you’ll stop. But wait - have you tried jumping forward? Our forward movement is now canceled when we’re in the air! Back to the drawing board.\nNow we need to also check if we’re on the ground, so that if we walk forward and the ray stops colliding, we do nothing. Otherwise, we move as normal:\nif Input.is_action_pressed(\"move_forward\"): if is_on_floor() and !$RayCast.is_colliding(): pass else: velocity += -transform.basis.z * speed Info You may be wondering why I wrote it this way. Keep reading, there’s a reason!\nThis works, but something feels off about the code. We have a conditional statement that does nothing. Surely we can simplify this. We can, with a little bit of Boolean Algebra.\nOur conditional statement is essentially this:\nif A: do_nothing else: do_something Which is equivalent to:\nif not A: do_something So what we really need to do is convert our conditional statement to:\nif !(is_on_floor() and !$RayCast.is_colliding()) This works, but it’s hard to read. Can it be simplified? It can, using a Boolean Algebra method called “De Morgan’s Law”. De Morgan’s Law states that\nnot (A and B) = not A or not B So we can apply that here and we get the following:\nif Input.is_action_pressed(\"move_forward\"): if !is_on_floor() or $RayCast.is_colliding(): velocity += -transform.basis.z * speed In English:\n“If we’re not on the floor or there is floor in front of us, move forward.”\nThis is a very simplistic implementation - you can still walk sideways or backwards off the edge, for example. Feel free to take this idea and run with it to make improvements. Some games let you fall if you move off the edge slowly, but stop you if you’re moving fast.\nWrapping Up In this tutorial, we added a few small improvements to the game. Capturing the mouse is useful in many types of 3D games (first-person, for example), and RayCasts have a wide range of uses - we only touched on one here. The animation we added was very small, but a good start - we’ll be using them for many things as we move forward.\nIn the next part: Using Constructed Solid Geometry (CSG).\nYou can also find a video version of this lesson here: ","description":"","tags":null,"title":"Edge Detection \u0026 Mouse Capture","uri":"/godot_recipes/3.x/g101/3d/101_3d_05/"},{"content":"Problem You want a floating “healthbar” for your 3D game objects (mobs, characters, etc.).\nSolution For this solution, we’re going to re-use a 2D healthbar based on a TextureProgress node. It’s already set up with textures and code for updating the value and color. If you already have something similar, feel free to use it here. In the example, we’ll name this scene “Healthbar2D”.\nIf you need some assets, here are the three images used in the bar:\nNote Re-using existing objects can save you a lot of time. Don’t re-invent the wheel everytime you need a healthbar, camera, or other common object.\nProject setup We’ll start with a KinematicBody mob. It’s programmed to spawn and travel in a straight line. It also has the following code to handle damage:\nfunc _on_Mob_input_event(camera, event, click_position, click_normal, shape_idx): if event is InputEventMouseButton: if event.button_index == BUTTON_LEFT and event.pressed: health -= 1 if health \u003c= 0: queue_free() Clicking on a unit deals one damage. Do ten damage, and the unit is destroyed. Now we need a visual representation of that using our 2D bar.\n2D in 3D You can display a 2D image in 3D using a Sprite3D. Add one to a new scene and name it “Healthbar3D”. First, we’ll get it configured and sized, so set the Texture to the green bar image.\nThe Sprite3D acts like any other 3D object - as we pan the camera around, our perspective on it changes. However, we want the healthbar to always “face” toward the camera so that we can see it.\nIn the Inspector, under Flags, set Billboard to “Enabled”.\nNow try moving the camera to confirm that the texture is always facing you.\nAdd an instance of this scene to the Mob scene and position the bar above the mob’s body.\nViewport texture We don’t want the Sprite3D to show a static texture - we want it to display the 2D TextureProgress. We can do that using a Viewport node, which can export a texture.\nAdd a Viewport as a child of the Sprite3D. In the Inspector set these properties:\nTransparent Bg: On Rendering/Usage: 2D Render Target/V Flip: On We also need to set the size of the viewport to match the size of the healthbar texture, which is (200, 26).\nInstance the HealthBar2D as a child of the Viewport. Your scene should look like this:\nIf the Viewport were not a child of the Sprite3D, we could set it as the sprite’s texture directly in the Inspector. Since it’s a child, it won’t be ready at the right time, so we’ll need to set it in a script attached to the Sprite3D:\nextends Sprite3D func _ready(): texture = $Viewport.get_texture() Connecting it all together In the mob’s _on_Mob_input_event() method, add the following after reducing the health:\n$HealthBar3D.update(health, max_health) Add the following to HealthBar3D.gd:\nonready var bar = $Viewport/HealthBar2D func update(value, full): bar.update_bar(value, full) This calls the update method that already exists on the 2D bar, setting the progress bar’s value and selecting the bar color:\nfunc update_bar(amount, full): texture_progress = bar_green if amount \u003c 0.75 * full: texture_progress = bar_yellow if value \u003c 0.45 * full: texture_progress = bar_red value = amount Click on the mobs to see the health bars change.\nNote Download the project file here: 3d_labels.zip\nWrapping up You can use this technique to display any other Control nodes, such as Label, VideoPlayer, etc. You can even use the Viewport to “project” an entire 2D game in 3D space.\nRelated Recipes Object Healthbars (2D) Like video? ","description":"","tags":null,"title":"3D Unit Healthbars","uri":"/godot_recipes/3.x/3d/healthbars/"},{"content":"Problem You want to make RPG-style ability buttons, including a cooldown effect.\nSolution If you need art for your buttons, you can find a wide variety of well-designed buttons at Game-icons.net. We’ll be using a few from there for this recipe.\nNode setup The scene for our ability button will need the following nodes:\nAbilityButton: TextureButton Sweep: TextureProgress Timer Counter: MarginContainer Value: Label Drop your chosen icon into the Texture property of the AbilityButton.\nOn the Sweep node, choose “Full Rect” from the Layout menu. Set the Fill Mode to “Counter Clockwise”.\nWe also want our cooldown “radial wipe” to darken the button, so set the Modulate property to a dark gray with some transparency:\nThe Timer node should be set to “One Shot”.\nCounter is a container to hold and align the text. Set its Layout to “Bottom Wide”, and in its Custom Constants, both Margin Right and Margin Left to 5.\nFinally, on the Value label, set Align to “Right” and Clip Text to “On”. Choose a font by adding a DynamicFont and setting an appropriate size. Put a value like 0.0 in the Text field to check how it works. Since our icon is black and white, it also helps to add an Outline Size of 1 in the font’s settings.\nScript Add a script to the AbilityButton. Connect the Timer’s timeout signal and the AbilityButton’s pressed signal.\nextends TextureButton onready var time_label = $Counter/Value export var cooldown = 1.0 func _ready(): $Timer.wait_time = cooldown time_label.hide() $Sweep.texture_progress = texture_normal $Sweep.value = 0 set_process(false) We start by exporting a cooldown variable for the length of our ability’s cooldown. Then, in the _ready() method, we can set the Timer to use that value. Then we hide the label, because we only want to display it during the countdown.\nNext, we need a texture to assign to the TextureProgress display. In this case, we’ll copy the texture from the button - you could also use a different texture if you like.\nFinally, we make sure the sweep’s value is at 0, and set the node’s processing to false. We’ll do the animation in _process() so we don’t need it running when we’re not in cooldown mode.\nfunc _process(delta): time_label.text = \"%3.1f\" % $Timer.time_left $Sweep.value = int(($Timer.time_left / cooldown) * 100) In _process() we use the time_left on the timer to set the label’s text and the sweep’s value.\nfunc _on_AbilityButton_pressed(): disabled = true set_process(true) $Timer.start() time_label.show() When the button is clicked, everything gets started.\nfunc _on_Timer_timeout(): print(\"ability ready\") $Sweep.value = 0 disabled = false time_label.hide() set_process(false) And everything is reset when the timer runs out. Put several buttons in an HBoxContainer and you’ve got an action bar:\nNote Download the project file here: cooldown_button.zip\nRelated recipes UI: Labels UI: Containers ","description":"","tags":null,"title":"Cooldown Button","uri":"/godot_recipes/3.x/ui/cooldown_button/"},{"content":"Problem You want to use a custom mouse cursor.\nSolution Setting the mouse cursor is done with Input.set_custom_mouse_cursor(). All you need is a texture to use. The texture must be no larger than 256x256 pixels in size.\nFor example, to use the following image:\nAnd set its hotspot to the center:\nextends Node2D func _ready(): Input.set_custom_mouse_cursor(cursor_image, Input.CURSOR_ARROW, Vector2(64, 64)) The second parameter sets which system cursor to replace. See the Input docs for the full list.\n","description":"","tags":null,"title":"Customizing the Mouse Cursor","uri":"/godot_recipes/3.x/input/custom_mouse_cursor/"},{"content":"Problem You need to display a heart container bar (or other icon-based bar).\nSolution A common way of displaying the player’s health is via a series of icons (typically hearts) that disappear as the player takes damage.\nIn this recipe, we’re going to explore three ways of displaying this information, which I’m labeling “simple”, “empty”, and “partial”:\nThis image shows what the bar displays when the player has 3 health.\nsimple: Only the hearts are displayed. empty: Empty heart containers are displayed. partial: The player can have partially filled containers. Setting up the bar The heart images I’m using are 53x45. You can get them here:\nKenney.nl: Platformer Art Deluxe\nIdeally, your heart bar will be easy to drop into your overall HUD/UI. It therefore makes sense to make it a separate scene. We’ll start with an HBoxContainer which will keep things aligned. Set the Custom Constants/Separation to 5.\nAdd a TextureRect child. Drag your heart texture into the Texture property and set the Stretch Mode to “Keep”. Name the node “1” and then press “Ctrl-D” to duplicate the node for as many hearts as you need (5 in this example). Your node setup should look like this:\nAdding a script The script below will cover all three bar configurations for flexibility. If you only need one in your game, you can remove the code relating to the other modes.\nTo begin, we’re going to load the textures we need and define our three bar modes:\nextends HBoxContainer enum MODES {simple, empty, partial} var heart_full = preload(\"res://assets/hud_heartFull.png\") var heart_empty = preload(\"res://assets/hud_heartEmpty.png\") var heart_half = preload(\"res://assets/hud_heartHalf.png\") export (MODES) var mode = MODES.simple func update_health(value): match mode: MODES.simple: update_simple(value) MODES.empty: update_empty(value) MODES.partial: update_partial(value) Calling update_health() on the bar will cause it to display the passed value, based on the selected mode.\nNote We’re not going to do any bounds checking on the value input. There are many ways you may have health implemented in your game, and so that’s left to you.\nFirst, the update_simple() method. Here, we loop through the heart containers and set the visibility of each TextureRect:\nfunc update_simple(value): for i in get_child_count(): get_child(i).visible = value \u003e i update_empty() is very similar, except instead of hiding the icon, we change its texture to the empty container:\nfunc update_empty(value): for i in get_child_count(): if value \u003e i: get_child(i).texture = heart_full else: get_child(i).texture = heart_empty Finally, for the partially filled containers, we have a third texture and twice the number of possible values:\nfunc update_partial(value): for i in get_child_count(): if value \u003e i * 2 + 1: get_child(i).texture = heart_full elif value \u003e i * 2: get_child(i).texture = heart_half else: get_child(i).texture = heart_empty Here’s an example using each of the bar modes:\nWrapping up Use this heart bar setup as a basis for your own HUD. This technique can be expanded to support a wide variety of information displays.\nNote Download the project file here: heart_bars.zip\nRelated recipes UI: Containers ","description":"","tags":null,"title":"Heart Containers: 3 Ways","uri":"/godot_recipes/3.x/ui/heart_containers_3/"},{"content":"Problem You want your kinematic character to interact with rigid bodies.\nSolution Note This recipe applies equally well in both 2D and 3D nodes.\nBy default, a kinematic body moved with move_and_slide() or move_and_collide() will push any rigid bodies it collides with. This interaction ignores the rigid body’s physics properties due to the kinematic move function’s infinite_inertia parameter.\nIn some cases, this might be all you need. However, if you want to avoid “glitches” such as body overlap, tunneling, and other unrealistic behavior, you’ll need to add some code for the interactions.\nFor this example, we’ll use the 2D character described in the Platform character recipe.\nThe most commonly used movement method for kinematic bodies is move_and_slide(). In the example code, the movement happens on this line:\nvelocity = move_and_slide(velocity, Vector2.UP) This causes the body to move in the given direction and slide along obstacles when colliding, as well as using the floor_normal parameter to determine what surfaces should count as a “floor”. move_and_slide() also contains additional parameters:\nmove_and_slide ( Vector2 linear_velocity, Vector2 floor_normal=Vector2( 0, 0 ), bool stop_on_slope=false, int max_slides=4, float floor_max_angle=0.785398, bool infinite_inertia=true ) It’s that last one that needs to be changed. Since GDScript doesn’t have named parameters, this means we have to pass all of them, but we can keep them at their default values:\nvelocity = move_and_slide(velocity, Vector2.UP, false, 4, PI/4, false) Now if you try to move, you’ll see that the kinematic body just stops on collision. It can’t push the rigid body at all.\nTo give the colliding body a “push” we’ll need to apply an impulse. An impulse is an instantaneous “kick” - think of a bat hitting a ball. This is as opposed to a force, which is a continuous “push” on an object.\n# This represents the player's inertia. export (int, 0, 200) var push = 100 func _physics_process(delta): # after calling move_and_slide() for index in get_slide_count(): var collision = get_slide_collision(index) if collision.collider.is_in_group(\"bodies\"): collision.collider.apply_central_impulse(-collision.normal * push) The collision normal points out of the rigid body, so we reverse it to point away from the character and apply the push factor. Now pushing works again, but it won’t force the rigid bodies through walls:\nYou can also scale the force of the impulse based on the character’s speed:\ncollision.collider.apply_central_impulse(-collision.normal * velocity.length() * push_factor) # Depending on your character's movement speed, adjust push_factor to # something between 0 and 1. Experiment to find the settings that work for your particular game.\nNote Download the project file here: kinematic_vs_rigid.zip\nRelated recipes Platform character Like video? ","description":"","tags":null,"title":"Kinematic to Rigid Body Interaction","uri":"/godot_recipes/3.x/physics/kinematic_to_rigidbody/"},{"content":"Problem You need your kinematic body to align with the surface it’s standing on.\nSolution Warning As of Godot 3.2, there is a bug preventing KinematicBody2D’s stop_on_slope parameter from working correctly. The technique in this recipe can be used as a workaround for this problem. See GitHub for details and other suggestions regarding this issue.\nWe’ll start with a basic kinematic platform character. See the Platform character recipe for details.\nWe have the following code for movement:\nfunc _physics_process(delta): get_input() velocity.y += gravity * delta velocity = move_and_slide(velocity, Vector2.UP, true) if is_on_floor(): is_jumping = false if Input.is_action_just_pressed(\"ui_up\"): is_jumping = true velocity.y = jump_speed As you can see, there are a couple of problems. First, the character flies off the slope when running. It’s also sliding down the slope when there’s no input.\nWe can partially solve this by switching from move_and_slide() to move_and_slide_with_snap():\nsnap = Vector2.DOWN * 128 if !is_jumping else Vector2.ZERO velocity = move_and_slide_with_snap(velocity, snap, Vector2.UP, true) Now we have an upward “hop” when we stop on the way up the slope. This is because our x velocity is set to 0 by the lack of input, but the y is not.\nOrienting the velocity We can fix this by orienting our velocity relative to the slope. To illustrate, let’s first rotate the character to align with the slope. We can do this by checking the floor normal when we’re on the floor:\nif is_on_floor(): rotation = get_floor_normal().angle() + PI/2 This hasn’t changed anything about the movement yet, but it does help us visualize what we need to do. When we’re on the slope, our local transform looks like this:\nNow when we move, we want our x velocity to align with our local x axis (the red arrow), and gravity/jump to align with local y (the green arrow). We can keep our input code the same, and just assume that velocity is always calculated in the local coordinate system. The only problem will be that move_and_slide() expects the velocity vector to be in global coordinates. Let’s adjust move_and_slide_with_snap() to account for this:\nsnap = transform.y * 128 if !is_jumping else Vector2.ZERO velocity = move_and_slide_with_snap(velocity.rotated(rotation), snap, -transform.y, true) # Convert velocity back to local space. velocity = velocity.rotated(-rotation) We’ve changed a few things here, so let’s look at them carefully.\nThe snap vector is now our local down vector, so it will always point directly into the slope. The floor_normal parameter is also changed to the local up direction (-transform.y). We convert velocity to global by rotating it to match the player’s rotation, then revert the resulting velocity back to local by doing the reverse. The result:\nWrapping up This technique allows for a wide range of possible platformer-style movement schemes. For example, you can do fun things like this:\nHere’s the full script:\nfunc _physics_process(delta): get_input() velocity.y += gravity * delta snap = transform.y * 128 if !is_jumping else Vector2.ZERO velocity = move_and_slide_with_snap(velocity.rotated(rotation), snap, -transform.y, true, 4, PI/3) velocity = velocity.rotated(-rotation) if is_on_floor(): rotation = get_floor_normal().angle() + PI/2 is_jumping = false if Input.is_action_just_pressed(\"ui_up\"): is_jumping = true velocity.y = jump_speed Related recipes Platform character Using KinematicBody2D ","description":"","tags":null,"title":"KinematicBody2D: align with surface","uri":"/godot_recipes/3.x/2d/2d_align_surface/"},{"content":" Circle Jump An end-to-end game development series. In this series, we build a one-touch mobile game called “Circle Jump”. Here’s what the game looks like:\nIn each part of the series, we’ll add features and fix bugs, explaining the process along the way.\nThe game is be available on the following platforms:\nAndroid: Google Play Store iOS: coming soon Web: Game of the Month You can also download it for desktop platforms from Itch.io:\nCircle Jump by kidscancode All source code for the game is available on GitHub.\n","description":"","tags":null,"title":"Mobile Game: Circle Jump","uri":"/godot_recipes/3.x/games/circle_jump/"},{"content":"Problem You need moving platforms in your 2D platformer.\nSolution There are several ways to approach this problem. In this recipe, we’ll use KinematicBody2Ds for our platforms and move them with AnimationPlayer. This allows for a variety of movement styles while minimizing the amount of code we need to write.\nSetting up We’ll start with a basic platformer setup using the Platform character recipe. We will need to make one small modification from that recipe: using move_and_slide_with_snap() for the movement.\nHere is the updated code:\nfunc _physics_process(delta): get_input() velocity.y += gravity * delta var snap = Vector2.DOWN * 16 if is_on_floor() else Vector2.ZERO velocity = move_and_slide_with_snap(velocity, snap, Vector2.UP) if Input.is_action_just_pressed(\"jump\"): if is_on_floor(): velocity.y = jump_speed With this code, we’ll still get the same behavior with jumping and sliding, but the snap value will ensure that the character “sticks” to the platform even if it moves. See the KinematicBody2D docs for more information on how the snap parameter works.\nCreating the platform The platform scene contains the following nodes:\nThe Node2D parent is there to act as the “anchor” or start point for the platform. We’ll animate the platform’s position relative to this parent node.\nSet up the Sprite’s Texture and the collision shape appropriately. In the KinematicBody2D, set the Sync to Physics property “On”. Since we’re not moving the body in code, this ensures that it’s moved during the physics step. You’ll also need to set the Process Mode property of the AnimationPlayer to “Physics”.\nTo move the platform, create an animation in the AnimationPlayer that animates the body’s position property. For example, here’s one animating the platform horizontally in a 4 second loop:\nYou’re done! Instance some platforms in your level/world and try them out:\nNote Download the project file here: moving_platforms.zip\nRelated recipes Platform character Like video? Coming soon\n","description":"","tags":null,"title":"Moving Platforms","uri":"/godot_recipes/3.x/2d/moving_platforms/"},{"content":"Problem You want to use Godot’s OpenSimplexNoise to generate noise, noise textures, and other effects.\nSolution Noise, or more specifically gradient noise is a method for generating more natural-looking “random” patterns. To do this, Godot provides the OpenSimplexNoise class.\nInfo Probably the most well-known gradient noise algorithm is called Perlin noise. Because it and its successor, simplex noise, are protected by patents, Godot uses an algorithm called OpenSimplex to generate noise.\nOpenSimplexNoise works by generating a 3D “cloud” of points. Each point has a value ranging from -1 to 1. Below are two examples of noise generated by OpenSimplexNoise. In the images, each pixel’s white value is mapped to the noise value at that point.\nThe parameters used for configuring OpenSimplexNoise:\nseed - The seed used to generate the random values. Default value: 0. period - Lower values result in higher frequency noise (i.e. more changes in value across the same distance). Default value: 64. octaves - The number of noise layers that contribute to the result. Each successive layer affects the result less (based on the persistence). Default value: 3. lacunarity - The difference in period between octaves. Default value: 2. persistence - The amount that each octave contributes to the noise. Default value: 0.5. Here’s the easiest way to experiment with the effects of the different parameters. Add a Sprite and in its Texture property, choose “New NoiseTexture”. In that NoiseTexture for Noise choose “New OpenSimplexNoise”.\nYou’ll see a black-and-white texture that’s generated based on the noise values. Adjust the values and observe the effect on the image.\nUsing noise values Once you have your noise configured, there are a few ways you can access the values.\nget_noise_2d(x, y) get_noise_3d(x, y, z) get_noise_4d(x, y, z, w) In each case, the result is a value in the range [-1, 1].\nTip You may have noticed there’s no get_noise_1d() method. If you need one-dimensional noise, use get_noise_2d() and keep one of the values constant.\nFor example, we can use get_noise_3d() to generate a 2d image while varying the third dimension over time to get an animated effect:\nIn this image the color is based on the noise value. Since we don’t want negative values for color, we use\nvar value = get_noise_3d(x, y, z) * 0.5 + 0.5\nto modify the results to the range [0, 1]. Then, this value is applied to color using the following formula:\nColor(1.0-value/2.0, 0.5-value/2.0, value/4.0)\nNoise applications Noise can be used for a wide range of applications:\nProcedural terrain generation Visual effects (water, fog, fire, etc) Related recipes Screen Shake Like video? ","description":"","tags":null,"title":"Noise","uri":"/godot_recipes/3.x/math/noise/"},{"content":"In the last part, we added UI in the form of menus to start and configure the game. We also need a UI to display in-game information such as score.\nHUD scene Add a new scene with a CanvasLayer root to be our HUD. Give it two children: a MarginContainer named “ScoreBox” and a `Label\" named “Message”.\nYour scene tree should look like this:\nSet the layout of the ScoreBox to “Bottom Wide” and the Custom Constants all to 20. Add an HBoxContainer child and under that two Label nodes. Name the second label “Score” and put 100 in its Text property. Set the HBoxContainer’s Alignment to “End”.\nAdd the same DynamicFont resource to both labels, but choose “Make Unique” on the first label and set its size to 32. Set its Text property to “Score”. In its _Size Flags/Vertical, set “Fill”. Your layout should look like this:\nNow for the Message node load the font and set Text to “Message” so we’ll have something to see. Also choose “Make Unique” on the font resource (you’ll see why in the next section). Set Align and Valign to “Center” and Clip Text to “On”. For layout, choose “Center Wide”. Also, set Grow Direction/Vertical to “Both”.\nMessage animation This message will show information during gameplay (level up, bonuses, etc). We want it to be animated - to appear and then fade out. Add an AnimationPlayer to the scene.\nWe’ll make two animations: one to set the initial values, and one to animate the message display. Add the first animation, “init” and click the “Autoplay on Load” button. Set the length to 0.1.\nAdd a keyframe at time 0 for the Font/Size (64), and one for the Visible set to “Off”.\nAdd the second animation, “show_message”. Set its length to 0.75 and keyframe Visibility to “On”.\nNext, we’ll keyframe the Font/Size from 64 at time 0 and 200 at the end. Set the track’s Update Mode to “Continuous”.\nWe also want it to fade out as it grows, so keyframe the Modulate alpha value from 255 to 0.\nHeres’ what the animation settings should look like:\nAnd the animation when it plays:\nHUD Script Now let’s add a script to the scene, with methods to update the displays:\nextends CanvasLayer func show_message(text): $Message.text = text $AnimationPlayer.play(\"show_message\") func hide(): $ScoreBox.hide() func show(): $ScoreBox.show() func update_score(value): $ScoreBox/HBoxContainer/Score.text = str(value) Instance the HUD in the main scene, and add $HUD.hide() to the _ready() and _on_Jumper_died() functions. In new_game() we need to show the hud and display a message:\n$HUD.show() $HUD.show_message(\"Go!\") To add the score, create a score variable and set it to 0 in new_game(). In _on_Jumper_captured() increment it by one. Make sure to call $HUD.update_score(score) after each of these.\nIn the next part, we’ll add sound and color to the game!\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video? ","description":"","tags":null,"title":"Score and HUD","uri":"/godot_recipes/3.x/games/circle_jump/circle_jump_05/"},{"content":"Problem You want to shoot projectiles from your player/mob/etc..\nSolution Setting up the bullet First, we’ll set up a “bullet” object that we can instance. Here are the nodes we’ll use:\nArea2D: Bullet Sprite CollisionShape2D For the Sprite’s texture, you can use any image you like. Here’s an example one:\nSet up the nodes and configure the sprite and collision shape. If your texture is oriented pointing up, like the one above, make sure to rotate the Sprite node by 90° so that it’s pointing to the right, ensuring it matches the parent’s “forward” direction.\nAdd a script and connect the Area2D’s body_entered signal.\nextends Area2D var speed = 750 func _physics_process(delta): position += transform.x * speed * delta func _on_Bullet_body_entered(body): if body.is_in_group(\"mobs\"): body.queue_free() queue_free() For this example, we’ll remove the bullet if it hits anything at all. We’ll also delete anything tagged in the “mobs” group that it hits.\nShooting We need to set up a spawn location for the bullets. Add a Position2D and place it where you want the bullets to spawn. Here’s an example, placed at the barrel of the gun. I’ve named it “Muzzle”.\nNotice that as the player rotates, the Muzzle’s transform remains oriented the same way relative to the gun. This will be very convenient when spawning the bullets, as they can use the transform to get the proper position and direction. We just set the new bullet’s transform equal to the muzzle’s.\nTip This will work for any character type, not just the “rotate-and-move” style shown here. Just attach the Position2D where you want the bullets to spawn.\nIn the character’s script we add a variable to hold the bullet scene for instancing:\nexport (PackedScene) var Bullet And check for our defined input action:\nif Input.is_action_just_pressed(\"shoot\"): shoot() Now in our shoot() function we can instance a bullet and add it to the tree. A common mistake is to add the bullet as a child of the player:\nfunc shoot(): var b = Bullet.instance() add_child(b) b.transform = $Muzzle.transform The problem here is that since the bullets are children of the player, they are affected when the player moves or rotates.\nTo fix this, we should make sure the bullets are added to the world instead. In this case, we’ll use owner, which refers to the root node of the scene the player is in. Note that we also need to use the muzzle’s global transform, or else the bullet would not be where we expected.\nfunc shoot(): var b = Bullet.instance() owner.add_child(b) b.transform = $Muzzle.global_transform Note Download the project file here: 2d_shooting.zip\nRelated recipes Top-down character Gamedev Math: transforms AI: Homing missiles ","description":"","tags":null,"title":"Shooting projectiles","uri":"/godot_recipes/3.x/2d/2d_shooting/"},{"content":"Problem You want to shoot projectiles from your player/mob/etc..\nSolution For this example, we’ll use the “Mini Tank” that we set up in KinematicBody: Movement.\nSetting up the bullet First, we’ll set up a “bullet” object that we can instance. Here are the nodes we’ll use:\nArea: Bullet MeshInstance CollisionShape For your mesh, you can use one of Godot’s built-in primitive shapes, or something like this:\nNote If you’d like to use the bullet model pictured here, you can grab it from Kenney’s “Weapon Pack”.\nAdd your mesh to the MeshInstance and a scale a collision shape to match.\nWarning Remember to align your MeshInstance with the forward direction (-Z) of the Area node, or your bullet won’t look like it’s flying the right way!\nAdd a script and connect the Area’s body_entered signal.\nextends Area signal exploded export var muzzle_velocity = 25 export var g = Vector3.DOWN * 20 var velocity = Vector3.ZERO func _physics_process(delta): velocity += g * delta look_at(transform.origin + velocity.normalized(), Vector3.UP) transform.origin += velocity * delta func _on_Shell_body_entered(body): emit_signal(\"exploded\", transform.origin) queue_free() We’re using a custom gravity vector, g so that we can control how the shell flies from the tank’s cannon, giving it a nice arc effect. If you’d rather your projectiles move in a straight line, you can remove the line that applies it in _physics_process().\nUsing look_at() each frame turns the bullet to point in its direction of travel.\nWe’ll also emit an exploded signal, which you can connect up to implement explosion and/or damage effects (but that’s for another recipe).\nShooting Now in the tank (or whatever object you have doing the shooting), add a Position3D child at the point where you want the bullets to appear. In the case of our tank, we’re placing it at the end of the cannon barrel:\nNow we can add the code to the tank’s script. First a way to add the bullet scene we’re going to instance:\nexport (PackedScene) var Bullet And in _process() or _unhandled_input() (wherever you’re capturing input), add the code to instance the bullet:\nif Input.is_action_just_pressed(\"shoot\"): var b = Bullet.instance() owner.add_child(b) b.transform = $Cannon/Muzzle.global_transform b.velocity = -b.transform.basis.z * b.muzzle_velocity That’s it - run your scene and try it out:\nNote Download the project file here: 3d_shooting.zip\nRelated recipes KinematicBody: Movement Godot 101: Intro to 3D ","description":"","tags":null,"title":"Shooting projectiles","uri":"/godot_recipes/3.x/3d/3d_shooting/"},{"content":"Problem You’d like to use animated tiles in your TileMap.\nSolution The most straightforward way to approach this problem is to use the AnimatedTexture resource.\nCreating an AnimatedTexture For this example, we’ll use the following water tiles:\nDownload these images: water.zip\nUnzip the images into your project folder. In the Inspector, click the “Create a new resource” button:\nChoose AnimatedTexture and set the Frames property to 5. For each frame, drag the corresponding image to its Texture property.\nYou can adjust the overall animation’s speed with the Fps property, as well as each individual frame’s Delay Sec.\nClick the “Save” button to save the resource. Give it a name such as water_anim.tres.\nUsing AnimatedTexture in a TileMap Now that the AnimatedTexture is saved, it can be used in a TileSet. Open a new or existing TileMap and select its Tile Set property. Click the button to add a new texture to the TileSet:\nSelect the newly added texture and click “New Single Tile”. Draw a box around the texture (use “Enable Snap” to make this easier).\nNow you can select the tile in your TileMap and draw with it just like any other tile.\nYou can download a complete project of this example: animated_tiles.zip\nRelated Recipes TileMap: using autotile ","description":"","tags":null,"title":"TileMap: animated tiles","uri":"/godot_recipes/3.x/2d/tilemap_animation/"},{"content":" Gamedev Math Math is a big part of game development. Some of it you may remember from school, or it may be something you’ve never encountered before. Here you’ll find guides to help you get up to speed and examples of how these concepts are applied to making games.\nIn this section: Interpolation Transforms Noise Vectors: Using Dot and Cross Product ","description":"","tags":null,"title":"Gamedev Math","uri":"/godot_recipes/3.x/math/"},{"content":" Misc Other recipes that just don’t fit in anywhere else.\nIn this section: Autoloads/ Singletons Inheritance ","description":"","tags":null,"title":"Misc","uri":"/godot_recipes/3.x/recipes/"},{"content":" Physics Learn how to use Godot’s physics nodes.\nIn this section: Kinematic Friction KinematicBody: Stopping on Slopes RigidBody2D: Drag and Drop Kinematic to Rigid Body Interaction Using 2D Joints Conveyor Belt ","description":"","tags":null,"title":"Physics","uri":"/godot_recipes/3.x/physics/"},{"content":" AI/Behavior Automated behavior and (sometimes) smarter entities.\nIn this section: Chasing the player Path following Changing behaviors Homing missile Context-based steering ","description":"","tags":null,"title":"AI/Behavior","uri":"/godot_recipes/3.x/ai/"},{"content":"Problem You want an object to “orbit” (move in a circle) around another object.\nSolution This is a common beginner question, and often comes after a bunch of messy experimenting with trig functions. The answer is much simpler:\nPlace the orbiting sprite in a child node of the main sprite (we’re calling it “Pivot”). Give it an offset and rotate the Pivot.\nextends Node2D export var rotation_speed = PI func _process(delta): $Sprite/Pivot.rotation += rotation_speed * delta This works just as well in 3D, too:\nextends Spatial export var rotation_speed = PI func _process(delta): $MeshInstance/Pivot.rotate_y(rotation_speed * delta) ","description":"","tags":null,"title":"Circular movement","uri":"/godot_recipes/3.x/basics/rotation/"},{"content":"Problem You want to make a rolling cube in 3D.\nSolution Rolling a cube is trickier than it seems. You can’t just rotate the cube around its center:\nInstead, the cube needs to be rotated around its bottom edge.\nHere’s the tricky part: which bottom edge? It depends on which direction the cube is rolling.\nIn preparing this recipe, I experimented with a few different solutions to this problem:\nPure math - calculating and applying rotation transforms AnimationPlayer - using animations to key the rotations and offsets Helper nodes - using Spatial(s) as rotation helpers They all worked fine, but I found the last option the most flexible and easiest to adapt, so that’s what we’ll do here.\nNode setup Cube: KinematicBody Pivot: Spatial Mesh: MeshInstance Collision: CollisionShape Tween: Tween Tip You can do this with RigidBody, KinematicBody, or Area as your collision node. There will be minor differences in how you handle movement. Which node you choose should depend on what other behavior you want in your game. For this recipe, we’re only concerned with the movement.\nBy default, everything will be centered at (0, 0, 0) so the first thing we’re going to do is offset everything so that the bottom center of the cube is the KinematicBody’s position.\nTo do this, move the mesh and collision nodes up to (0, 1, 0), leaving the rest where they are. Now when you select the root node, its position will be the bottom of the cube:\nNow when you want to roll the cube, you’ll need to move the Pivot one unit in the direction you want to move. Since the mesh is attached, move it the opposite amount. For example, to roll to the right (+X), you’ll end up with this:\nNow the pivot node is at the correct edge and rotating it will also rotate the mesh.\nMovement script The movement is broken in to 3 steps:\nStep 1 Here we apply the two offsets shown above: shift the Pivot in the direction of movement, and shift the Mesh in the opposite direction.\nStep 2 In this step we animate the rotation. We find the axis of rotation using the cross product of the direction and the down vector. Then we use the Tween to animate rotating the pivot’s basis. We use yield() to wait for the animation to finish.\nStep 3 Finally, we need to reset everything so that it’s ready to happen again. In the end, we want to have the cube moved 2 units in the chosen direction (for a cube of size 2) and the pivot and mesh back at their original positions.\nextends KinematicBody export var speed = 4.0 onready var pivot = $Pivot onready var mesh = $Pivot/MeshInstance onready var tween = $Tween func _physics_process(_delta): var forward = Vector3.FORWARD if Input.is_action_pressed(\"up\"): roll(forward) if Input.is_action_pressed(\"down\"): roll(-forward) if Input.is_action_pressed(\"right\"): roll(forward.cross(Vector3.UP)) if Input.is_action_pressed(\"left\"): roll(-forward.cross(Vector3.UP)) func roll(dir): # Do nothing if we're currently rolling. if tween.is_active(): return ## Step 1: Offset the pivot pivot.translate(dir) mesh.translate(-dir) ## Step 2: Animate the rotation var axis = dir.cross(Vector3.DOWN) tween.interpolate_property(pivot, \"transform:basis\", null, pivot.transform.basis.rotated(axis, PI/2), 1/speed, Tween.TRANS_QUAD, Tween.EASE_IN) tween.start() yield(tween, \"tween_all_completed\") ## Step3: Finalize movement and reverse the offset transform.origin += dir * 2 pivot.transform = Transform.IDENTITY mesh.transform.origin = Vector3(0, 1, 0) Try it, and you’ll notice there’s one problem:\nThe cube is “squishing” because of the basis interpolation, which is going from 0 to 90 degrees. Since the basis also represents scale, this causes some deformation.\nWe could solve this in 2 ways. First, we could break up the rotation into two separate tweens, each doing 45 degrees. However, I find this tricky when we want to play around with the different tween transitions.\nThe other way is to ensure the scale remains constant. We can do this by connecting the Tween’s tween_step signal, which fires every frame during the tween, and normalizing the scale. The orthonormalized() method does this:\nfunc _on_Tween_tween_step(_object, _key, _elapsed, _value): pivot.transform = pivot.transform.orthonormalized() Note Alternatively, you can call set_disable_scale(true) on the pivot node).\nIf your cube’s texture isn’t symmetrical, you may notice that it’s resetting after every roll. To preserve the rotation of the mesh, add the following:\nIn Step 1\nChange mesh.translate(-dir) to mesh.global_translate(-dir).\nIn Step 3\nAdd two lines to keep the mesh rotation after reset:\n## Step3: Finalize movement and reverse the offset transform.origin += dir * 2 var b = mesh.global_transform.basis ## Save the rotation pivot.transform = Transform.IDENTITY mesh.transform.origin = Vector3(0, 1, 0) mesh.global_transform.basis = b ## Apply the rotation Checking for collisions If you plan to have obstacles in your game, you can check for collisions before moving (similar to any other grid-based movement scheme). Add a raycast check before Step 1 of the move:\n# Cast a ray before moving to check for obstacles var space = get_world().direct_space_state var collision = space.intersect_ray(mesh.global_transform.origin, mesh.global_transform.origin + dir * 2.5, [self]) if collision: return Note You could also use a RayCast node. Just remember to call force_raycast_update() before checking.\nRelated recipes Transforms Like video? ","description":"","tags":null,"title":"Rolling Cube","uri":"/godot_recipes/3.x/3d/rolling_cube/"},{"content":"Problem You want to create a “screen shake” effect.\nSolution The “screen shake” effect is a popular way to add a dynamic feel to your game. When used well, it adds a lot of appeal. When misused, players hate it. Keep this in mind when adding it to your game and use wisely.\nThe effect is quite simple: when an event occurs - an explosion, a heavy object hitting an obstacle, etc. - we want to rapidly displace the camera in small increments for a brief time.\nThere are many ways to implement this effect. For this recipe, we’ll be emulating the technique outlined in the following GDC talk:\nTo summarize, the camera will have a trauma property, measuring how much the camera is shaking. Every time something happens that should shake the camera, we’ll add a bit more trauma - a large amount for big events or a little for small ones. Over time, the trauma decreases.\nTrauma We’ll start by implementing the camera. Make a new scene with a Camera2D node, name it ShakeCamera2D, and attach a script.\nFirst, define the parameters that control the shake behavior:\nextends Camera2D export var decay = 0.8 # How quickly the shaking stops [0, 1]. export var max_offset = Vector2(100, 75) # Maximum hor/ver shake in pixels. export var max_roll = 0.1 # Maximum rotation in radians (use sparingly). export (NodePath) var target # Assign the node this camera will follow. var trauma = 0.0 # Current shake strength. var trauma_power = 2 # Trauma exponent. Use [2, 3]. trauma_power is the relationship between trauma and the actual movement of the camera (ie amount = trauma * trauma). A square (2) or cube (3) relationship is typically the best, but feel free to experiment.\nWe’ve also added a target variable so that you can place an instance of this camera anywhere you like and set the target node it will follow.\nfunc _ready(): randomize() func add_trauma(amount): trauma = min(trauma + amount, 1.0) The add_trauma() function is what we call to start or increase shaking. Pass it a value from 0 to 1.\nfunc _process(delta): if target: global_position = get_node(target).global_position if trauma: trauma = max(trauma - decay * delta, 0) shake() In process() we’ll move the camera to track its target. If there is any trauma, we’ll use decay to reduce it and then call shake() to move the camera.\nRandom displacement The shake() function applies a random movement to the camera based on the current trauma level (raised to the given power). In 2D, we have two translational and one rotational movement to calculate. Picking a random number between -1 and 1 is an easy way to get a movement in either direction.\nfunc shake(): var amount = pow(trauma, trauma_power) rotation = max_roll * amount * rand_range(-1, 1) offset.x = max_offset.x * amount * rand_range(-1, 1) offset.y = max_offset.y * amount * rand_range(-1, 1) This looks OK, but we can make it look better.\nUsing noise The drawback with using rand_range() for the movement is that it can change greatly from frame to frame, making for a rather erratic feel. To get a more “smooth” randomness, we can turn to something called noise.\nNoise, or more specifically gradient noise is a method for generating more natural-looking “random” patterns. To do this, Godot provides the OpenSimplexNoise class.\nInfo Probably the most well-known gradient noise algorithm is called Perlin noise. Because it and its successor, simplex noise, are protected by patents, Godot uses an algorithm called OpenSimplex to generate noise.\nOpenSimplexNoise works by generating a 3D “cloud” of points. Each point has a value ranging from -1 to 1. Below are two examples of noise generated by OpenSimplexNoise. In the images, each pixel’s white value is mapped to the noise value at that point.\nAs you can see, while “noisy”, if you pick a particular pixel, adjacent pixels may vary unpredictably, but won’t suddenly swing wildly from one extreme to another. The behavior can be adjusted to suit your needs, but we won’t go into the details of configuring OpenSimplexNoise here. See the related recipes section below for links to more information.\nAdd the following code at the top of the script:\nonready var noise = OpenSimplexNoise.new() var noise_y = 0 func _ready(): randomize() noise.seed = randi() noise.period = 4 noise.octaves = 2 Then, in the shake() function:\nnoise_y += 1 rotation = max_roll * amount * noise.get_noise_2d(noise.seed, noise_y) offset.x = max_offset.x * amount * noise.get_noise_2d(noise.seed*2, noise_y) offset.y = max_offset.y * amount * noise.get_noise_2d(noise.seed*3, noise_y) get_noise_2d() returns the noise value at a given (x, y) coordinate. We don’t want to use the same noise value for all three offsets, so we’re arbitrarily choosing three different (but distant) x values in the noise, and then using the steadily increasing noise_y value to “move” along the gradient at each point.\nNote Download the project file here: screen_shake.zip\nRelated recipes Noise Platform character Like video? ","description":"","tags":null,"title":"Screen Shake","uri":"/godot_recipes/3.x/2d/screen_shake/"},{"content":"Settings singleton First, we’ll add a new script by choosing File -\u003e New Script in the script tab. Name the script settings.gd.\nIn this script we’ll place the configuration settings for the game.\nvar enable_sound = true var enable_music = true var circles_per_level = 5 Add the script as an autoload by opening “Project Settings” and selecting the “Autoloads” tab. Click the folder to load the script and then click “Add”.\nAdding sound To play sounds, we’ll be adding several AudioStreamPlayer nodes to different scenes.\nFirst, add one to the Main scene and name it “Music”. For its Stream property use res://assets/audio/Music_Light-Puzzles.ogg.\nTo the Screens scene, add another called “Click”, which will play when we tap buttons. Use menu_click.wav from the assets folder.\nIn the Circle scene, add an audio player named “Beep” and use the 89.ogg sound file.\nFinally, on the Jumper, we need two sound effects: “Jump” and “Capture”. Use 70.ogg and 88.ogg, respectively.\nNow to play the sounds, we can call their play() methods. Add this to Main.new_game():\nif settings.enable_music: $Music.play() and Main._on_Jumper_died():\nif settings.enable_music: $Music.stop() In Screens.gd add this to _on_button_pressed():\nif settings.enable_sound: $Click.play() On the circle, we want to play the Beep sound when a limited circle completes a full orbit. This is in check_orbits():\ncurrent_orbits -= 1 if settings.enable_sound: $Beep.play() And in Jumper.gd, we add the sounds like so:\nfunc jump(): target.implode() target = null velocity = transform.x * jump_speed if settings.enable_sound: $Jump.play() func _on_Jumper_area_entered(area): target = area velocity = Vector2.ZERO emit_signal(\"captured\", area) if settings.enable_sound: $Capture.play() Run the game and test that you hear all the sounds as expected.\nSound settings Now that we have sound working, we can connect the buttons on the “Settings” screen that can toggle sound and music.\nThe button appearance needs to be changed to match the current on/off state of the property. We’ll load the textures first so that we can assign them as needed:\nvar sound_buttons = {true: preload(\"res://assets/images/buttons/audioOn.png\"), false: preload(\"res://assets/images/buttons/audioOff.png\")} var music_buttons = {true: preload(\"res://assets/images/buttons/musicOn.png\"), false: preload(\"res://assets/images/buttons/musicOff.png\")} Right now, we’re not handling the buttons when they’re pressed. The issue is that we’re currently passing the button’s name, which won’t let us change its texture. Instead, we’re going to refactor register_buttons() to pass a reference to the button itself:\nbutton.connect(\"pressed\", self, \"_on_button_pressed\", [button]) Then we can update _on_button_pressed() like so:\nfunc _on_button_pressed(button): if settings.enable_sound: $Click.play() match button.name: \"Home\": change_screen($TitleScreen) \"Play\": change_screen(null) yield(get_tree().create_timer(0.5), \"timeout\") emit_signal(\"start_game\") \"Settings\": change_screen($SettingsScreen) \"Sound\": settings.enable_sound = !settings.enable_sound button.texture_normal = sound_buttons[settings.enable_sound] \"Music\": settings.enable_music = !settings.enable_music button.texture_normal = music_buttons[settings.enable_music] Color themes We’re also goign to add a way to have different color schemes. These can change in different ways: perhaps as a settings option, or they change as the player gets to higher levels.\nWe’ll store the color scheme data in a dictionary, with the keys being the “name” of the scheme. Each color scheme will also be a dictionary, with the keys denoting the game component that will use that color.\nAdd this to settings.gd:\nvar color_schemes = { \"NEON1\": { 'background': Color8(0, 0, 0), 'player_body': Color8(203, 255, 0), 'player_trail': Color8(204, 0, 255), 'circle_fill': Color8(255, 0, 110), 'circle_static': Color8(0, 255, 102), 'circle_limited': Color8(204, 0, 255) }, \"NEON2\": { 'background': Color8(0, 0, 0), 'player_body': Color8(246, 255, 0), 'player_trail': Color8(255, 255, 255), 'circle_fill': Color8(255, 0, 110), 'circle_static': Color8(151, 255, 48), 'circle_limited': Color8(127, 0, 255) }, \"NEON3\": { 'background': Color8(0, 0, 0), 'player_body': Color8(255, 0, 187), 'player_trail': Color8(255, 148, 0), 'circle_fill': Color8(255, 148, 0), 'circle_static': Color8(170, 255, 0), 'circle_limited': Color8(204, 0, 255) } } var theme = color_schemes[\"NEON1\"] Now on each object, we need to set the colors based on the settings property.\nFor the circle, the color is set using the shader material resource. Because resources are shared, that means that changing one circle’s color would change them all. Let’s make each circle’s material unique to avoid this:\n$Sprite.material = $Sprite.material.duplicate() $SpriteEffect.material = $Sprite.material The color of the circle is determined by what mode it’s using, so set_mode() is where we’ll choose the color:\nfunc set_mode(_mode): mode = _mode var color match mode: MODES.STATIC: $Label.hide() color = settings.theme[\"circle_static\"] MODES.LIMITED: current_orbits = num_orbits $Label.text = str(current_orbits) $Label.show() color = settings.theme[\"circle_limited\"] $Sprite.material.set_shader_param(\"color\", color) Then in the _draw() function where we’re filling in the limited circle, replace the red color with settings.theme[\"circle_fill\"].\nFor the player, set the color in its _ready():\nfunc _ready(): $Sprite.material.set_shader_param(\"color\", settings.theme[\"player_body\"]) $Trail/Points.default_color = settings.theme[\"player_trail\"] In the next part, we’ll add a movement to the circles.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video? ","description":"","tags":null,"title":"Sound and Colors","uri":"/godot_recipes/3.x/games/circle_jump/circle_jump_06/"},{"content":"Earlier, we saw how to design a 3D environment using imported models. But what if you want to make something like a room, with walls, doors, ramps, and other features, but you don’t have any models handy? CSG to the rescue!\nWhat is CSG? CSG stands for Constructive Solid Geometry. It allows you to combine primitive shapes to build complex geometry. Shapes can be combined with boolean operations such as Union, Intersection, and Subtraction.\nCSG is a great tool for prototyping environments and game objects. Later in this tutorial, we’ll use it to make a small FPS-style level with some ramps, walls and platforms.\nBefore we do that, let’s get introduced to how the CSG nodes work.\nCSG Basics Create a new scene with a Spatial root, then add a child node and type “CSG” in the search box.\nThese are the available CSG shapes. Choose a CSGBox to start. You’ll see a plain cube mesh with the following properties:\nThe Operation property is the one that determines how CSG shapes will be combined. The options are:\nUnion - The shapes will be merged, removing any “inside” geometry. Intersection - Only the intersecting (overlapping) geometry will be kept. Subtraction - The second shape is “cut out” of the first. CSG operations are performed on a shape by adding children. Add a child CSGCylinder to the CSGBox. Drag the top size handle (orange dot) to make it a bit taller. You can also increase the Sides property to make it look more circular (here it’s set to 20):\nBy default, the shape’s operation is set to “Union”. The cylinder shape is being “added” to the cube. Try changing it to “Intersection”:\nAnd “Subtraction”:\nHopefully you’re already seeing the possibilities of creating complex shapes through these 3 operations.\nCSGCombiner This node is an “empty” shape. It’s used to organize your shapes. Children of a CSGCombiner will be combined following the same rules as above.\nBuilding a Room Now we’re going to make something useful: a large room with some obstacles and features that our character can interact with, and that we can use in the upcoming tutorials. Make a new scene with a Spatial root that we can start working with.\nStart with a CSGBox, and set its Width and Depth to 20 and its Height to 5. We need this to be a box that we go inside, so click the Invert Faces property as well. This reverses the shape so that the solid walls are on the inside rather than the outside. Also check the Use Collision property, so that the physics engine will treat this shape as a static body object.\nAdd an instance of the player character and test that you can walk around in your new room.\nTip You may remember that in the last part we added code to capture/release the mouse. You’ll need to copy that code over to this scene as well.\nAdding features Now let’s add some features - some internal walls, a ledge running around the edge with a ramp, and so on. Feel free to get creative and add your own ideas. Here are a few to get started:\nTip If you use a CSGCombiner for each of these objects it will be easier to organize and duplicate them. Make sure to enable Use Collision on it.\nWall with door Add a CSGBox and set its Width to 0.5 and its Height to 5 (the same height as the original room). Make the depth about half the size of the room. You can enable snapping here to make it easier to align.\nAdd another CSGBox as a child and set it to “Subtract”. Size it to resemble a door. You can also use a cylinder shape to get an arched portal.\nRamp For the ramp, we’ll use a CSGPolygon. This CSG shape lets you extrude a given polygon to a desired depth. The default shape is a square, but you can add or remove points. For a ramp, we want 3 points.\nAfter adding the CSGPolygon, you can click the Polygon property to adjust its number of points. After that, you can drag the three points to whatever location you like. To ensure everything lines up, you can type the coordinates into the Inspector:\nIn this picture, we’ve created a ramp and added a couple of CSGBox shapes to make the ledge.\nPutting it together Make sure to add a Material to your shapes, choosing an Albedo color that seems pleasant to you. In the following examples, we’ve picked a tan color.\nHere’s an example of a possible room setup:\nHit play and you should be able to walk around the rooms:\nThe area is featureless right now, but to make things more visually interesting, you can add individual lights in each room (more about lighting in a later tutorial). Here’s an example of adding some OmniLight and SpotLight nodes to the scene:\nWrapping Up CSG is a powerful tool for building objects directly in Godot without having to move to another modeling application such as Blender. It can be helpful if you need to mock up a test level for your game, or for the final environment. Keep in mind that as the CSG tree becomes more complex, it can incur a performance penalty. Try to use CSGCombiner to separate your scene into separate CSG trees to minimize this.\nIn the next part, we’ll look at a popular style of 3D game: first person.\nYou can also find a video version of this lesson here: ","description":"","tags":null,"title":"Using CSG","uri":"/godot_recipes/3.x/g101/3d/101_3d_06/"},{"content":" Shaders Deep voodoo. Cool effects.\nIn this section: Shaders: intro Interacting with Shaders Greyscale (monochrome) shader Blur shader ","description":"","tags":null,"title":"Shaders","uri":"/godot_recipes/3.x/shaders/"},{"content":"Problem When moving with WASD-style controls in 3D, it’s easy to get disoriented if the camera rotates. Whose forward counts - the player’s (ie the camera’s) or the object in the game world?\nSolution While this situation can apply to many possible scenarios, we’ll use the Rolling Cube recipe as our example.\nIn the script for the cube, we have the following code for movement:\nfunc _physics_process(_delta): var forward = Vector3.FORWARD if Input.is_action_pressed(\"up\"): roll(forward) if Input.is_action_pressed(\"down\"): roll(-forward) if Input.is_action_pressed(\"right\"): roll(forward.cross(Vector3.UP)) if Input.is_action_pressed(\"left\"): roll(-forward.cross(Vector3.UP)) As you can see, this uses global direction vectors, so if the camera rotates, “up” will no longer appear to be moving forward in the camera view. If we rotate the camera 180°, everything will be reversed!\nWe could just change to use the camera’s forward vector:\nvar forward = -camera.transform.basis.z.normalized() For some setups this might be fine. However, it really doesn’t work for the cube:\nThe cube needs to only move in the 4 cardinal directions. This means we need to take the camera’s forward vector and find which of the axes (+X, -X, +Z, or -Z) it’s closest to.\nWe can find this using the Vector3.max_axis() function. This returns which of the vector’s components is the largest. Since they can be positive or negative, we’ll use abs() first.\nOnce we have the axis with the largest magnitude, we can set our forward vector to match:\nfunc _physics_process(_delta): var forward = Vector3.FORWARD if camera: forward = Vector3.ZERO var cam_forward = -camera.transform.basis.z.normalized() var cam_axis = cam_forward.abs().max_axis() forward[cam_axis] = sign(cam_forward[cam_axis]) if Input.is_action_pressed(\"up\"): roll(forward) if Input.is_action_pressed(\"down\"): roll(-forward) if Input.is_action_pressed(\"right\"): roll(forward.cross(Vector3.UP)) if Input.is_action_pressed(\"left\"): roll(-forward.cross(Vector3.UP)) In this clip, I’m only pressing “w” to move:\nRelated recipes Rolling Cube Camera Gimbal Like video? ","description":"","tags":null,"title":"Align Movement with Camera","uri":"/godot_recipes/3.x/3d/move_with_camera/"},{"content":" Audio Helpful recipes for adding sound effects and music to your game.\nIn this section: Audio Manager ","description":"","tags":null,"title":"Audio","uri":"/godot_recipes/3.x/audio/"},{"content":"In this installment, we’ll look at how to make a first-person character. We’ll use the CSG-based level we designed in the previous part as a place to walk around and test our movement.\nCharacter Scene In an FPS or similar game, we want to give the player the illusion that they’re looking out of the character’s eyes. One nice aspect of this is that we don’t really need a model, at least to get started.\nStart with a KinematicBody. To this we’ll add two CollisionShape nodes (“Body” and “Feet”). We also want to have a Camera, but we need to be careful about how we handle rotation. The character should rotate in Y, but only the camera should rotate in X (for looking up and down). To make this work, add a Spatial node, which we’ll call “Pivot”, and add the Camera to that.\nThe “Body” collision shape is going to represent the player’s body. We can use a CapsuleShape (rotated 90 degrees around X). Set its Radius to 0.5 and Height to 1.\nOne issue with using a CapsuleShape is that the bottom is rounded. This is good for moving over small bumps in a natural way, but it also means that when standing on the edge of a surface, the player will “roll” off in a strange way. We can prevent this by using a BoxShape for the “Feet” collision. Make its extents (.4, .1, .4) and place it so that its bottom is just above the bottom of the capsule. We’ll still have the round bottom to move over things, but the box will keep us from sliding off ledges.\nMove the Pivot up a bit, so that it’s not pointing the camera out of the “middle” of the body.\nMoving around Much of the code for movement is the same as we used for the third-person character earlier in this series. We’ll start with declaring our variables:\nextends KinematicBody onready var camera = $Pivot/Camera var gravity = -30 var max_speed = 8 var mouse_sensitivity = 0.002 # radians/pixel var velocity = Vector3() Note The value of mouse_sensitivity maps the movement of the mouse, which is in pixels, to rotation, in degrees. So for each pixel the mouse moves, we’ll rotate by 0.002 radians (or about 0.1 degrees).\nfunc get_input(): var input_dir = Vector3() # desired move in camera direction if Input.is_action_pressed(\"move_forward\"): input_dir += -global_transform.basis.z if Input.is_action_pressed(\"move_back\"): input_dir += global_transform.basis.z if Input.is_action_pressed(\"strafe_left\"): input_dir += -global_transform.basis.x if Input.is_action_pressed(\"strafe_right\"): input_dir += global_transform.basis.x input_dir = input_dir.normalized() return input_dir When detecting input, we want to move in the direction the body is facing.\nNext, we add up the inputs and return the resulting direction vector.\nfunc _unhandled_input(event): if event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED: rotate_y(-event.relative.x * mouse_sensitivity) $Pivot.rotate_x(-event.relative.y * mouse_sensitivity) $Pivot.rotation.x = clamp($Pivot.rotation.x, -1.2, 1.2) We also need to capture mouse movement for camera rotation. As discussed above, horizontal mouse movement rotates the entire body in Y, while vertical motion rotates the helper node in X.\nWe also need to limit that vertical rotation to prevent the camera from flipping upside-down.\nfunc _physics_process(delta): velocity.y += gravity * delta var desired_velocity = get_input() * max_speed velocity.x = desired_velocity.x velocity.z = desired_velocity.z velocity = move_and_slide(velocity, Vector3.UP, true) In _physics_process() we get the desired_velocity, the direction vector returned by get_input(), and multiply it by max_speed to set its length. We don’t want to alter our velocity.y because that’s set by gravity, so we only set the x and z components based on the input.\nWe’re also setting true for the stop_on_slope parameter of move_and_slide(). This keeps us from sliding down the ramp if we stand on it.\nTest your movement and ensure everything is working as expected.\nAdding a weapon First person characters typically have some sort of item, or at least empty hands, visible in front of them. We’re going to use the shotgun model from the following art pack:\nKenney Weapon Pack\nAddd a MeshInstance to the Pivot node and use the shotgun.obj model from the art pack. You’ll notice that the model is too small for our player’s scale, so set Scale to (8, 8, 8).\nWe need to position the model so that it’s projecting out “through” the camera. Aligning it can be difficult, so click the “View” menu and choose “2 Viewports”. In the bottom one, select the Camera and click “Preview”, and in the top you can move the gun until it looks right.\nWrapping up We now have a basic first-person character controller. This could make a good foundation for a wide variety of game types by adding features and behaviors, as we’ll see in later lessons.\nYou can also find a video version of this lesson here: ","description":"","tags":null,"title":"First-person Character","uri":"/godot_recipes/3.x/g101/3d/101_3d_07/"},{"content":"Problem You want to click-and-drag to select multiple units, RTS style.\nSolution Realtime strategy (RTS) games often require giving orders to many units at once. A typical style of selecting multiple units is to click-and-drag a box around them. Once the units are selected, clicking on the map commands them to move.\nHere’s an example of what we’re going for:\nUnit setup To test this out, we’ll need some basic RTS-style units. They are set up to move towards a target and to avoid running into each other. We won’t go into too much detail on them in this tutorial. The unit script is commented if you’d like to use it as a base for creating your own RTS units. See below for a link to download the project.\nWorld setup Processing the unit selection will happen in the world. We’ll start with a Node2D called “World” and add a few unit instances in it. Attach a script to the World node and add the following variables:\nextends Node2D var dragging = false # Are we currently dragging? var selected = [] # Array of selected units. var drag_start = Vector2.ZERO # Location where drag began. var select_rect = RectangleShape2D.new() # Collision shape for drag box. Note that once we’ve drawn the box, we’ll need a way to find what units are inside it. The RectangleShape2D will allow us to query the physics engine and see what we collided with.\nDrawing the box We’ll be using the left mouse button for this. Clicking starts a drag and then letting go ends it. During dragging, we’ll draw the rectangle for visibility.\nfunc _unhandled_input(event): if event is InputEventMouseButton and event.button_index == BUTTON_LEFT: if event.pressed: # We only want to start a drag if there's no selection. if selected.size() == 0: dragging = true drag_start = event.position elif dragging: # Button released while dragging. dragging = false if event is InputEventMouseMotion and dragging: update() func _draw(): if dragging: draw_rect(Rect2(drag_start, get_global_mouse_position() - drag_start), Color(.5, .5, .5), false) Selecting the units Now that we’ve got a selection box, we need to find the units that are inside it. When we release the button and the drag ends, we must query the physics space to find the units. Note that the units are KinematicBody2D, but Area2D or other bodies would work as well.\nWe’ll use Physics2DDirectSpaceState.intersect_shape() to find the units. This requires a shape (our rectangle) and a transform (our location). See Godot docs for details.\nelif dragging: dragging = false update() var drag_end = event.position select_rect.extents = (drag_end - drag_start) / 2 We start by recording the location when we released the button, and use that to set the RectangleShape2D’s extents (remember: extents are measured from the rectangle’s center, so they’re half the full width/height).\nvar space = get_world_2d().direct_space_state var query = Physics2DShapeQueryParameters.new() query.set_shape(select_rect) query.transform = Transform2D(0, (drag_end + drag_start) / 2) selected = space.intersect_shape(query) Now we must get a reference to the physics state and set up our shape query using Physics2DShapeQueryParameters, assigning it our shape, and using the center of the dragged area as the origin for the query’s transform. Our result after calling intersect_shape() is an array of dictionaries, which looks like this:\n[{collider:[KinematicBody2D:1149], collider_id:1149, metadata:Null, rid:[RID], shape:0}, {collider:[KinematicBody2D:1144], collider_id:1144, metadata:Null, rid:[RID], shape:0}, {collider:[KinematicBody2D:1154], collider_id:1154, metadata:Null, rid:[RID], shape:0}, {collider:[KinematicBody2D:1159], collider_id:1159, metadata:Null, rid:[RID], shape:0}] Each of those collider items is a reference to a unit, so we can use this to notify them that they’ve been selected, activating the outline shader:\nfor item in selected: item.collider.selected = true Commanding the units Finally, we can command the selected units to move by clicking somewhere on the screen:\nfunc _unhandled_input(event): if event is InputEventMouseButton and event.button_index == BUTTON_LEFT: if event.pressed: if selected.size() == 0: dragging = true drag_start = event.position else: for item in selected: item.collider.target = event.position item.collider.selected = false selected = [] The else clause here triggers if we click the mouse when selected is greater than 0. Each item’s target is set, and we make sure to deselect the units so we can start again.\nWrapping up This technique can be expanded to a wide range of RTS or other game styles. Download the full project below and use it as a base for your own game.\nNote Download the project file here: rts_movement.zip\nRelated recipes Mouse Input Inputs: Introduction Like video? ","description":"","tags":null,"title":"Mouse: Drag-select multiple units","uri":"/godot_recipes/3.x/input/multi_unit_select/"},{"content":"Fixing a bug Our first task is to fix a bug with our menu system. Pressing the “Start” button launches a new game, but as the screen is moving off, it can be pressed again. Try “spamming” the start button - disaster ensues!\nWe can fix this by disabling the buttons while the screen transition is happening. Since we put all the buttons in a “buttons” group, we can easily do this with call_group().\nHere’s the updated BaseScreen.gd:\nextends CanvasLayer onready var tween = $Tween func appear(): get_tree().call_group(\"buttons\", \"set_disabled\", false) tween.interpolate_property(self, \"offset:x\", 500, 0, 0.5, Tween.TRANS_BACK, Tween.EASE_IN_OUT) tween.start() func disappear(): get_tree().call_group(\"buttons\", \"set_disabled\", true) tween.interpolate_property(self, \"offset:x\", 0, 500, 0.5, Tween.TRANS_BACK, Tween.EASE_IN_OUT) tween.start() Score and level As our score increases, we’ll want the game’s difficulty to increase as well. This means that when we get points, we’ll need to check if we’ve passed a certain threshold (circles_per_level). We may also have other things that give us points besides jumping on a circle. To make this easier to handle, we’ll give our score variable a setget method in the main script:\nvar score = 0 setget set_score var level = 0 And update the new_game() to use that method:\nfunc new_game(): self.score = 0 level = 1 Do the same with the score change in _on_Jumper_captured(), and we’ll move the HUD update into our new set_score() method:\nfunc _on_Jumper_captured(object): $Camera2D.position = object.position object.capture(player) call_deferred(\"spawn_circle\") self.score += 1 func set_score(value): score = value $HUD.update_score(score) if score \u003e 0 and score % settings.circles_per_level == 0: level += 1 $HUD.show_message(\"Level %s\" % str(level)) Try the game and you should see a “Level 2” message on the screen when you reach five points.\nMoving circles Part of the level progression is going to be increased difficulty. One way we’ll do that is by making some circles move. We already have multiple circle types (static and limited), but either of those should be capable of moving, so this won’t be a new circle type. Instead, it will be a property that any circle can have.\nOpen up the Circle scene and add a Tween node called “MoveTween”. Add this to the top of the circle script:\nonready var move_tween = $MoveTween var move_range = 100 # Distance the circle moves. var move_speed = 1.0 # The circle's movement speed. If move_range is 0, we’ll have a non-moving circle. We’ll make the default 100 here so that we can test it out.\nTo handle the movement, we’ll start the MoveTween. When it ends, we’ll start it again in the opposite direction, using the tween_completed signal.\nThis is the code to start the movement. Connect the tween_completed signal to this function:\nfunc set_tween(object=null, key=null): if move_range == 0: return move_range *= -1 move_tween.interpolate_property(self, \"position:x\", position.x, position.x + move_range, move_speed, Tween.TRANS_QUAD, Tween.EASE_IN_OUT) move_tween.start() Finally, we’ll add set_tween() to the end of the init() function and we can try it out.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video? ","description":"","tags":null,"title":"Moving circles","uri":"/godot_recipes/3.x/games/circle_jump/circle_jump_07/"},{"content":"Problem You want to make an airplane controller in 3D, but don’t need a fully accurate flight-simulator.\nSolution In this recipe, we’re going to make a simplified airplane controller. By “simplified” we mean stripping things down to the basics. We’re looking for the “feel” of flying a plane - one that you can just jump in and start flying effortlessly, with a minimal control scheme.\nNote This recipe is not an accurate flight simulator. We are not simulating aerodynamics, so this doesn’t fly like a real airplane. We’re going for simplicity and “fun” here, not accuracy.\nNode setup We’re going to use a KinematicBody for this. Since we won’t be simulating actual flight physics (lift, drag, etc.), we don’t need RigidBody in this case.\nHere’s our model setup:\nWe’re using a cylinder for the collision shape, sized to match the plane’s fuselage. This will allow for detecting the ground, which is all we’re concerned with for this demo.\nTo start the script, let’s look at our plane’s properties:\nextends KinematicBody # Can't fly below this speed var min_flight_speed = 10 # Maximum airspeed var max_flight_speed = 30 # Turn rate var turn_speed = 0.75 # Climb/dive rate var pitch_speed = 0.5 # Wings \"autolevel\" speed var level_speed = 3.0 # Throttle change speed var throttle_delta = 30 # Acceleration/deceleration var acceleration = 6.0 # Current speed var forward_speed = 0 # Throttle input speed var target_speed = 0 # Lets us change behavior when grounded var grounded = false var velocity = Vector3.ZERO var turn_input = 0 var pitch_input = 0 Controls We’ll need the following input actions for our controls. We’re using a game controller in this demo, but you can add keyboard inputs as well if you like.\nThis function captures the inputs and sets the input values. Note that increasing/decreasing throttle changes the target_speed, not the actual speed.\nfunc get_input(delta): # Throttle input if Input.is_action_pressed(\"throttle_up\"): target_speed = min(forward_speed + throttle_delta * delta, max_flight_speed) if Input.is_action_pressed(\"throttle_down\"): var limit = 0 if grounded else min_flight_speed target_speed = max(forward_speed - throttle_delta * delta, limit) # Turn (roll/yaw) input turn_input = 0 turn_input -= Input.get_action_strength(\"roll_right\") turn_input += Input.get_action_strength(\"roll_left\") # Pitch (climb/dive) input pitch_input = 0 pitch_input -= Input.get_action_strength(\"pitch_down\") pitch_input += Input.get_action_strength(\"pitch_up\") Movement Movement happens in _physics_process(), first lerping the speed towards the target speed and then using move_and_slide():\nfunc _physics_process(delta): # Accelerate/decelerate forward_speed = lerp(forward_speed, target_speed, acceleration * delta) # Movement is always forward velocity = -transform.basis.z * forward_speed velocity = move_and_slide(velocity, Vector3.UP) To test, add the plane to a test scene (don’t forget a Camera). Press the \"throttle_up\" input and you should see the plane accelerate forward.\nTip We’re using the Interpolated Camera recipe in this demo.\nNext, let’s handle changing the pitch of the plane. Add this right after calling get_input():\ntransform.basis = transform.basis.rotated(transform.basis.x, pitch_input * pitch_speed * delta) Run the scene again and try pitching up and down:\nAfter that, add the following for the turn input:\ntransform.basis = transform.basis.rotated(Vector3.UP, turn_input * turn_speed * delta) Notice that while the plane turns, it doesn’t really look natural. Airplanes bank when they turn, so let’s animate that by changing the rotation of the mesh:\n$Mesh/Body.rotation.y = lerp($Mesh/Body.rotation.y, turn_input, level_speed * delta) The amount of roll is related to the turn_input so a shallow turn banks less. Going straight will “auto” level the plane.\nThat’s it! You now have the basic flying controls working correctly, and it should feel comfortable and natural to fly around. Try adjusting the various properties to see how they affect the movement.\nLanding/taking off While the above is fine for flying, it doesn’t handle the ground very well. Here, we’ll handle the ground using a simplistic approach (by “simplistic”, we mean doing so in a very basic way - you’ll probably want to expand on it depending on what your game may need).\nFirst, we’ll want to distinguish between being on the ground and being in the air. On the ground, we can slow down to 0; in the air, we must maintain the minimum airspeed. Also, when on the ground, we won’t bank when turning (we don’t want our wings digging into the ground!).\nfunc _physics_process(delta): get_input(delta) transform.basis = transform.basis.rotated(transform.basis.x, pitch_input * pitch_speed * delta) transform.basis = transform.basis.rotated(Vector3.UP, turn_input * turn_speed * delta) # If on the ground, don't roll the body if grounded: $Mesh/Body.rotation.y = 0 else: $Mesh/Body.rotation.y = lerp($Mesh/Body.rotation.y, turn_input, level_speed * delta) forward_speed = lerp(forward_speed, target_speed, acceleration * delta) velocity = -transform.basis.z * forward_speed # Handle landing/taking off if is_on_floor(): if not grounded: rotation.x = 0 velocity.y -= 1 grounded = true else: grounded = false velocity = move_and_slide(velocity, Vector3.UP) Note that while grounded, we’re setting velocity.y to keep us “stuck” to the ground. Alternatively, this could be done via move_and_slide_with_snap().\nMeanwhile, in the get_input() function, we’ll also take into account grounded when throttling down and when pitching down, and by only allowing takeoff if above min_flight_speed:\nfunc get_input(delta): if Input.is_action_pressed(\"throttle_up\"): target_speed = min(forward_speed + throttle_delta * delta, max_flight_speed) if Input.is_action_pressed(\"throttle_down\"): var limit = 0 if grounded else min_flight_speed target_speed = max(forward_speed - throttle_delta * delta, limit) turn_input = 0 if forward_speed \u003e 0.5: turn_input -= Input.get_action_strength(\"roll_right\") turn_input += Input.get_action_strength(\"roll_left\") pitch_input = 0 if not grounded: pitch_input -= Input.get_action_strength(\"pitch_down\") if forward_speed \u003e= min_flight_speed: pitch_input += Input.get_action_strength(\"pitch_up\") Full script Here’s the full script:\nClick to expand... extends KinematicBody # Can't fly below this speed var min_flight_speed = 10 # Maximum airspeed var max_flight_speed = 30 # Turn rate var turn_speed = 0.75 # Climb/dive rate var pitch_speed = 0.5 # Wings \"autolevel\" speed var level_speed = 3.0 # Throttle change speed var throttle_delta = 30 # Acceleration/deceleration var acceleration = 6.0 # Current speed var forward_speed = 0 # Throttle input speed var target_speed = 0 # Lets us disable certain things when grounded var grounded = false var velocity = Vector3.ZERO var turn_input = 0 var pitch_input = 0 func _ready(): DebugOverlay.stats.add_property(self, \"grounded\", \"\") DebugOverlay.stats.add_property(self, \"transform:origin:y\", \"round\") DebugOverlay.stats.add_property(self, \"forward_speed\", \"round\") func _physics_process(delta): get_input(delta) # Rotate the transform based on the input values transform.basis = transform.basis.rotated(transform.basis.x, pitch_input * pitch_speed * delta) transform.basis = transform.basis.rotated(Vector3.UP, turn_input * turn_speed * delta) # If on the ground, don't roll the body if grounded: $Mesh/Body.rotation.y = 0 else: # Roll the body based on the turn input $Mesh/Body.rotation.y = lerp($Mesh/Body.rotation.y, turn_input, level_speed * delta) # Accelerate/decelerate forward_speed = lerp(forward_speed, target_speed, acceleration * delta) # Movement is always forward velocity = -transform.basis.z * forward_speed # Handle landing/taking off if is_on_floor(): if not grounded: rotation.x = 0 velocity.y -= 1 grounded = true else: grounded = false velocity = move_and_slide(velocity, Vector3.UP) func get_input(delta): # Throttle input if Input.is_action_pressed(\"throttle_up\"): target_speed = min(forward_speed + throttle_delta * delta, max_flight_speed) if Input.is_action_pressed(\"throttle_down\"): var limit = 0 if grounded else min_flight_speed target_speed = max(forward_speed - throttle_delta * delta, limit) # Turn (roll/yaw) input turn_input = 0 if forward_speed \u003e 0.5: turn_input -= Input.get_action_strength(\"roll_right\") turn_input += Input.get_action_strength(\"roll_left\") # Pitch (climb/dive) input pitch_input = 0 if not grounded: pitch_input -= Input.get_action_strength(\"pitch_down\") if forward_speed \u003e= min_flight_speed: pitch_input += Input.get_action_strength(\"pitch_up\") Wrapping up You can adapt this technique to a variety of arcade-style flying games. For example, for mouse control, you could use the relative property of InputEventMouseMotion to set the pitch and turn input.\nNote Download the project file here: airplane_test.zip\nRelated recipes Interpolated Camera Inputs: Introduction KinematicBody: Movement Like video? ","description":"","tags":null,"title":"Simplified Airplane Controller","uri":"/godot_recipes/3.x/3d/simple_airplane/"},{"content":"Problem You’d like to understand Godot’s Joint2D nodes.\nSolution Joint are used to constrain the movement of attached physics objects. For any joint node, you need to attach two bodies, which must extend from PhysicsObject2D.\nProperties These properties are common to all joint nodes:\nNode A and Node B: The assigned physics bodies. Bias: The rate at which the joint pulls the two bodies back together if they move apart. Defaults to 0. Disable Collisions: Allows the connected bodies to ignore collisions between them. Defaults to true. There are three types of Joint2D. In all of the following examples, there is one RigidBody2D connected via a joint to a StaticBody2D. “Visible Collision Shapes” is enabled in the screen images below so you can see a representation of the joint.\nPinJoint2D The “pin” joint attaches the two bodies at a single point, allowing them to freely rotate.\nThe pin joint’s Softness property gives some “springiness” to the connection. The value can range from 0 (the default) which allows no movement, to 16.\nDampedSpringJoint2D This joint connects the two bodies with a spring-like force.\nThe spring’s behavior can be adjusted with these properties:\nLength: The joint’s maximum length. Rest Length:The joint’s length when no forces or movement are applied. Stiffness: The spring’s “stretchiness”, i.e. how much it resists forces pulling against it. Damping: How quickly the spring stops “bouncing”. GrooveJoint2D This joint constrains the attached bodies to move linearly.\nBy default, the groove runs vertically, but you can change this by rotating the groove node.\nThese properties control the groove’s behavior:\nLength: The groove’s length. The attached bodies can’t move past this maximum distance. Initial Offset: Starting “position” along the groove. You can download an example project to play with these joints here: physics_joints.zip\nRelated Recipes ","description":"","tags":null,"title":"Using 2D Joints","uri":"/godot_recipes/3.x/physics/joints_2d/"},{"content":" Exporting Building and exporting your project for PC, web, or mobile.\nIn this section: ","description":"","tags":null,"title":"Exporting","uri":"/godot_recipes/3.x/export/"},{"content":"Problem You want to make a 3D spaceship that flies in an arcade/cinematic way. You’re not looking for realistic physics, but more of a dog-fighting, “Star Wars”-style of spaceflight.\nSolution To accomplish this, we’ll use a KinematicBody for the ship. The three axis inputs (pitch, roll, and yaw) will rotate the body’s basis around the corresponding axis. The direction of motion will always point forward.\nNote You can do this with RigidBody and get the same results. See the example project linked below, which includes a rigid body version as well.\nAssets Spaceship models are from this asset pack:\nUltimate Spaceships Pack by Quaternius\nI’ve chosen the “Executioner” ship model:\nFeel free to choose your favorite design.\nSetup Select the gltf file of the ship you want, and click the Import tab. Change the Root Type to KinematicBody and click “Reimport”. Then double-click the gltf and you’ll have a new inherited scene with a KinematicBody root and a MeshInstance child. Add a CollisionShape to the body.\nIn Project Settings -\u003e Input Map, set up the following inputs:\nroll_right / roll_left pitch_up / pitch_down yaw_right / yaw_left throttle_up / throttle_down You can assign keys or controller inputs. Analog stick inputs will work best.\nMovement To start the script, let’s handle the forward movement. Pressing the throttle buttons smoothly increases/decreases the speed.\nextends KinematicBody export var max_speed = 50 export var acceleration = 0.6 var velocity = Vector3.ZERO var forward_speed = 0 func get_input(delta): if Input.is_action_pressed(\"throttle_up\"): forward_speed = lerp(forward_speed, max_speed, acceleration * delta) if Input.is_action_pressed(\"throttle_down\"): forward_speed = lerp(forward_speed, 0, acceleration * delta) func _physics_process(delta): get_input(delta) velocity = -transform.basis.z * forward_speed move_and_collide(velocity * delta) Make a test scene with a Camera to try it out. You can use a stationary camera or a chase camera. Check that the ship accelerates and slows before moving on to the next step.\nRotation Now we can handle rotation in the three axes. Add the following variables at the top of the script:\nexport var pitch_speed = 1.5 export var roll_speed = 1.9 export var yaw_speed = 1.25 var pitch_input = 0 var roll_input = 0 var yaw_input = 0 The three axis speeds will affect the “handling” of the ship. Experiment to find values the work for you and your desired flight style.\nNext, add these lines to get_input() to capture the three axis inputs:\npitch_input = Input.get_action_strength(\"pitch_up\") - Input.get_action_strength(\"pitch_down\") roll_input = Input.get_action_strength(\"roll_left\") - Input.get_action_strength(\"roll_right\") yaw_input = Input.get_action_strength(\"yaw_left\") - Input.get_action_strength(\"yaw_right\") Finally, we need to rotate the ship’s Basis according to the inputs. Note how each input affects one axis of rotation:\ntransform.basis = transform.basis.rotated(transform.basis.z, roll_input * roll_speed * delta) transform.basis = transform.basis.rotated(transform.basis.x, pitch_input * pitch_speed * delta) transform.basis = transform.basis.rotated(transform.basis.y, yaw_input * yaw_speed * delta) transform.basis = transform.basis.orthonormalized() Improvements Currently the rotations are a little to “sharp”. The ship starts and stops rotating instantly, which feels a bit too unnatural. We can solve this with lerp(), and by adding one more configuration variable to set how “floaty” we’d like the controls to be:\nexport var input_response = 8.0 Change the three axis inputs in get_input() to the following:\npitch_input = lerp(pitch_input, Input.get_action_strength(\"pitch_up\") - Input.get_action_strength(\"pitch_down\"), input_response * delta) roll_input = lerp(roll_input, Input.get_action_strength(\"roll_left\") - Input.get_action_strength(\"roll_right\"), input_response * delta) yaw_input = lerp(yaw_input, Input.get_action_strength(\"yaw_left\") - Input.get_action_strength(\"yaw_right\"), input_response * delta) Now when stopping or changing direction, there’s a little bit of inertia.\nLinking roll/yaw One problem with this control scheme is that it’s awkward. Having to use a separate stick for the yaw input makes it difficult to control, especially when also shooting and using other controls. Many games solve this by linking the roll input to also apply a small amount of yaw. To do this, change the yaw_speed to around 1/4 to 1/2 of the roll_speed.\nIn the get_input() function, change the line getting yaw_input to the following:\nyaw_input = roll_input This is another fun place to experiment by changing the roll and yaw speeds. For example, what if yaw was primary and roll smaller? What if other axes were linked? If your game has different ships, you can give them different values for variety in flight styles/performance.\nWrapping up That’s it, now you can fly! This controller is a great start for whatever space-based game you might have in mind. Add some other ships, and a few effects, and you’re ready go:\nFull script Here’s the complete script:\nextends KinematicBody export var max_speed = 50 export var acceleration = 0.6 export var pitch_speed = 1.5 export var roll_speed = 1.9 export var yaw_speed = 1.25 # Set lower for linked roll/yaw export var input_response = 8.0 var velocity = Vector3.ZERO var forward_speed = 0 var pitch_input = 0 var roll_input = 0 var yaw_input = 0 func get_input(delta): if Input.is_action_pressed(\"throttle_up\"): forward_speed = lerp(forward_speed, max_speed, acceleration * delta) if Input.is_action_pressed(\"throttle_down\"): forward_speed = lerp(forward_speed, 0, acceleration * delta) pitch_input = lerp(pitch_input, Input.get_action_strength(\"pitch_up\") - Input.get_action_strength(\"pitch_down\"), input_response * delta) roll_input = lerp(roll_input, Input.get_action_strength(\"roll_left\") - Input.get_action_strength(\"roll_right\"), input_response * delta) yaw_input = lerp(yaw_input, Input.get_action_strength(\"yaw_left\") - Input.get_action_strength(\"yaw_right\"), input_response * delta) # replace the line above with this for linked roll/yaw: # yaw_input = roll_input func _physics_process(delta): get_input(delta) transform.basis = transform.basis.rotated(transform.basis.z, roll_input * roll_speed * delta) transform.basis = transform.basis.rotated(transform.basis.x, pitch_input * pitch_speed * delta) transform.basis = transform.basis.rotated(transform.basis.y, yaw_input * yaw_speed * delta) transform.basis = transform.basis.orthonormalized() velocity = -transform.basis.z * forward_speed move_and_collide(velocity * delta) Note Download the project file here: https://github.com/kidscancode/3d_spaceship_demo\nRelated recipes Input Actions Interpolated Camera Like video? ","description":"","tags":[],"title":"Arcade-style Spaceship","uri":"/godot_recipes/3.x/3d/spaceship/"},{"content":"Problem You want to make a conveyor belt object that will move bodies (kinematic or rigid).\nSolution You can make a conveyor belt object using nothing but a StaticBody2D by using its constant_linear_velocity property.\nNote See below for how to address this in 3D.\nHere’s an example, using a StaticBody2D and a RigidBody2D. No code was added. The static body’s Constant Linear Velocity is set to (200, 0).\nAnimating the belt There are many ways to present the appearance of your conveyor belt, depending on your art assets. For this demo project, I have only a TileMap which is using this single 88x88 tile:\nAdd a Sprite to your static body, and in its Texture choose “New AtlasTexture”:\nDrop the tile texture in its Texture property and set the Region to (0, 0, 880, 88):\nChoosing 880 gives us a conveyor belt that’s exactly 10 tiles wide. You can use any width you need.\nTip If your image doesn’t repeat or looks wrong, reimport it with the Repeat flag set to “Enabled”.\nTry adjusting the x of the Region property. You’ll see the tiles shift. This is what we need to animate the belt. You can do this with an AnimationPlayer or in code. We’ll do the latter for this example:\nextends StaticBody2D export var speed = 100 func _ready(): constant_linear_velocity.x = speed func _process(delta): $Sprite.texture.region.position.x -= speed * delta This code ensures that our belt moves at the desired speed, and that the animation matches the physics effect. Note that the directions are opposite: increasing the x of the region shifts the image to the left.\nThis works perfectly well with kinematic bodies, too. Here’s the same conveyor belt object added to our Platform character recipe:\n3D At the time of this writing, constant_linear_velocity does not work in 3D using StaticBody.\nHowever, you can use this technique if you change from “Bullet” to the “GodotPhysics” engine in your Project Settings:\nRelated recipes Platform character Using KinematicBody2D Moving Platforms ","description":"","tags":null,"title":"Conveyor Belt","uri":"/godot_recipes/3.x/physics/conveyor_belt/"},{"content":"Problem You need an AI-controlled object in your game that can follow a path, avoid obstacles, and make other decisions about how to move around the world.\nSolution “Steering behavior” is the blanket term for a variety of algorithms that you can use to solve this problem. Which one you choose will depend on your game, the type of world the object lives in, and what type of “intelligence” you want it to have.\nIn this example, we’re going to use a method called “Context Behavior”, which aims to give the object enough information about the world to make a choice of how to move. For additional reading on this subject, see the following links:\nAndrew Fray: Context Behaviours Know How to Share\nJames Keats: AI Context Behaviors\nFor this demo, we’ll use a generic “Agent” object. In your game, this might be a car driving around a track, a monster patrolling a dungeon, or some other kind of game entity. Our agent will use a KinematicBody2D, but remember, you can use this technique with any kind of object - the algorithm is about the entity choosing a direction to move, how it moves is entirely separate.\nThe Algorithm To begin, let’s imagine our agent has a number of rays extending in all directions (we’ll talk about how many to use later - for now let’s use 8).\nIn our agent’s script, we’ll store an array called interest, tracking in which directions the agent wants to go.\nOf course, if they’re all the same, then it can’t move - it wants to go in all directions equally! So lets consider that it has a preference - it mostly wants to go forward:\nIn this case, the interest array would look like this:\nThe strongest desire is to go forward, but forward-left and forward-right are acceptible as well. But what if an obstacle appears?\nNow we’ll introduce a second array, danger, that indicates directions that are not preferred.\nCombining these two arrays, we can eliminate any interest directions that are also contained in danger. By summing up the remaining interest directions, we’re left with a new direction pointing away from the obstacle.\nTo summarize:\nFind the object’s interest directions. Find the directions that contain danger. Eliminate any interest directions that are dangerous. Sum the remaining interest directions to find the new heading. Finding Interest This will vary depending on what your agent’s goal is. If it’s to chase the player, then the interest values should be high in the direction of the player. You can even have multiple targets: closer goals have higher interest, but if an obstacle cancels them out, the lower scoring goals will win.\nFor this demo, we’re going to imagine we’re making a racing game of some kind. The AI-controlled cars need to make it around the track: their interest array should be pointing forward along the track, so they don’t start going backwards.\nThere are a few ways to do this, and in order to keep our agents from needing to know the implementation details, we’ll have the track tell them which way to go based on their position. At any time if you ask the track which way is correct, it will tell you.\nThe Code Here’s the code for our agent. We start with the exported values: movement parameters and other values we want to be able to adjust easily. look_ahead, for example, is how far ahead the danger rays will detect obstacles.\nNote that we’ve made the num_rays adjustable, so that you can find the number that works best for your situation. We’ll talk below about the tradeoffs and benefits of larger numbers of rays.\nextends KinematicBody2D export var max_speed = 350 export var steer_force = 0.1 export var look_ahead = 100 export var num_rays = 8 # context array var ray_directions = [] var interest = [] var danger = [] var chosen_dir = Vector2.ZERO var velocity = Vector2.ZERO var acceleration = Vector2.ZERO Next, we have _ready() where we size the arrays properly and populate the ray_directions array with the actual ray vectors, distributing them evenly around the circle based on num_rays. We begin with no rotation, so Vector2.RIGHT is forward.\nfunc _ready(): interest.resize(num_rays) danger.resize(num_rays) ray_directions.resize(num_rays) for i in num_rays: var angle = i * 2 * PI / num_rays ray_directions[i] = Vector2.RIGHT.rotated(angle) In _physics_process() we’ll populate the context arrays and execute the movement. Note we’ve broken the steps of the algorithm in to separate functions. Once we’ve found our chosen direction, we turn towards it as much as possible (based on steer_force) and move.\nfunc _physics_process(delta): set_interest() set_danger() choose_direction() var desired_velocity = chosen_dir.rotated(rotation) * max_speed velocity = velocity.linear_interpolate(desired_velocity, steer_force) rotation = velocity.angle() move_and_collide(velocity * delta) Now we’ll go over the 3 functions that make up the algorithm. first, setting the interest array. As mentioned above, we’re going to ask the world (our owner in this case) to tell us which direction we should be trying to go.\nUsing each ray direction, we take the dot product with the given path direction. Recall that the dot product of two aligned vectors is 1 and for two perpendicular vectors it’s 0. We ignore negative values - 0 means we don’t want to go that way.\nFor example, with 32 rays, the interest would look like this:\nAs a safety measure, if there’s no owner to tell us a direction, we’ll default to trying to go forward.\nfunc set_interest(): # Set interest in each slot based on world direction if owner and owner.has_method(\"get_path_direction\"): var path_direction = owner.get_path_direction(position) for i in num_rays: var d = ray_directions[i].rotated(rotation).dot(path_direction) interest[i] = max(0, d) # If no world path, use default interest else: set_default_interest() func set_default_interest(): # Default to moving forward for i in num_rays: var d = ray_directions[i].rotated(rotation).dot(transform.x) interest[i] = max(0, d) Now we can populate the danger array. Using the Physics2DDirectSpaceState, we cast a ray in each direction. If there’s a hit, we add a 1 in that spot.\nfunc set_danger(): # Cast rays to find danger directions var space_state = get_world_2d().direct_space_state for i in num_rays: var result = space_state.intersect_ray(position, position + ray_directions[i].rotated(rotation) * look_ahead, [self]) danger[i] = 1.0 if result else 0.0 Finally, we can use the context arrays to choose our direction. Looping through the danger array, zero the interest wherever there’s danger. Then, sum up and normalize the remaining interest vectors.\nfunc choose_direction(): # Eliminate interest in slots with danger for i in num_rays: if danger[i] \u003e 0.0: interest[i] = 0.0 # Choose direction based on remaining interest chosen_dir = Vector2.ZERO for i in num_rays: chosen_dir += ray_directions[i] * interest[i] chosen_dir = chosen_dir.normalized() Example in Practice Let’s try it out in action! Here, we’ve created a track using a Path2D and some collision polygons.\nIn the script for this scene, we have a get_path_direction() function. Given a position, this function finds the closest point on the path and puts the PathFollow2D there in order to find the forward direction.\nfunc get_path_direction(pos): var offset = path.curve.get_closest_offset(pos) path_follow.offset = offset return path_follow.transform.x We’ve randomized the speeds of the agents do get some variety. Notice how the fast one finds ways to dodge around the slow ones.\nWrapping up This method is very flexible and can be extended to produce a wide variety of complex-looking behaviors. It\nHere are some additional suggestions for adaptations/improvements:\nLevels of danger When populating the danger array, don’t just use 0 or 1, but instead calculate a danger “score” based on the distance of the object. Then subtract that amount from the interest rather than removing it. Far away objects will have a small impact while close ones will have more.\nAvoidance Rather than a danger item canceling the interest, it could add to the interest in the opposite direction.\nRelated recipes Vectors: Using Dot and Cross Product Like video? ","description":"","tags":null,"title":"Context-based steering","uri":"/godot_recipes/3.x/ai/context_map/"},{"content":"Problem You need an easy way to display debug data on-screen.\nSolution We’ll create an overlay that any node can register a property with, and that property will be displayed in an appropriate format.\nHere’s an example of what we’re going for:\nStart by adding a MarginContainer named DebugStats with a VBoxContainer child. Set the margins to a comfortable value (I usually use 20).\nLet’s take a look at the code:\nextends MarginContainer class Property: var num_format = \"%4.2f\" var object # The object being tracked. var property # The property to display (NodePath). var label_ref # A reference to the Label. var display # Display option (rounded, etc.) func _init(_object, _property, _label, _display): object = _object property = _property label_ref = _label display = _display func set_label(): # Sets the label's text. var s = object.name + \"/\" + property + \" : \" var p = object.get_indexed(property) match display: \"\": s += str(p) \"length\": s += num_format % p.length() \"round\": match typeof(p): TYPE_INT, TYPE_REAL: s += num_format % p TYPE_VECTOR2, TYPE_VECTOR3: s += str(p.round()) label_ref.text = s var props = [] # An array of the tracked properties. func _process(_delta): if not visible: return for prop in props: prop.set_label() We begin with a custom class to encapsulate the data for the object and property we’re tracking. Let’s break down the class properties:\nobject - This is a reference to the object we’re tracking. property - This is in the form of a NodePath, meaning we can track something like \"position\", but also \"position:x\". label_ref - Each property is linked to a Label node, this is a reference to the label so that we can set its text. display - This is an optional setting to configure how the value should be displayed (see below). In the set_label() method we build up a string to display in the label’s text property. We include the object’s name and which property we’re showing, plus the value modified by the display option.\nFor this example, we’ve shown two settings for the display option:\n\"length\" - if the property is a vector, we’ll display its length. \"round\" - if the property is a numeric type, we’ll round its values. We then need functions to add/remove properties from the display:\nfunc add_property(object, property, display): var label = Label.new() label.set(\"custom_fonts/font\", load(\"res://debug/roboto_16.tres\")) $VBoxContainer.add_child(label) props.append(Property.new(object, property, label, display)) func remove_property(object, property): for prop in props: if prop.object == object and prop.property == property: props.erase(prop) add_property() can be called from any node (we should load the debug display as a singleton). This creates the label and registers the property object. Note that we’re loading a saved DynamicFont resource to use.\nAdding to game Now any node in the game can register/remove properties from the display like so:\nDebugOverlay.stats.add_property(self, \"velocity\", \"length\") DebugOverlay.stats.add_property(self, \"transform:origin\", \"round\") Related recipes Drawing Vectors in 3D ","description":"","tags":null,"title":"Displaying debug data","uri":"/godot_recipes/3.x/ui/debug_overlay/"},{"content":"Problem You’d like visual debug information in your 3D game: a way to see vectors representing velocity, position, etc.\nSolution Debug drawing in 2D is quite convenient. CanvasItem provides a range of primitive drawing methods to use in the _draw() callback. In 3D, things are not quite so simple. One solution is to use ImmediateGeometry to manually create meshes, but this is very cumbersome and inconvenient for quick debugging.\nA better solution is to stick with the CanvasItem draw methods. To do so, we need to project the positions in 3D space onto the 2D viewport. Fortunately, Camera can do this for us using its unproject_position() method.\nSetting up For the display layer, add a CanvasLayer containing a Control to your 3D scene and add a script to the Control.\nAs an example, let’s assume this drawing control has a reference to the player node, and we want to draw the node’s velocity vector. We also have a reference to the Camera node. More about how we’ll add those references later.\nvar player var camera func _draw(): var color = Color(0, 1, 0) var start = camera.unproject_position(player.global_transform.origin) var end = camera.unproject_position(player.global_transform.origin + player.velocity) node.draw_line(start, end, color, width) node.draw_triangle(end, start.direction_to(end), width*2, color) func draw_triangle(pos, dir, size, color): var a = pos + dir * size var b = pos + dir.rotated(2*PI/3) * size var c = pos + dir.rotated(4*PI/3) * size var points = PoolVector2Array([a, b, c]) draw_polygon(points, PoolColorArray([color])) We use unproject_position() to find the start and end points of the vector we want to draw. draw_triangle() is there to give us a nice pointed arrow appearance.\nEasy access from game objects Now let’s make this more functional. Your game might have many objects you want to draw debug vectors for. An enemy’s facing direction, an acceleration vector, a destination, etc. We need an easy way to register any object to the debug drawing layer.\nAdd the DebugOverlay as an autoload and set it as a singleton. This way we can access it from any node. Add this script to it:\nextends CanvasLayer onready var draw = $DebugDraw3D func _ready(): if not InputMap.has_action(\"toggle_debug\"): InputMap.add_action(\"toggle_debug\") var ev = InputEventKey.new() ev.scancode = KEY_BACKSLASH InputMap.action_add_event(\"toggle_debug\", ev) func _input(event): if event.is_action_pressed(\"toggle_debug\"): for n in get_children(): n.visible = not n.visible I’ve included the code to add an input action to toggle visibility. This makes it convenient to drop this into any project without needing to edit the Input Map. We can now reference the drawing layer with DebugOverlay.draw.\nNote You can add other debug layers here too. For example, one that displays properties as text.\nWe’ll start by defining a custom object to hold all the information for the debug value we want to display.\nextends Control class Vector: var object # The node to follow var property # The property to draw var scale # Scale factor var width # Line width var color # Draw color func _init(_object, _property, _scale, _width, _color): object = _object value = _property scale = _scale width = _width color = _color func draw(node, camera): var start = camera.unproject_position(object.global_transform.origin) var end = camera.unproject_position(object.global_transform.origin + object.get(property) * scale) node.draw_line(start, end, color, width) node.draw_triangle(end, start.direction_to(end), width*2, color) var vectors = [] # Array to hold all registered values. This object encapsulates all the functionality for each vector we want to display, including the drawing code we saw earlier. In _process(), we can then draw them, making sure to get the current active camera:\nfunc _process(delta): if not visible: return update() func _draw(): var camera = get_viewport().get_camera() for vector in vectors: vector.draw(self, camera) And finally, we can add a function to register a new vector to follow:\nfunc add_vector(object, property, scale, width, color): vectors.append(Vector.new(object, property, scale, width, color)) Now any object in the game can add a debug vector with the following:\nDebugOverlay.draw.add_vector(self, \"velocity\", 1, 4, Color(0,1,0, 0.5)) Here’s an example of an AI car displaying its raycasts and steering direction:\nRelated recipes UI: Displaying debug data ","description":"","tags":null,"title":"Drawing Vectors in 3D","uri":"/godot_recipes/3.x/3d/debug_overlay/"},{"content":"Problem You want units in your game to have healthbars that follow them as they move.\nSolution Displaying the bar can be done with a TextureProgress node. This is like the ProgressBar node, but allows the use of textures for the bar itself. The length of the bar will indicate the health value, but we can also change the texture color. We’ll use three colored bars for this:\nSo that this bar can be added to any unit in the game, we’ll make it a separate scene. Start with a Node2D and a TextureProgress child. Add a script to the root node.\nDrag the green bar into the Textures/Progress property and set its Value to 100. Drag the bar until it’s centered and above the origin.\nextends Node2D var bar_red = preload(\"res://assets/barHorizontal_red.png\") var bar_green = preload(\"res://assets/barHorizontal_green.png\") var bar_yellow = preload(\"res://assets/barHorizontal_yellow.png\") onready var healthbar = $HealthBar The script starts by loading the three colored bars, which will change as the health decreases. We also store a reference to the progress bar.\nfunc _ready(): hide() if get_parent() and get_parent().get(\"max_health\"): healthbar.max_value = get_parent().max_health The HealthDisplay should be attached to a unit. If the unit has a max_health property, we use that to set the range of the bar (it’s 100 by default). We also want the bar to start out hidden, and appear if the unit loses health.\nfunc _process(delta): global_rotation = 0 This prevents the bar from rotating. It will always remain on top of the unit it’s attached to.\nfunc update_healthbar(value): healthbar.texture_progress = bar_green if value \u003c healthbar.max_value * 0.7: healthbar.texture_progress = bar_yellow if value \u003c healthbar.max_value * 0.35: healthbar.texture_progress = bar_red if value \u003c healthbar.max_value: show() healthbar.value = value Finally, we have a function we can call when the unit’s health changes. It updates the value of the bar and sets the texture based on the remaining proportion.\nWhen you attach this to a unit, the bar may appear too big. Set the Scale property of the instanced HealthDisplay to adjust based on the size of your unit.\nHere’s an example of this system in use. You can download the example project for this below.\nNote Download the project file here: tower_defense_demo.zip\n","description":"","tags":null,"title":"Object Healthbars","uri":"/godot_recipes/3.x/ui/unit_healthbar/"},{"content":"Problem You’re looking for a way to handle data and/or create flexible data objects in your game.\nSolution Godot’s Resource class is a powerful tool for storing and working with data. Many of the most common objects you work with in Godot extend the Resource type: animations, collision shapes, images, etc. Resources not only contain data, but can also manipulate that data (if you’re familiar with the concept of scriptable objects in Unity, the concept is similar).\nIn addition to all of Godot’s built-in Resource types, you can create your own custom resources to handle your own game data. This has the benefit of abstracting and encapsulating data - creating something that can be used by any other object in your game.\nExample: Player health For this example, we’ll take the concept of player health in a platformer game. A lot of game systems interact with the player’s health. For example:\nThe player may take damage when running into obstacles Enemies can damage the player when touching or shooting them The player can heal when picking up objects or standing in certain places The game’s UI needs to display the health and any changes that happen In addition, there may be other interactions: maybe the game’s soundtrack changes as the player’s health gets low, or enemy behavior changes based on the player’s status.\nNote This is an intentionally simplified example. In practice, you’ll probably need more functionality than we use here, or you’ll want to modify the example to fit with your game’s architecture.\nFirst, we need to define our new custom resource, which we’ll call PlayerHealth. This resource needs to keep track of properties related to health. It also provides some functionality and signals to handle the changing of the health amount (such as healing and taking damage).\nIn the Script tab, choose File\u003eNew Script. Make sure it inherits Resource and name it PlayerHealth.gd.\nLet’s break it down piece-by-piece:\nAt the top we have our extends line and the class_name we’re assigning to the resource. This name will appear in various places in the editor.\nextends Resource class_name PlayerHealth Next we have a signal that game objects can subscribe to if they need to know when the player’s health changes. You could also add additional signals for the health reaching zero, etc.\nsignal health_changed These are the properties we’ll be using.\nexport (int) var max_value var current_value = 0 This function lets us initialize the health to the max value. You might do this at game restart or when starting a new level.\nfunc reset(): current_value = max_value This function should be called whenever damage is dealt to the player.\nfunc take_damage(amount): current_value = max(0, current_value - amount) emit_signal(\"health_changed\", current_value) This function should be called whenever the player needs to be healed.\nfunc heal(amount): current_value = min(max_value, current_value + amount) emit_signal(\"health_changed\", current_value) Here’s the full script:\nextends Resource class_name PlayerHealth signal health_empty signal health_changed export (int) var max_value var current_value = 0 func reset(): current_value = max_value func take_damage(amount): current_value = max(0, current_value - amount) emit_signal(\"health_changed\", current_value) func heal(amount): current_value = min(max_value, current_value + amount) emit_signal(\"health_changed\", current_value) Creating a new resource Once the PlayerHealth class is defined, we can make a new instance of it. Click the “New Resource” button at the top of the Inspector:\nIn the “Create New Resource” dialog you’ll see the long list of resource types. Searching will locate our PlayerHealth type.\nNow you can set the desired max_value and save the new resource as a .tres file.\nUsing the resource Once the resource has been created and saved, we’re ready to use it. Once again, in this scenario we have the following objects:\nPlayer - a KinematicBody2D UI - contains a ProgressTexture to display health Heal zone - an Area2D that heals anything that stands in it Spikes - TileMap tiles that cause damage if touched We won’t include all of the code for the game, just the parts that pertain to the health resource.\nOn the player, we export a variable to attach the resource via the Inspector. As part of the player’s movement code, it calls hurt() when the player runs into spikes.\nexport (Resource) var health func _ready(): health.reset() func hurt(amount): # Called when running into obstacles health.take_damage(amount) The heal zone (an Area2D), affects anything inside it that has a health property:\nfunc _physics_process(delta): for body in get_overlapping_bodies(): if \"health\" in body: body.health.heal(heal_rate * delta) Finally, for the UI to display the health, we attach the same health resource and connect to its health_changed signal:\nexport (Resource) var player_health func _ready(): if player_health: player_health.connect(\"health_changed\", self, \"_on_player_health_changed\") func _on_player_health_changed(value): healthbar.value = float(value) / player_health.max_value * 100 Here’s an example of it in action:\nNote Download the project file here: custom_resources.zip\nRelated recipes Platform character Object healthbars ","description":"","tags":null,"title":"Using Custom Resources","uri":"/godot_recipes/3.x/basics/custom_resources/"},{"content":"About ads When building a free-to-play mobile game, you have two choices when it comes to monetization: in-app purchases and advertisement. In this part, we’ll look at how to integrate a mobile ad platform (Admob) into your game.\nAds can be unpopular and whether to use them is a decision for the individual game developer to make. We’re not making a decision on the pros and cons in this tutorial - we’re here to show you how to put ads in your game if you want them.\nSet up Admob Head over to Admob and create an account.\nIn the AdMob manager, create a new app - ours is titled “Circle Jump” - and specify the “Android” platform (we’ll discuss iOS later).\nIn the “Circle Jump” app, you’ll need to create three “Ad Units”. These are the types of ads that you can show in your game. For this tutorial, we’ll need a “Banner” and an “Interstitial”. Each ad unit will have an “Ad Unit ID”, a long string of characters - we’ll need that later in the game.\nUsing Godot modules Godot doesn’t include ad services by default, so it’s necessary to use an engine module, or plugin, to add that functionality. You can find the module we’ll be using here: godot-admob. On that page, you’ll see a list of the methods provided by the plugin.\nTo use a custom engine module, the engine has to be recompiled. In the case of mobile platforms, that means recompiling the export templates because the default ones we downloaded from Godot weren’t compiled with this module.\nCompiling export templates is not difficult, but it does require setting up a build environment on your computer - downloading the required programs and libraries needed to build Godot. If you’re new to this concept and interested in learning about it, see the Compiling section of the official docs.\nFortunately, we won’t need to compile custom export templates, because it’s already been done for us. Head over to the godot-custom-mobile-templates Github repo. Click on “Releases” and download the version of the export templates that matches your version of Godot.\nWarning The export template version must match the Godot editor version. If you’re using a custom-built editor, you will also have to build the templates from the same code branch.\nUnzip the templates somewhere on your computer (don’t put them in the Circle Jump project folder).\nConfiguring export Back in the Godot editor, we need to make some changes to the export configuration. First, open Project -\u003e Project Settings and find the “Android” section. In the Modules property is where you list the module(s) you want to use in your code. The module name is listed on the godot-admob page: “org/godotengine/godot/GodotAdMob”. If you have more than one module, separate them with commas.\nIn the _Project -\u003e Export_menu, we need to tell Godot to use the custom templates we downloaded. These are set in the “Custom Package” section. Click the folder icon and navigate to where you unzipped the templates. Make sure to add both the “Debug” and “Release” templates.\nCode Now when we run the game (on Android), it will load that module. It’s accessed via an engine singleton. Open settings.gd and add the following:\nvar admob = null var real_ads = false var banner_top = false # Fill these from your AdMob account: var ad_banner_id = \"\" var ad_interstitial_id = \"\" var enable_ads = true These are our settings variables for the module. real_ads set to false puts us in “Test Ad” mode. You shouldn’t change this to true until you’re ready to release your game. banner_top toggles whether the banner ad should be shown at the top or bottom of the screen.\nad_banner_id and ad_interstitial_id should be filled with your ad unit values from your AdMob account.\nWe need to initialize the module:\nfunc _ready(): if Engine.has_singleton(\"AdMob\"): admob = Engine.get_singleton(\"AdMob\") admob.init(real_ads, get_instance_id()) admob.loadBanner(ad_banner_id, banner_top) admob.loadInterstitial(ad_interstitial_id) We first check that the module singleton exists. If it’s found, we can initialize the module and load the ad units.\nfunc show_ad_banner(): if admob and enable_ads: admob.showBanner() func hide_ad_banner(): if admob: admob.hideBanner() Next, we have functions to let us show/hide the banner. We only want it showing in the menu screens, not during actual gameplay.\nfunc show_ad_interstitial(): if admob and enable_ads: admob.showInterstitial() We’ll use this function to show the interstitial ad at the end of a game.\nfunc _on_interstitial_close(): if admob and enable_ads: show_ad_banner() The module looks for this callback to run any code when the interstitial ad closes. Since we’ll be at the end of a game and going back to the menu, we’ll show the banner again.\nNow we need to call these functions from the game. Open Main.gd and add the following:\nIn new_game(), add settings.hide_ad_banner(). At the end of _on_Jumper_died() add settings.show_ad_interstitial(). Run the game on your device, and you should see the test ad appear:\nDisabling ads Many games allow ads to be disabled, whether via in-app purchases, reaching a certain level, etc. In our case, we’ll add it as a button on the “Settings” screen.\nFirst, we’ll change the enable_ads to give it a setter function:\nvar enable_ads = true setget set_enable_ads And add the setter function:\nfunc set_enable_ads(value): enable_ads = value if enable_ads: show_ad_banner() if !enable_ads: hide_ad_banner() This will cause the banner add to appear/disappear instantly when pressing the button.\nTo add the button, we’ll need a third row of buttons. Open the BaseScreen scene and duplicate the first HBoxContainer.\nIn the SettingsScreen scene add a Button called “Ads” to the middle row. Set its text to “Disable Ads”, its Custom Font (a size of 48 works well), and set its Custom Styles all to “New StyleBoxEmpty”. Don’t forget to add the button to the “buttons” group.\nIn Screens.gd, add the following to the match statement that processes the buttons:\nmatch button.name: \"Ads\": settings.enable_ads = !settings.enable_ads if settings.enable_ads: button.text = \"Disable Ads\" else: button.text = \"Enable Ads\" Run the game on your device and verify that you can enable/disable ads.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video? ","description":"","tags":null,"title":"Mobile ads","uri":"/godot_recipes/3.x/games/circle_jump/circle_jump_11/"},{"content":"Problem You need a dynamic camera that moves and zooms to keep multiple objects on screen at the same time.\nAn example might be in a 2 player game, keeping both players on-screen as they move farther and closer together, like so:\nSolution In a single-player game, you’re probably used to attaching the camera to the player, so that it automatically follows them. We can’t really do this here because we have 2 (or more) players or other game objects that we want to keep on the screen at all times.\nWe need our camera to do 3 things:\nAdd/remove any number of targets. Keep the camera’s position centered at the midpoint of the targets. Adjust the camera’s zoom to keep all targets on screen. Create a new scene with a Camera2D and attach a script. We’ll add this camera to our game once we’re done.\nLet’s break down how the script works.\nNote You can see the full script at the end of the article.\nHere’s how the script starts:\nextends Camera2D export var move_speed = 0.5 # camera position lerp speed export var zoom_speed = 0.25 # camera zoom lerp speed export var min_zoom = 1.5 # camera won't zoom closer than this export var max_zoom = 5 # camera won't zoom farther than this export var margin = Vector2(400, 200) # include some buffer area around targets var targets = [] # Array of targets to be tracked. onready var screen_size = get_viewport_rect().size These settings will let you adjust the camera’s behavior. We’ll lerp() all camera changes, so making the move/zoom speeds low will introduce some delay in the camera “catching up” to sudden changes.\nMaximum and minimum zoom values will also depend on the size of objects in your game and how close or far you want to get.\nThe margin property is going to add some extra space around the targets so they’re not right on the edge of the viewable area.\nLastly, we have our array of targets and we get the viewport size so that we can properly calculate the scale.\nfunc add_target(t): if not t in targets: targets.append(t) func remove_target(t): if t in targets: targets.erase(t) For adding and removing targets, we have two helper functions. You can use these during gameplay to change what targets are being tracked (“Player 3 has entered the game!”). Note that we don’t want to have the same target tracked twice, so we reject it if it’s already there.\nMost of the functionality happens in _process(). First, moving the camera:\nfunc _process(delta): if !targets: return # Keep the camera centered between the targets var p = Vector2.ZERO for target in targets: p += target.position p /= targets.size() position = lerp(position, p, move_speed) Here, we loop through the targets’ positions and find the common center. Using lerp() we make sure it moves there smoothly.\nNext, we’ll handle the zoom:\n# Find the zoom that will contain all targets var r = Rect2(position, Vector2.ONE) for target in targets: r = r.expand(target.position) r = r.grow_individual(margin.x, margin.y, margin.x, margin.y) var d = max(r.size.x, r.size.y) var z if r.size.x \u003e r.size.y * screen_size.aspect(): z = clamp(r.size.x / screen_size.x, min_zoom, max_zoom) else: z = clamp(r.size.y / screen_size.y, min_zoom, max_zoom) zoom = lerp(zoom, Vector2.ONE * z, zoom_speed) The key functionality here comes from Rect2. We want to find a rectangle that encloses all the targets, which we can get with the expand() method. We then grow the rect by the margin.\nHere you can see the rectangle being drawn (press “Tab” in the demo project to enable this drawing):\nThen, depending whether the rectangle is wider or taller (relative to the screen’s aspect ratio), we find the scale and clamp it in the max/min range we’ve defined.\nFull script extends Camera2D export var move_speed = 0.5 # camera position lerp speed export var zoom_speed = 0.25 # camera zoom lerp speed export var min_zoom = 1.5 # camera won't zoom closer than this export var max_zoom = 5 # camera won't zoom farther than this export var margin = Vector2(400, 200) # include some buffer area around targets var targets = [] # Array of targets to be tracked. onready var screen_size = get_viewport_rect().size func _process(delta): if !targets: return # Keep the camera centered between the targets var p = Vector2.ZERO for target in targets: p += target.position p /= targets.size() position = lerp(position, p, move_speed) # Find the zoom that will contain all targets var r = Rect2(position, Vector2.ONE) for target in targets: r = r.expand(target.position) r = r.grow_individual(margin.x, margin.y, margin.x, margin.y) var d = max(r.size.x, r.size.y) var z if r.size.x \u003e r.size.y * screen_size.aspect(): z = clamp(r.size.x / screen_size.x, min_zoom, max_zoom) else: z = clamp(r.size.y / screen_size.y, min_zoom, max_zoom) zoom = lerp(zoom, Vector2.ONE * z, zoom_speed) func add_target(t): if not t in targets: targets.append(t) func remove_target(t): if t in targets: targets.erase(t) Note Download the project file here: multitarget_camera2d.zip\nRelated recipes Touchscreen Camera Splitscreen multiplayer Like video? ","description":"","tags":null,"title":"Multitarget Camera","uri":"/godot_recipes/3.x/2d/multi_target_camera/"},{"content":"Problem You want a 2D bullet that travels in an arc, or ballistic curve.\nSolution One approach to this problem would be to use a RigidBody2D - with its built-in physics, gravity would automatically pull it back to earth after firing it.\nHowever, as mentioned in the 2D shooting recipe, Area2D is a great choice for simple bullets and other projectiles - when you don’t need collisions, bouncing, or other physics reactions. Ballistic motion is easy enough to calculate that we won’t need the help of the physics engine.\nSetting up the bullet - Bullet (Area2D) - Sprite - CollisionShape2D We can use Area2D’s gravity property. Set it to 150 for the initial test.\nextends Area2D var velocity = Vector2(350, 0) func _process(delta): velocity.y += gravity * delta position += velocity * delta rotation = velocity.angle() func _on_BallisticBullet_body_entered(body): queue_free() Using the standard equations of motion is all we need to do here. The initial value for velocity is just for testing. Run the bullet scene:\nNow in your object that’s doing the shooting, you can instance the bullet and set its initial properties. Put this in whatever function/input handles shooting:\nexport var muzzle_velocity = 350 export var gravity = 250 func shoot(): var b = Bullet.instance() owner.add_child(b) b.transform = $Barrel/Position2D.global_transform b.velocity = b.transform.x * muzzle_velocity b.gravity = gravity Here’s an example in action:\nRelated recipes 2D shooting recipe 2D: Draw trajectory ","description":"","tags":null,"title":"Ballistic bullet","uri":"/godot_recipes/3.x/2d/ballistic_bullet/"},{"content":"Problem You want to move a 3D object to a clicked position.\nSolution We’ll start with a flat plane for our world. Our actor will move on this plane.\nThe actor for this demo is a triangular prism mesh:\nHere is the code for the movement. If given a target, the object will turn and move toward it.\nextends KinematicBody export var speed = 5 export var gravity = -5 var target = null var velocity = Vector3.ZERO func _physics_process(delta): velocity.y += gravity * delta if target: look_at(target, Vector3.UP) rotation.x = 0 velocity = -transform.basis.z * speed if transform.origin.distance_to(target) \u003c .5: target = null velocity = Vector3.ZERO velocity = move_and_slide(velocity, Vector3.UP) We’ve also added a MeshInstance called “Marker” to the scene. This will be moved to indicate the clicked position.\nMouse -\u003e 3D Now we need a way to map mouse position into our 3D world. If you imagine the screen as a window into the 3D world, the mouse is trapped on the glass. To select something in 3D, we must project a ray from our eye (the camera), through the mouse’s position and into the world.\nWhile this can be done manually using the Camera’s project_ray methods, we can take advantage of the fact that CollisionObject nodes do this automatically. All we need to do is connect our StaticBody ground’s input_event signal:\nfunc _on_StaticBody_input_event(camera, event, click_position, click_normal, shape_idx): if event is InputEventMouseButton and event.pressed: $Marker.transform.origin = click_position $Player.target = click_position We set the position of the marker and the Player’s target to the clicked position:\nWrapping up You can use this technique to detect clicks on any objects in your 3D world.\nNote Download the project file here: 3d_click_move.zip\nRelated recipes Like video? ","description":"","tags":null,"title":"Click to move","uri":"/godot_recipes/3.x/3d/click_to_move/"},{"content":"Problem You want units to display damage as floating numbers when hit.\nSolution There are many ways to approach this problem. For example, you could use a bitmap font and build an image for each number out of its digits, then use a Sprite node to display and move it.\nHowever, for this recipe, we’ll use a Label node (named “FCT”). This will give us the flexibility to change the font, as well as making it easy to display the number as a string - or even other messages such as “miss”.\nStart with a Label node and add a Tween child. We’ll use the Tween to animate the movement and the fade-out effect.\nSet the label’s Custom Fonts/Font property using your favorite font. In this example, we’re using “Xolonium.ttf” with a font size of 28 and a black outline of 1 pixel. In the menu select “Layout-\u003eCenter”, and also set Align and Valign to “Center”.\nAdd a script to the label.\nextends Label func show_value(value, travel, duration, spread, crit=false): When we spawn the floating text, we’ll call this function to set the parameters:\nvalue - the number (or string) to display travel - a Vector2 representing the direction of travel duration - how long the text will last spread - movement will be randomly spread across this arc crit - if true, indicates the damage was a “critical” hit Here’s what the function does:\ntext = value var movement = travel.rotated(rand_range(-spread/2, spread/2)) rect_pivot_offset = rect_size / 2 First, assign the value and randomize the movement based on the given spread (+/-90 degrees, for example). Since we may also be animating the scale, we set the rect_pivot_offset to the center of the control so that it will scale from the center.\n$Tween.interpolate_property(self, \"rect_position\", rect_position, rect_position + movement, duration, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT) $Tween.interpolate_property(self, \"modulate:a\", 1.0, 0.0, duration, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT) Next, we have two properties to interpolate: rect_position for the movement and modulate.a for the visibility.\nif crit: modulate = Color(1, 0, 0) $Tween.interpolate_property(self, \"rect_scale\", rect_scale*2, rect_scale, 0.4, Tween.TRANS_BACK, Tween.EASE_IN) If the hit is a critical, we’ll also change the color and animate the scale for a bigger effect. Note, I’ve hardcoded this to be red, but you should probably make this a configurable value.\n$Tween.start() yield($Tween, \"tween_all_completed\") queue_free() Finally, we start the Tween and wait for it to finish, then remove the Label.\nFloating text manager Next we’ll crate a small node to manage placing and spawning the floating text. This node will be attached to the game entities that you want to display floating text effects.\nThis is a Node2D named “FCTManager”. It contains the following script:\nextends Node2D var FCT = preload(\"res://FCT.tscn\") export var travel = Vector2(0, -80) export var duration = 2 export var spread = PI/2 func show_value(value, crit=false): var fct = FCT.instance() add_child(fct) fct.show_value(str(value), travel, duration, spread, crit) Here you can expose the settings to the Inspector for convenient changes. The show_value() method here spawns the floating labels and sets their properties.\nIn your game unit, you’d attach an instance of this node, and position it wherever you want the text to appear. Then add something like the following to the unit’s take_damage() method:\n$FCTManager.show_value(dmg, crit) Wrapping up Optimization: in the case where you have a very large number of enemies/bullets, you may experience some performance impact from repeatedly spawning and freeing floating text. In this case, you can spawn a fixed number of text objects in the manager, and show/hide them rather than freeing them at the end of the animation.\nNote Download the project file here: floating_text.zip\nNote Art in this demo by Luis Zuno\nRelated recipes UI: Labels UI: Object Healthbars Like video? ","description":"","tags":null,"title":"Floating combat text","uri":"/godot_recipes/3.x/ui/floating_text/"},{"content":"Problem Your game needs a “level select” menu, where the user can choose from a grid of options.\nSolution As shown in the example above, we’ll make a scrolling grid of level “boxes” that the player can choose from. Let’s start with the individual level boxes:\n1: Level box Here’s the node setup:\nLevelBox: PanelContainer Label MarginContainer TextureRect The TextureRect is for displaying the lock icon, and the Label for displaying the level number. When one is showing, the other is hidden.\nYou can style these as you like, here’s an example:\nMake sure to set the box’s Rect Min Size in the Inspector. We’re using (110, 110) in the example, but it depends on what size layout you’re going for.\nNow add a script and connect the gui_input signal.\nextends PanelContainer signal level_selected var locked = true setget set_locked var level_num = 1 setget set_level onready var label = $Label onready var lock = $MarginContainer func set_locked(value): locked = value lock.visible = value label.visible = not value func set_level(value): level_num = value label.text = str(level_num) func _on_LevelBox_gui_input(event): if locked: return if event is InputEventMouseButton and event.pressed: print(\"Clicked level \", level_num) emit_signal(\"level_selected\", level_num) The print() statement can help you test that the click is being detected.\n2: Grid Once you have the box scene completed, add a new scene with a GridContainer. Add any number of LevelBox instances under it, making sure to set the Columns value. Here’s one with 6 columns:\nIn this example Custom Constants/HSeparation and VSeparation are set to 10.\nSave this scene as LevelGrid. We’ll use multiple instances to display the desired number of levels.\n3: Menu screen Now we can put together the final menu.\nHere’s the basic layout we’re going for:\nWe’ll create it with these nodes:\nLevelMenu: MarginContainer VBoxContainer Title: Label HBoxContainer BackButton: TextureButton ClipControl: Control NextButton: TextureButton Adjust the node properties:\nLevelMenu Custom Constants/Margins: 20 VBoxContainer Custom Constants/Separation: 50 Title Style the font however you like HBoxContainer Size Flags/Vertical: Expand BackButton / NextButton Expand: On Stretch Mode: Keep Aspect Centered Size Flags/Horizontal: Expand ClipControl Rect/Clip Content: On Rect/Min Size: 710 The ClipControl node is where the grid goes. Enabling Clip Content means that if the contents are larger than the control, they’ll be cropped. That will allow us to make a horizontally scrolling set of grids. Add an HBoxContainer called GridBox to ClipControl, and instance 3 (or more) LevelGrids inside it.\nMake sure to set Custom Constants/Separation to 0.\nYour layout should look something like this (we’ve disabled Clip Content in order to show what’s happening):\nWith Clip Content, the three grids are all there, but the ClipControl only shows one at a time.\nNow, to scroll the menu, we need to shift the GridBox by 710 pixels to the left/right.\n110 (width of each LevelBox) * 6 (grid columns) + 10 (grid spacing) * 5 == 710 Info You may be wondering why we’re not using a ScrollContainer here. You certainly can, but we don’t want continuous scrolling, and we don’t want to see a scrollbar.\nAdd a script to the LevelMenu and connect the pressed signals of the two buttons.\nextends MarginContainer var num_grids = 1 var current_grid = 1 var grid_width = 710 onready var gridbox = $VBoxContainer/HBoxContainer/ClipControl/GridBox onready var tween = $Tween func _ready(): # Number all the level boxes and unlock them # Replace with your game's level/unlocks/etc. # You can also connect the \"level_selected\" signals num_grids = gridbox.get_child_count() for grid in gridbox.get_children(): for box in grid.get_children(): var num = box.get_position_in_parent() + 1 + 18 * grid.get_position_in_parent() box.level_num = num box.locked = false func _on_BackButton_pressed(): if current_grid \u003e 1: current_grid -= 1 gridbox.rect_position.x += grid_width func _on_NextButton_pressed(): if current_grid \u003c num_grids: current_grid += 1 gridbox.rect_position.x -= grid_width When you run the scene, you’ll find that clicking “Next” will advance to the next menu, but the “Back” button doesn’t work.\nThe problem is scene order. BackButton is above ClipControl in the scene tree. That means that when the grid is shifted to the left, it is on top of the button. Unfortunately, there’s not a Clip Input property, but there is a way. Attach a script to ClipControl:\nextends Control func _clips_input(): return true Now everything should be working as expected.\nDownload the example project to see the whole thing in action, including some tweens for the scrolling action (tweens make everything better).\nNote Download the project file here: level_select.zip\nRelated recipes Containers Know Your Nodes: Label Like video? ","description":"","tags":[],"title":"Level Select Menu","uri":"/godot_recipes/3.x/ui/level_select/"},{"content":"Problem You want to have collisions with a Line2D.\nSolution Node setup Add the following nodes to your scene, and draw your line as desired:\nLine2D StaticBody2D Don’t add a collision shape to the body yet!\nNote You can use an Area2D instead if you want to detect overlap with the line rather than collision.\nNext, we need to add collision shapes to the body. We have two options:\nOption 1: Using SegmentShape2D SegmentShape2D is a line-segment collision shape. The idea here is to create a segment collision for each pair of points in the line.\nextends Line2D func _ready(): for i in points.size() - 1: var new_shape = CollisionShape2D.new() $StaticBody2D.add_child(new_shape) var segment = SegmentShape2D.new() segment.a = points[i] segment.b = points[i + 1] new_shape.shape = segment Option 2: Using RectangleShape2D SegmentShape2D does not have any width component, so if you need your line collision to have a thickness, you can use a rectangle collision instead.\nextends Line2D func _ready(): for i in points.size() - 1: var new_shape = CollisionShape2D.new() $StaticBody2D.add_child(new_shape) var rect = RectangleShape2D.new() new_shape.position = (points[i] + points[i + 1]) / 2 new_shape.rotation = points[i].direction_to(points[i + 1]).angle() var length = points[i].distance_to(points[i + 1]) rect.extents = Vector2(length / 2, 10) new_shape.shape = rect Note Download an example project here: 2d_line_collision.zip\nRelated recipes Top-down Movement ","description":"","tags":null,"title":"Line2D Collision","uri":"/godot_recipes/3.x/2d/line_collision/"},{"content":"Problem You want a minimap or radar-style UI item showing the locations of objects outside of the player’s view.\nSolution Here’s an example of what we are going for: Project setup To illustrate this feature, we’ll start with a simplified top-down game using the Autotile recipe and a player based on the Top-down character recipe. See the linked recipes for details on how these parts work.\nNote The art in this project comes from kenney.nl, which you can download here: Topdown Shooter and Interface Pack.\nOur main scene setup looks like this:\nThe CanvasLayer node is there to hold our UI, including the minimap/radar we’re making in this recipe.\nUI Layout The first step will be to create the layout for the minimap. In order to work with whatever other UI elements exist in the game, it must resize smoothly, and integrate well with a container-based layout.\nAdd a MarginContainer first. Set its Custom Constants all to 5. This control will hold the rest of the nodes and ensure it doesn’t bleed over into any other elements. Name it “MiniMap” and save the scene.\nNext, add a NinePatchRect node. This node is similar to a TextureRect but handles resizing differently by not stretching the corners/edges. Drop the panel_woodDetail_blank.png image from the asset folder into the Texture property. This is a 128x128 image and if we scale the root MarginContainer, the image becomes stretched and ugly:\nUsing the NinePatchRects’s properties, we can ensure that the frame remains the same size when stretched. You can define these properties graphically in the “TextureRegion” panel, but it’s sometimes easier to enter the values directly. Set all four properties in the Patch Margin section to 64 and change the node’s name to “Frame”.\nNow observe what happens when we change the size:\nNext, we’d like to fill in the inner part of the frame with the grid pattern pattern_blueprintPaper.png:\nHowever, we need it to tile automatically no matter what size we make the frame. Also, since this grid area is where our minimap markers will appear, we don’t want the grid extending past the edges of the frame.\nAs a child of the MiniMap (and a sibling of the Frame), add another MarginContainer. Set all four margin properties in Custom Constants to 20. As a child of this node, add a TextureRect and assign its Texture to the above image. Set its Stretch Mode to “Tile”. Name this node “Grid”.\nTry changing the size of your root node to see the effect:\nFor now, let’s leave the minimap’s size at (200, 200) - you can check the root node’s Rect/Size property to confirm.\nAt this point, your scene tree should look like the following:\nMap Markers As a child of Grid, add a Sprite node named “PlayerMarker” and give it the minimapIcon_arrowA.png texture. Note the sprite’s Transform/Position property: (0, 0), which places it exactly in the top-left corner of the Grid:\nIf our Grid size is currently (150, 150) (you can check this in its Rect/Size property), then its center will be (75, 75). Put the PlayerMarker’s Position there:\nDon’t worry, we’ll automate this later.\nAdd two more Sprite nodes: “MobMarker” and “AlertMarker”, using the minimapIcon_jewelRed.png and minimapIcon_exclamationYellow.png textures.\nThese will represent two different types of objects in the game world. Click the “Toggle Visibility” button next to each so that they won’t appear by default.\nScripting the map markers At this point, we have some decisions to make. How we approach populating the minimap with the objects in the world has a lot to do with how the game is set up. Since this is a very minimal demonstration project, we’re going keep the process simple. In a larger game, you may need to use a more robust approach.\nFor this demo, we have two game objects: a Mob, which wanders around the map randomly, and a Crate, which the player can pick up. Many of these are scattered around the main scene. Each will need to be represented by one of the map markers we made.\nAdd each item that you want to appear on the minimap to a group named “minimap_objects”. In each object’s script, assign it a minimap_icon property:\n# In the mob's script: var minimap_icon = \"mob\" # In the crate's script: var minimap_icon = \"alert\" Now we can begin adding a script to the MiniMap. First, a player reference that can be assigned in the Inspector when the minimap is added to the main scene and a zoom property to calibrate the scale - how far the minimap can “see”. We also have some onready variables to make it more convenient to access the nodes we need.\nextends MarginContainer export (NodePath) var player export var zoom = 1.5 onready var grid = $MarginContainer/Grid onready var player_marker = $MarginContainer/Grid/PlayerMarker onready var mob_marker = $MarginContainer/Grid/MobMarker onready var alert_marker = $MarginContainer/Grid/AlertMarker Next, we’ll use a dictionary to map the minimap_icon tags we gave our units to the corresponding marker:\nonready var icons = {\"mob\": mob_marker, \"alert\": alert_marker} Then we need a variable to hold the calculated ratio of map size to world size. We’ll use another dictionary to assign active markers to each object. The key will be the object (ie the Mob or Crate instance) and the value the assigned marker.\nvar grid_scale var markers = {} In _ready() we’ll center the player’s marker at the center of the grid. and calculate the scale factor. (Note: you should connect the resized signal and do both of these things in the callback if you have a dynamically sized UI).\nfunc _ready(): player_marker.position = grid.rect_size / 2 grid_scale = grid.rect_size / (get_viewport_rect().size * zoom) We’ll also create markers for every game object (using the “minimap_objects” group) by duplicating the matching marker node and tying the marker to the object via the markers dictionary:\nvar map_objects = get_tree().get_nodes_in_group(\"minimap_objects\") for item in map_objects: var new_marker = icons[item.minimap_icon].duplicate() grid.add_child(new_marker) new_marker.show() markers[item] = new_marker Now that we have created the markers and linked each one to an object, we can update their positions in _process(). If no player is assigned, we’ll do nothing:\nfunc _process(delta): if !player: return If there is a player, we’ll first rotate the player marker to match the player’s heading. Since our PlayerMarker sprite points upwards rather than along the x axis, we must add 90 degrees:\nplayer_marker.rotation = get_node(player).rotation + PI/2 Next, we’ll find each object’s position relative to the player and use that to find the marker’s position (remembering to offset by grid.rect_size / 2 because the control’s origin is in the top left corner).\nfor item in markers: var obj_pos = (item.position - get_node(player).position) * grid_scale + grid.rect_size / 2 markers[item].position = obj_pos The problem with this is that markers can be placed outside the grid:\nTo fix this, after calculating obj_pos, but before setting the marker’s position, clamp it to the grid’s rectangle:\nobj_pos.x = clamp(obj_pos.x, 0, grid.rect_size.x) obj_pos.y = clamp(obj_pos.y, 0, grid.rect_size.y) Next, we can decide what to do about markers that are “off-screen” - when they would be outside the grid’s rectangle. Choose one of the following options (do this also before using clamp()). The first option is to hide them:\nif grid.get_rect().has_point(obj_pos + grid.rect_position): markers[item].hide() else: markers[item].show() The second is to change their appearance, in this case we’ll make them smaller to show they’re at a farther distance:\nif grid.get_rect().has_point(obj_pos + grid.rect_position): markers[item].scale = Vector2(0.75, 0.75) else: markers[item].scale = Vector2(1, 1) Removing objects If a mob gets killed or a crate picked up, the game will crash because the marker reference is no longer valid. We need a way to ensure markers are removed when the object is. Here’s a quick way to do this in our rudimentary demo setup:\nAdd signal removed to any object that you’ve put in the “minimap_objects” group. Emit this signal when the object is destroyed, along with a reference to itself so the map can identify it:\nemit_signal(\"removed\", self) In the _ready() of the main script, connect these signals to the minimap:\nfunc _ready(): for object in get_tree().get_nodes_in_group(\"minimap_objects\"): object.connect(\"removed\", $CanvasLayer/MiniMap, \"_on_object_removed\") Now add the receiving function to the minimap script to free the marker and remove the reference:\nfunc _on_object_removed(object): if object in markers: markers[object].queue_free() markers.erase(object) Adjusting zoom If you’ve stuck with it this far, we have one more feature to add: adjustable zoom level. With this, scrolling the mouse wheel when hovering over the map will zoom its scale in and out.\nFirst, add a setget to the zoom property:\nexport var zoom = 1.5 setget set_zoom func set_zoom(value): zoom = clamp(value, 0.5, 5) grid_scale = grid.rect_size / (get_viewport_rect().size * zoom) On the MiniMap node, connect the _gui_input signal in the Inspector so we can process the scroll wheel events:\nfunc _on_MiniMap_gui_input(event): if event is InputEventMouseButton and event.pressed: if event.button_index == BUTTON_WHEEL_UP: self.zoom += 0.1 if event.button_index == BUTTON_WHEEL_DOWN: self.zoom -= 0.1 That’s it - observe the effect of scrolling in and out:\nWrapping up While this is a pretty big recipe, I’ve tried to make it flexible enough for you to incorporate into whatever project you’re working on.\nSome other things you might want to add:\nMore marker types for different game objects. Adding new units when they’re spawned (hint: use a signal just like we did for removing units). Clicking on a marker to get info about it. Use a picture of your map as the minimap background instead of the grid. Note Download the project file here: minimap.zip\nRelated recipes UI: Containers TileMap: using autotile Top-down character Like video? ","description":"","tags":null,"title":"Minimap/radar","uri":"/godot_recipes/3.x/ui/minimap/"},{"content":"Problem You want to make an arcade-style car game, so you’re looking for simplicity over realistic physics. In this recipe, you’ll learn how to make a fun, driveable car using a rolling sphere.\nSolution There are a lot of ways to make a driving game. Different games need different levels of realism. If you’re trying to make a light, arcade-style car, you don’t need all of the features that Godot’s VehicleBody node provides, such as supension, independently modeled wheels, etc.\nInstead, we’re going to use a single RigidBody sphere to handle the driving physics. The sphere will be invisible, and the car mesh will be placed at the sphere’s location, making it look like it’s the car that’s driving.\nAs you can see in the preview clip above, the result looks remarkably good (and feels great to play!). Read on, and you’ll see that the amount of code required is also surprisingly small.\nInputs For control, we’re going to add four inputs to the Input Map:\naccelerate brake steer_left steer_right You can use keyboard input, game controller, or both. However, we recommend going with the analog stick for better steering.\nNode setup In order to make this work, the car is split into two separate nodes: a RigidBody sphere for the physics, and a MeshInstance to display the car body. Here’s the scene layout:\nCar: Spatial CarMesh (Imported model) Ball: RigidBody Here’s how these nodes will interact: pressing “accelerate” will apply a force on the Ball in the direction the CarMesh is facing, while the turning inputs will rotate the CarMesh.\nCarMesh Here’s the car model we’ll use:\nNote You can find this and other car models in Kenney’s “Car Kit”, available here: https://kenney.nl/assets/car-kit. Download the whole kit; you can use any of them that you choose. Note that this kit includes the models in multiple formats - you won’t need all of them for your project. GLTF is the recommended format for use with Godot.\nIf you use the GLTF models, you shouldn’t have adjust anything in the import settings.\nHere’s what the node tree looks like when importing the “suv” model:\nNote that the wheels \u0026 body are separate meshes. This will make it easy to add some visual appeal - like turning the wheels when steering.\nBall Add a sphere CollisionShape to the rigid body. We’re using a radius of 1 here, but you’ll want to experiment with the size of the ball to get different driving behavior.\nHere’s how to adjust the settings on the body:\nAngular Damp: 5 - this property will have a huge effect on the driving feel. A higher value will bring the car to a stop much faster. Gravity Scale: 10 - Default gravity in Godot (9.8) feels a bit floaty, especially when going for an action feel. This will really matter if you plan to have jumps, hills, etc. in your world. You can set this in the Project Settings instead, if you prefer. Physics Material/Bounce: 0.1 - Playing around with this value can be a lot of fun. Be careful going above 0.5, though! For the demo, we’ve also added a mesh for debugging purposes. You don’t need this, but it helps when troubleshooting to have a visual of the ball rolling.\nRayCast Finally, add a RayCast node as a child of the CarMesh. Set its Cast To to (0, -1, 0). As always, don’t forget to check the Enabled box.\nWe’re going to use this for ground detection. When the car’s in the air, steering and acceleration won’t work. We can also use it to align the car mesh to a slope (if your game’s track isn’t flat).\nNow we’re ready to start coding.\nScript We’ll begin the script with some node references we’ll need:\nextends Spatial # Node references onready var ball = $Ball onready var car_mesh = $CarMesh onready var ground_ray = $CarMesh/RayCast Next, some variables configuring the car’s behavior. See the comments describing each one’s purpose.\n# Where to place the car mesh relative to the sphere var sphere_offset = Vector3(0, -1.0, 0) # Engine power var acceleration = 50 # Turn amount, in degrees var steering = 21.0 # How quickly the car turns var turn_speed = 5 # Below this speed, the car doesn't turn var turn_stop_limit = 0.75 # Variables for input values var speed_input = 0 var rotate_input = 0 You can export these if you’d like to adjust them from the Inspector.\nWe don’t want the RayCast to collide with the ball, so we can add an exception in _ready().\nfunc _ready(): ground_ray.add_exception(ball) Then, in _physics_process() we add a force to the ball based on the direction the car is pointing, as well as keeping the car mesh positioned at the ball’s position:\nfunc _physics_process(_delta): # Keep the car mesh aligned with the sphere car_mesh.transform.origin = ball.transform.origin + sphere_offset # Accelerate based on car's forward direction ball.add_central_force(-car_mesh.global_transform.basis.z * speed_input) The next step is to get the inputs, but we’ll also check if the ray is colliding with the ground first:\nfunc _process(delta): # Can't steer/accelerate when in the air if not ground_ray.is_colliding(): return # Get accelerate/brake input speed_input = 0 speed_input += Input.get_action_strength(\"accelerate\") speed_input -= Input.get_action_strength(\"brake\") speed_input *= acceleration # Get steering input rotate_input = 0 rotate_input += Input.get_action_strength(\"steer_left\") rotate_input -= Input.get_action_strength(\"steer_right\") rotate_input *= deg2rad(steering) Tip At this point, you can try it out. You should be able to accelerate forward and back (but not steer yet).\nNext, still in the _process() function, we’ll rotate the car mesh based on the rotation input. We’ll use slerp() (spherical linear interpolation) to do this smoothly:\n# rotate car mesh if ball.linear_velocity.length() \u003e turn_stop_limit: var new_basis = car_mesh.global_transform.basis.rotated(car_mesh.global_transform.basis.y, rotate_input) car_mesh.global_transform.basis = car_mesh.global_transform.basis.slerp(new_basis, turn_speed * delta) car_mesh.global_transform = car_mesh.global_transform.orthonormalized() Warning Because of floating point imprecision, repeatedly rotating a transform will eventually cause it to become distorted. The scale can drift or the axes can become no-perpendicular. In any script where you’re regularly rotating a transform, it’s a good idea to use orthonormalized() to correct any error before it accumulates.\nYou should try playing again at this point. You’ll be able to control the car and drive around, and everything works pretty much as expected. However, there are a few more things to add that will improve the “feel” of the driving.\nFinal touches 1. Align with slopes If you’ve tried driving on a slope, you’ve seen that the car mesh doesn’t tilt at all, it always remains level. That looks unnatural, so let’s use the process described in KinematicBody: Align with Surface to fix that.\nAdd this code after rotating the mesh in _process():\nvar n = ground_ray.get_collision_normal() var xform = align_with_y(car_mesh.global_transform, n.normalized()) car_mesh.global_transform = car_mesh.global_transform.interpolate_with(xform, 10 * delta) And the align function (notice how we’re using orthonormalized() again?):\nfunc align_with_y(xform, new_y): xform.basis.y = new_y xform.basis.x = -xform.basis.z.cross(new_y) xform.basis = xform.basis.orthonormalized() return xform 2. Turn the wheels It looks nice if the front wheels turn when you steer. Add some references to the front wheel meshes at the top of the script:\nonready var right_wheel = $CarMesh/tmpParent/suv/wheel_frontRight onready var left_wheel = $CarMesh/tmpParent/suv/wheel_frontLeft And right after getting input, add the following:\n# rotate wheels for effect right_wheel.rotation.y = rotate_input left_wheel.rotation.y = rotate_input 3. Tilt the body This one adds a ton of visual appeal. We’re going to tilt the car’s body based on the speed of the turn. Add a variable at the top of the script:\nvar body_tilt = 35 The smaller this number, the more extreme the tilt effect will be. Between 35 and 40 works well for the SUV model.\nNow add the following right after rotating the car mesh (in the if statement):\n# tilt body for effect var t = -rotate_input * ball.linear_velocity.length() / body_tilt body_mesh.rotation.z = lerp(body_mesh.rotation.z, t, 10 * delta) Observe the difference:\n4. Smoke Finally, the skid looks much better with a little smoke coming from the tires. Here’s an example using a Particles node and sphere shapes:\nWrapping up Note Download the project file here: https://github.com/kidscancode/3d_car_sphere\nCredits The demo project seen here uses the following open-source/creative commons assets:\nCars: Kenney Car Kit by Kenney Track: Modular Racekart Track by Keith at Fertile Soil Productions Outline shader: Godot Post Process Outlines by jocamar Related recipes Input Actions KinematicBody: Align with Surface Like video? ","description":"","tags":null,"title":"Quick Arcade-style Car","uri":"/godot_recipes/3.x/3d/3d_sphere_car/"},{"content":"Saving settings We’ve added three toggle properties in the game - which works fine - but the settings aren’t preserved when we quit. We need to save those settings so the next time you run the game, they persist.\nFirst, we’ll define our settings file in res://settings.gd:\nvar settings_file = \"user://settings.save\" Next, we’ll add saving/loading functions for the three game settings that we want to save.\nfunc save_settings(): var f = File.new() f.open(settings_file, File.WRITE) f.store_var(enable_sound) f.store_var(enable_music) f.store_var(enable_ads) f.close() func load_settings(): var f = File.new() if f.file_exists(settings_file): f.open(settings_file, File.READ) enable_sound = f.get_var() enable_music = f.get_var() self.enable_ads = f.get_var() f.close() Call load_settings() in _ready() and save_settings() at the end of set_enable_ads(). Also, in Screens.gd we need to save the state when the sound/music settings change, so add settings.save_settings() in each of those parts of the match statement.\nAnother problem we’ll have is when the game starts, the icons in the settings menu won’t reflect the state that we just loaded from the save file. We can set that in register_buttons() which is already looping through all buttons to connect their signals:\nfor button in buttons: button.connect(\"pressed\", self, \"_on_button_pressed\", [button]) match button.name: \"Ads\": if settings.enable_ads: button.text = \"Disable Ads\" else: button.text = \"Enable Ads\" \"Sound\": button.texture_normal = sound_buttons[settings.enable_sound] \"Music\": button.texture_normal = music_buttons[settings.enable_music] About screen The other thing we’ll add in this part is an “About” screen. This is where we’ll let the player know what the game’s all about and link to its license and to this page, since it is a tutorial game.\nWarning Complying with license terms is very important. You can find out what’s required by Godot here: Complying with Licenses. Note that the art you’re using may also require credit, links, or other acknowledgement.\nTo reach it, we’ve added a new button on the “Title” screen:\nThe button is setup just like the others - add it to the “buttons” group so that it will get registered. In the Screens.gd, add another match for this button’s name:\n\"About\": change_screen($AboutScreen) Here’s what the “About” screen looks like:\nExtending “BaseScreen.tscn”, we’ve added a TextEdit and another container for a single “Home” button.\nIn the TextEdit, set BBCode enabled and put the following in the Text property:\n[center][u]Circle Jump[/u] [img]res://assets/images/godot_logo.png[/img][/center] Circle Jump is an open source tutorial game made with the Godot Game Engine. You can find the tutorial and the game's source code here: [url=https://github.com/kidscancode/circle_jump]Circle Jump Source[/url] Copyright © 2019 KidsCanCode [url=https://github.com/kidscancode/circle_jump/blob/master/LICENSE]License Information[/url] Note See BBCode in RichTextLabel for details on how BBCode formatting works.\nTo allow clicking on URLs, connect the meta_clicked signal of the TextEdit:\nfunc _on_TextEdit_meta_clicked(meta): OS.shell_open(meta) Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video? ","description":"","tags":null,"title":"Saving settings","uri":"/godot_recipes/3.x/games/circle_jump/circle_jump_12/"},{"content":"Problem You want to smoothly rotate a 3D object to point in a new direction.\nSolution When you first encounter this problem, you may find yourself thinking in terms of Euler angles - the three values representing the angles to the x/y/z axes. While Godot will allow you to see the object’s Euler angles in the rotation property, it is not recommended to use them to work in 3D. There are a number of reasons why this the case, such as a problem called “gimbal lock”, where you lose one degree of freedom when one of your rotations reaches 90 degrees.\nInfo If you’re interested in the background behind Euler angles and the problems they introduce, like gimbal lock, here’s a video that explains it well.\nWe can avoid using 3D Euler angles in Godot by using the object’s Transform property. This property represents the body’s position and orientation in space. It uses a mathematical construct called a matrix to do this, but you don’t really need to understand the underlying math in order to make use of it.\nlook_at() Let’s say we have a 3D object such as a missile or arrow and you want it to point at its target. You can do this using the Spatial method look_at():\nfunc _process(delta): var target_position = $Target.transform.origin $Arrow.look_at(target_position, Vector3.UP) This code would make our node ($Arrow) always point at the target’s position, no matter how it moves.\nNote that look_at() requires 2 parameters: the target position, and an “up vector”. Imagine an airplane pointing its nose towards a target - there are an infinite number of ways it could be oriented, because the plane could roll about its axis. This second parameter is how you define what you want the final orientation to be.\nSmooth rotation The above code works, but it snaps the rotation instantly to the target. This might be fine if you have a very slow-moving target, but looks unnatural. It would look better if we move smoothly, or “interpolated”, the rotation smoothly between the starting orientation and the ending.\nGodot has us covered here too, because the Transform object has a method called interpolate_with(), which returns an intermediate transform between a current one and a target one.\nvar speed = 5 func _process(delta): var target_position = $Target.transform.origin var new_transform = $Arrow.transform.looking_at(target_position, Vector3.UP) $Arrow.transform = $Arrow.transform.interpolate_with(new_transform, speed * delta) Note that since interpolate_with() operates on the transform, it can be used to interpolate both rotation and position of an object.\nWrapping up That’s it! Use this handy method to rotate your 3D objects, and stop thinking about angles!\nNote Download the project file here: 3d_rotate.zip\nRelated recipes Gamedev Math: Transforms Gamedev Math: Interpolation Camera Gimbal Like video? ","description":"","tags":null,"title":"Smooth rotation","uri":"/godot_recipes/3.x/3d/rotate_interpolate/"},{"content":"Problem You need a touch-controlled 2D camera for your mobile game.\nSolution In this recipe, we’ll create a generic 2D camera with multiple touch controls:\nDrag to pan Pinch to zoom Setup Our camera will extend the built-in node, so add a Camera2D to a new scene and name it “TouchCamera”. Save and attach a script.\nHere are the variables we’ll need:\nextends Camera2D export (NodePath) var target # Optional: export these properties for convenient editing. var target_return_enabled = true var target_return_rate = 0.02 var min_zoom = 0.5 var max_zoom = 2 var zoom_sensitivity = 10 var zoom_speed = 0.05 var events = {} var last_drag_distance = 0 If a target is assigned, then the camera can follow and/or automatically return to it. The other properties that control how the camera works:\ntarget_return_enabled - If this is true, the camera will automatically return to the target after dragging. target_return_rate - Controls how fast the camera returns to its target. min_zoom / max_zoom - Limits how far you can zoom in/out. zoom_sensitivity - Sets how sensitive pinch-to-zoom will be - it’s the number of pixels’ movement needed to “start” a zoom. zoom_speed - Used to smooth the zooming. You can export these properties as well, if you’d like to be able to adjust them in the Inspector.\nThe other variables track the state of the camera. events is a dictionary that will hold the active touchscreen events, using the event’s index as its key. last_drag_distance keeps track of the distance between the two drag events in a “pinch” gesture.\nIn the _process() function, we’ll move the camera towards the target (if target return is enabled and there’s no touch event active).\nfunc _process(delta): if target and target_return_enabled and events.size() == 0: position = lerp(position, get_node(target).position, target_return_rate) This will allow us to pan the camera around and it will return to the player when we release the touch.\nNow we’re ready to start adding the gestures, starting with “pan”.\nPan Note You can test this gesture your computer by enabling “Emulate Touch From Mouse” in Project Settings -\u003e Input Devices -\u003e Pointing.\nJust like mouse or keyboard events, touch events extend InputEvent and follow the same input priority. We’ll use _unhandled_input() for processing so that other nodes, such as Control nodes, can process events first:\nfunc _unhandled_input(event): if event is InputEventScreenTouch: if event.pressed: events[event.index] = event else: events.erase(event.index) First we’re checking for a touch event (InputEventScreenTouch). We add the event to the events dictionary. The event’s index property is our dictionary’s key. We also remove the event if it’s not pressed, which means the touch has ended.\nNext, we need to handle a drag that comes after the touch:\nif event is InputEventScreenDrag: events[event.index] = event if events.size() == 1: position += event.relative.rotated(rotation) * zoom.x If we get a drag event, we also add to the dictionary. Note that this will be updating the value - index 0 was already there from the first touch event, for example, and has now become a drag event.\nIf there’s only one event active, then this must be a one-finger drag, and we can adjust our camera’s position accordingly. Note that we need to scale the movement based on the current zoom, or else our drag movement will be disproportionately large when zoomed in and small when zoomed out. Similarly, if the camera is rotated, that rotation should be applied to the relative value as well so that the drag moves the camera in the correct direction.\nHere’s an example captured directly from a mobile device. The yellow circle indicates the touch location.\nZoom Note You won’t be able to test this gesture on your computer because it requires 2 touch events, which the mouse can’t emulate.\nA “pinch” gesture will trigger the camera to zoom. This happens when we detect two drag events. If the drag events move toward each other, we’ll zoom in; away from each other, we’ll zoom out.\nif event is InputEventScreenDrag: events[event.index] = event if events.size() == 1: position += event.relative.rotated(rotation) * zoom.x elif events.size() == 2: var drag_distance = events[0].position.distance_to(events[1].position) if abs(drag_distance - last_drag_distance) \u003e zoom_sensitivity: var new_zoom = (1 + zoom_speed) if drag_distance \u003c last_drag_distance else (1 - zoom_speed) new_zoom = clamp(zoom.x * new_zoom, min_zoom, max_zoom) zoom = Vector2.ONE * new_zoom last_drag_distance = drag_distance Here we handle the case of 2 active drag events. drag_distance tells us how far apart they are, and we can compare it with last_drag_distance to see if it’s larger or smaller. zoom_speed is a factor, so we’ll be multiplying the zoom by 1.05 (for zooming in) and 0.95 (for zooming out). We can then clamp the resulting zoom so that it doesn’t exceed our designated limits, and then assign the new zoom level. Finally, we update last_drag_distance for the next event.\nWrapping up You can use this camera as a basis for your own camera needs. Here are some suggestions you can try to make yourself:\nUse lerp() to smooth the zooming. Automatically return zoom to default level. Double-tap to reset. Add more gestures -three fingers, etc. For completeness, here’s the full TouchCamera.gd script:\nextends Camera2D export (NodePath) var target var target_return_enabled = true var target_return_rate = 0.02 var min_zoom = 0.5 var max_zoom = 2 var zoom_sensitivity = 10 var zoom_speed = 0.05 var events = {} var last_drag_distance = 0 func _process(delta): if target and target_return_enabled and events.size() == 0: position = lerp(position, get_node(target).position, target_return_rate) func _unhandled_input(event): if event is InputEventScreenTouch: if event.pressed: events[event.index] = event else: events.erase(event.index) if event is InputEventScreenDrag: events[event.index] = event if events.size() == 1: position += event.relative.rotated(rotation) * zoom.x elif events.size() == 2: var drag_distance = events[0].position.distance_to(events[1].position) if abs(drag_distance - last_drag_distance) \u003e zoom_sensitivity: var new_zoom = (1 + zoom_speed) if drag_distance \u003c last_drag_distance else (1 - zoom_speed) new_zoom = clamp(zoom.x * new_zoom, min_zoom, max_zoom) zoom = Vector2.ONE * new_zoom last_drag_distance = drag_distance Note Download the project file here: 2d_touch_camera.zip\nRelated recipes Input: Input Actions Drag-select multiple units Like video? ","description":"","tags":null,"title":"Touchscreen Camera","uri":"/godot_recipes/3.x/2d/touchscreen_camera/"},{"content":"Problem You’d like to understand what is meant by dot product and cross product.\nSolution In this recipe we’ll introduce the concept of vector dot product and cross product and how they might be used.\nDot product Dot product is an operation on two vectors that returns a scalar. It is often visualized as the projection of vector A onto vector B:\nThis is the formula for calculating the dot product:\nWhere θ is the angle between the two vectors and ||A|| is the magnitude of A.\nThis is very useful when both vectors are normalized (i.e. their magnitudes are 1), then the formula simplifies to:\nThis shows that the dot product is directly related to the angle between the two vectors. Since cos(0) == 1 and cos(180) == -1, the result of the dot product can tell you how closely aligned two vectors are:\nSee below for how we can apply this fact in a practical example.\nCross product The cross product of two vectors is a third vector that is perpendicular to both of them. Its magnitude is related to their magnitudes and the angle between them.\nOnce again, if we’re using normalized vectors, the result is simplified: it will be directly related to the angle and its magnitude will range from -1 to 1.\nNote Since the cross product is perpendicular to both vectors, we would need to be working in 3D. In most 2D frameworks, including Godot, the 2D Vector2.cross() method returns a scalar value representing the result’s magnitude.\nPractical applications Consider this animation, showing how the results of Vector2.dot() and Vector2.cross() change in relation to the changing angle:\nThis demonstrates two common applications of these methods. If the red vector is our object’s forward direction, and the green shows the direction towards another object:\nDot product: Using the result, we can tell if the object is in front of (\u003e 0) or behind (\u003c 0) us. Cross product: Using the result, we can tell if the object is to the left (\u003e 0) or right (\u003c 0). ","description":"","tags":null,"title":"Vectors: Using Dot and Cross Product","uri":"/godot_recipes/3.x/math/dot_cross_product/"},{"content":"Problem You want to draw the trajectory of a ballistic shot, like from a tank.\nSolution Setup For this example, we’re using the “Ballistic Bullet” from this recipe:\nBallistic bullet and a tank set up like so, with a Position2D designating the “muzzle” where the bullet will be spawned:\nIn the tank’s script, we instance the bullet like so:\nfunc _unhandled_input(event): if event.is_action_released(\"shoot\") and can_shoot: var b = Bullet.instance() owner.add_child(b) b.transform = $Barrel/Muzzle.global_transform b.velocity = b.transform.x * muzzle_velocity b.gravity = gravity can_shoot = false This instances the bullet, adds it as a child to the “world” node (the tank’s owner) and sets its initial properties. Note that we’re using the tank to define gravity, but that’s just for this example - in a full project you would likely use a global value for this.\nHere’s our starting setup in action:\nLine setup In the main scene, which contains the tank and the ground, we’ve added a Line2D. This is what we’ll use to draw the trajectory.\nTo improve the line’s appearance, we’ve set the Width to 15 and all of the Capping options to “Round”. We’ve also added a Gradient in the Fill section:\nDrawing the line Now we’re ready to draw the line. The goal will be to move along the projected trajectory and add points to the line as we go. Since we know the starting velocity and the gravity that the bullet is using, we can use the same calculation.\nonready var tank = $Tank onready var muzzle = $Tank/Barrel/Muzzle onready var line = $Line2D var max_points = 250 func update_trajectory(delta): line.clear_points() var pos = muzzle.global_position var vel = muzzle.global_transform.x * tank.muzzle_velocity for i in max_points: line.add_point(pos) vel.y += tank.gravity * delta pos += vel * delta if pos.y \u003e $Ground.position.y - 25: break func _process(delta): if Input.is_action_pressed(\"shoot\"): line.show() update_trajectory(delta) func _on_Bullet_exploded(pos): tank.can_shoot = true line.hide() max_points sets the maximum number of points you want to add to the line. In the update_trajectory() function, we get the bullet’s starting position and velocity from the tank (remember, gravity is defined in the tank too, for this example). We then iterate through those points, moving the position each “step” by the same amount the bullet will move during one frame.\nWe’ve also added a break if the path contacts the position of the top of the ground, so that we don’t keep drawing in that case.\nFinally, we show/hide the line when shooting or not.\nRelated recipes 2D shooting recipe 2D ballistic bullet ","description":"","tags":null,"title":"Draw trajectory","uri":"/godot_recipes/3.x/2d/2d_draw_trajectory/"},{"content":"Problem You want a radial menu - a ring of buttons that pops up for you to choose an option.\nSolution Radial menus are used in a variety of games to allow access to a selection of buttons. For example, clicking on an NPC in a game allows you to choose what action to take: talk, inspect, attack, etc.\nThe specific look-and-feel of your menu should match with your game’s esthetic. For this demo, we’ll focus on the mechanics of making the menu work, and leave the styling choices to you.\nHere’s the node setup:\nWe’re using a TextureButton as our root node. This is the button you’ll click to open/close the menu.\nThe “Buttons” Control node is the container where you’ll place any number of items that you want. For this example, we’re using some buttons from our Cooldown Button recipe.\nFinally, we have a Tween to handle animating the menu opening/closing.\nNow, let’s look at the script for the button:\nextends TextureButton export var radius = 120 export var speed = 0.25 var num var active = false Here are our variables. radius represents the “size” of the menu: the radius of the circle. speed is for the animation - smaller numbers are faster.\nnum keeps track of how many buttons there are, while active is a flag to track whether the menu is open or closed.\nfunc _ready(): $Buttons.hide() num = $Buttons.get_child_count() for b in $Buttons.get_children(): b.rect_position = rect_position In _ready() we start setting things up: hiding the menu buttons by default, and setting their positions to that of the main button.\nNow connect the pressed signal of the main button, and the tween_all_completed signal of the Tween.\nfunc _on_StartButton_pressed(): disabled = true if active: hide_menu() else: show_menu() Clicking the button show/hides the menu. We also need to disable the button, or else clicking again while the tween is playing would restart it.\nfunc _on_Tween_tween_all_completed(): disabled = false active = not active if not active: $Buttons.hide() When the tween animation finishes, toggle the active state and enable the button again.\nLet’s look at the show_menu() function:\nfunc show_menu(): var spacing = TAU / num for b in $Buttons.get_children(): # Subtract PI/2 to align the first button to the top var a = spacing * b.get_position_in_parent() - PI / 2 var dest = b.rect_position + Vector2(radius, 0).rotated(a) $Tween.interpolate_property(b, \"rect_position\", b.rect_position, dest, speed, Tween.TRANS_BACK, Tween.EASE_OUT) $Tween.interpolate_property(b, \"rect_scale\", Vector2(0.5, 0.5), Vector2.ONE, speed, Tween.TRANS_LINEAR) $Buttons.show() $Tween.start() In this function we calculate the angle we need between each item (spacing). We then loop through each button and find its destination (dest) based on this angle and the chosen radius. For each button, we’re tweening two properties, rect_position and rect_scale, to get our desired effect.\nhide_menu() performs the exact opposite function:\nfunc hide_menu(): for b in $Buttons.get_children(): $Tween.interpolate_property(b, \"rect_position\", b.rect_position, rect_position, speed, Tween.TRANS_BACK, Tween.EASE_IN) $Tween.interpolate_property(b, \"rect_scale\", null, Vector2(0.5, 0.5), speed, Tween.TRANS_LINEAR) $Tween.start() Here’s the end result:\nNote Download the project file here: ui_radial_menu.zip\nRelated recipes UI: Cooldown Button ","description":"","tags":null,"title":"Radial Popup Menu","uri":"/godot_recipes/3.x/ui/radial_menu/"},{"content":"Problem You need your kinematic body to align with the surface or terrain.\nSolution This recipe builds on the basic KinematicBody controller described in the KinematicBody: Movement recipe, so read that one first.\nFirst, we’ve added some terrain to the scene. You can download the terrain from here: https://fertile-soil-productions.itch.io/modular-terrain-pack. This is low-poly terrain, but you can use or make any terrain you like for this technique.\nAs you can see, the movement still works with the terrain, but the tank seems to “float” above the slopes because it doesn’t change its orientation.\nInstead, we need to rotate the tank so that its treads are aligned with the ground, even as the slope changes. To do that, we need to know which way is up.\nSurface normals A surface normal is a unit vector (“normal vector” and “unit vector” mean the same thing) perpendicular to a surface. It shows which way the surface is facing. In the case of a mesh, every surface has a normal pointing outward.\nIn Godot, when a body collides, you can get the normal of the collision. This will be the colliding body’s normal at the point of contact.\nOnce we have the surface normal, we need to align the tank’s Y axis with it. Note that we can’t use Transform.looking_at(), because that will align the -Z (forward) axis with the normal.\nTo do this, we’ll use the following function:\nfunc align_with_y(xform, new_y): xform.basis.y = new_y xform.basis.x = -xform.basis.z.cross(new_y) xform.basis = xform.basis.orthonormalized() return xform Given a transform and a new Y direction vector, this function returns the transform rotated so that its basis.y is aligned with the given normal.\nNote If you’re unfamiliar with the cross product or other vector math, there’s a great vector math intro in the Godot Docs.\nWe can update the tank’s movement code to call this function when it collides with a surface:\nfunc _physics_process(delta): velocity += gravity * delta get_input(delta) velocity = move_and_slide_with_snap(velocity, Vector3.DOWN*2, Vector3.UP, true) for i in get_slide_count(): var c = get_slide_collision(i) global_transform = align_with_y(global_transform, c.normal) This doesn’t work quite as expected:\nThe problem is that the tank’s collision shape could be colliding with more than one of the terrain’s faces. Also, move_and_slide() can result in more than one collision in a single frame. This leads to the jittering. We need to choose one face and stick with it.\nAdd a RayCast child to the tank and set its Cast To to (0, -2, 0). Don’t forget to check the Enabled property.\nSince this raycast is pointing down from the exact center of the tank, we’ll align with the individual surface that it collides with - the one directly beneath the tank.\nfunc _physics_process(delta): velocity += gravity * delta get_input(delta) velocity = move_and_slide_with_snap(velocity, Vector3.DOWN*2, Vector3.UP, true) var n = $RayCast.get_collision_normal() global_transform = align_with_y(global_transform, n) This is much better, but because we are instantly snapping to the new alignment every time the tank crosses an edge, it still looks a little jarring:\nWe can solve this last problem by interpolating to the new transform rather than snapping immediately to it.\nfunc _physics_process(delta): velocity += gravity * delta get_input(delta) velocity = move_and_slide_with_snap(velocity, Vector3.DOWN*2, Vector3.UP, true) var n = $RayCast.get_collision_normal() var xform = align_with_y(global_transform, n) global_transform = global_transform.interpolate_with(xform, 0.2) The result is much smoother and more pleasing:\nFeel free to experiment with the interpolation amount. We found 0.2 to work well in this situation, but you might find a higher or lower value works better for you.\nRelated recipes KinematicBody: Movement Math: Interpolation Math: Transforms Like video? ","description":"","tags":null,"title":"KinematicBody: align with surface","uri":"/godot_recipes/3.x/3d/3d_align_surface/"},{"content":" Games Demo games and tutorials.\nIn this section: Mobile Game: Circle Jump ","description":"","tags":null,"title":"Game Tutorials","uri":"/godot_recipes/3.x/games/"},{"content":" \u0026nbsp 3D Car Making a 3D car using KinematicBody.\nIn this section: 3D Kinematic Car: Base 3D Kinematic Car: Traction/Drifting 3D Kinematic Car: Chase Camera 3D Kinematic Car: Slopes \u0026 Ramps ","description":"","tags":null,"title":"3D Kinematic Car","uri":"/godot_recipes/3.x/3d/kinematic_car/"},{"content":" Godot Recipes Godot’s nodes are your ingredients. What can you cook up?\nOn this site you’ll find a collection of solutions and examples to help you make whatever game system you need.\nGodot 4.0 Godot 4.0 is coming!\nBecause Godot 4 brings a lot of breaking changes, we’ve got a whole new set of Godot Recipes just for the newest version. You can click the ribbon in the top-right to toggle the version, or click the button below:\nGodot 4 Recipes Are you ready to learn game development? Whether it’s as a hobby or working towards your dream career, there’s never been a better time to get started. Modern programming languages and tools have made it easier than ever to build high-quality games and distribute them to the world. One of these tools is the Godot game engine. For beginners, it offers a friendly way to learn gamedev techniques. For experienced developers, it’s a powerful, customizable and open tool for bringing your visions to life.\nIf you’re new to Godot, you can start here: What is Godot?.\nHow to use this site Beginners If you’re new to game development, start with the “Godot 101: Basics” section. There you’ll find an introduction to the Godot application, and a step-by-step guide to creating your first project. There is a lot of material to absorb here. Don’t feel discouraged if you feel you don’t get it at first. Repetition is the key to learning complex topics; the more you work with Godot’s features, the more familiar and easy they will start to feel.\nInfo It’s assumed that you have at least some general programming experience. If you’re completely new to programming, click here for tips on how to get started.\nExperienced Developers If you’re an experienced developer and/or you’re familiar with other modern game engine(s), feel free to explore the menu on the left. You’ll find a number of useful guides and tutorials to show you how to do things the “Godot Way”. Code samples and example projects are available for all articles.\n","description":"","tags":null,"title":"Home","uri":"/godot_recipes/3.x/"},{"content":"In this tutorial, we’ll explore how inheritance works in Godot. You can use inheritance in Godot to reuse code and create powerful hierarchies of object and scenes in your game.\nWe’ll imagine we’re making a classic top-down RPG and use Godot’s inheritance capabilities to create two different kinds of characters in the game.\nIntroduction In object oriented programming (OOP), inheritance is a powerful tool. Put briefly, you can define a class that inherits from another class. An object created using the first class will contain the methods and member variables of the “master” class as well as its own.\nGodot is strongly object-oriented, and offers the opportunity to use inheritance not just with objects (scripts) but also with scenes.\nHere’s a preview of what we’re making:\nThe green character is controlled by the player, and the other characters are NPCs, walking around the tile-based map semi-randomly.\nProject setup In Project Settings create four new input actions called “left”, “right”, “up”, and “down” and assign each of them to the matching arrow key. We’ll be using those names as dictionary keys, so make sure to note the spelling and capitalization.\nSet the display Width and Height to 640 by 480 (we’re using 32x32 tiles, so we don’t need much screen space for this demo).\nDownload the art (character spritesheets) and unzip it in the project folder.\nCreating Characters Both kinds of characters share a number of properties and functions:\nA spritesheet containing the 4-directional movement animations An AnimationPlayer to play the movement animations Grid-based movement (the character can only move one full “square” at a time) Collision detection with walls We’ll start by creating a scene that will contain all of the above. Start with an Area2D and name it “Character”. Give it the following children:\nSprite CollisionShape2D Tween (named MoveTween) AnimationPlayer We’ll leave the Sprite without a texture for now, but in the Inspector set its Vframes and Hframes properties to 4 and 3 respectively.\nNext, create a RectangleShape2D in the collision shape and set its Extents property in the Inspector to (10, 18).\nNOTE: Because all the characters are drawn to the same scale, we can be confident that the same sized collision shape will work for all characters. If this isn’t the case with the art you’re using, you can skip setting the collision shape here and configure it later for the inherited scenes.\nAnimations Create four animations in the AnimationPlayer node. Name them to match the four directions we used in the input actions. For each animation, we’re going to set the length to 0.8 and add a track for the Sprite’s Frame property. The pattern for each direction is listed below. See the screenshot for an example of the end result.\ndirection frames left 9, 10, 11, 10 down 6, 7, 8, 7 right 3, 4, 5, 4 up 0, 1, 2, 1 Collision Detection Because the characters are moving on a grid, they will either move the full amount to the next tile or not at all. This means that before moving, the character needs to check if the move is possible. Add four RayCast2D nodes and set their names and Cast To properties as follows:\nName Cast To RayCastRight (32, 0) RayCastLeft (-32, 0) RayCastDown (0, 32) RayCastUp (0, -32) Make sure to set the Enabled property on each one (RayCast2Ds are disabled by default). Your final node setup should look something like this:\nCharacter Script Now add a script to the Character node (it will automatically be named “Character.gd”).\nFirst, we’ll define our class variables:\nextends Area2D var tile_size = 32 var can_move = true var facing = 'right' var moves = {'right': Vector2(1, 0), 'left': Vector2(-1, 0), 'up': Vector2(0, -1), 'down': Vector2(0, 1)} var raycasts = {'right': 'RayCastRight', 'left': 'RayCastLeft', 'up': 'RayCastUp', 'down': 'RayCastDown'} can_move is a flag that will track whether the character can move. It will be false while a movement is already underway. facing is the current direction of movement. Note that the moves and raycasts dictionaries’ keys match the input actions we created.\nNext is the code that will execute a movement from one square to another:\nfunc move(dir): if get_node(raycasts[facing]).is_colliding(): return facing = dir can_move = false $AnimationPlayer.play(facing) $MoveTween.interpolate_property(self, \"position\", position, position + moves[facing] * tile_size, 0.8, Tween.TRANS_SINE, Tween.EASE_IN_OUT) $MoveTween.start() return true We pass a direction to move(). If the RayCast2D for that direction detects a collision, the move is canceled. Otherwise, we change facing to that direction, disable movement, and start playing the matching animation. To actually execute the movement, we use the Tween node to interpolate the position property from its current value to its current value plus a 32-pixel movement in the given direction. The duration is set to 0.8 which matches the animation length.\nNote: See the Tween documentation for details on how the interpolate_property() method works.\nFinally, to enable movement again, we need to reset can_move when the movement has finished. Connect the tween_completed signal from MoveTween and add the following:\nfunc _on_MoveTween_tween_completed( object, key ): can_move = true Implementing the Player The player character needs to inherit all the properties we gave to Character as well as adding keyboard controlled movement.\nWe’ll start by making a new scene. However, instead of making a new empty scene, click on Scene -\u003e New Inherited Scene in the menu. Select the Character.tscn. Rename the root node from “Character” to “Player” and save the new scene.\nAll we need to do for the Sprite is set the texture, so choose a character you like from the “res://art/rpgsprites1” folder and drag it to the Texture property.\nNext, we need a new script for the player, so remove the attached one (“Character.gd”) and attach a new one. In the “Attach Node Script” dialog, click the folder icon next to the Inherits option and choose “Character.gd”.\nHere’s our player script (note that it extends the character script):\nextends \"res://Character.gd\" func _process(delta): if can_move: for dir in moves.keys(): if Input.is_action_pressed(dir): move(dir) Because we’ve inherited all the behavior from “Character.gd”, we only need to worry about control. Here, we’re using the _process() function to check the keystate each frame. However, only if can_move allows it do we actually check the keys and call move().\nRun the scene and try it out.\nNPC characters Hopefully you’re seeing how inheritance works by now, but let’s make another type of character: an NPC that will wander around the screen randomly. Make another scene inheriting from “Character.tscn” and name it NPC.\nThis time, leave the sprite’s Texture blank and add a new script, again inheriting from “Character.gd”.\nextends \"res://Character.gd\" var textures = ['mage_f.png', 'mage_m.png', 'healer_f.png', 'healer_m.png', 'townfolk1_f.png', 'townfolk1_m.png'] func _ready(): randomize() var texture = textures[randi() % textures.size()] texture = load(\"res://art/rpgsprites1/%s\" % texture) $Sprite.texture = texture facing = moves.keys()[randi() % 4] func _process(delta): if can_move: if not move(facing) or randi() % 10 \u003e 5: facing = moves.keys()[randi() % 4] This time, we’re using _ready() to select a random texture and assign it. We’re also choosing a random starting direction.\nAs with the player, we’ll use _process() to trigger the movement, but this time we’ll use the fact that the move() function returns true if it successfully executes (if the raycast detects an obstacle, it returns false). So if the NPC can’t move, it will pick a new random direction. For variety, we also add a 50% chance that it will change direction anyway.\nRun the scene and observe the NPC wandering randomly around the screen.\nTesting Collisions Finally, to confirm that the collision detection is working, let’s create a small scene for the characters to wander around in. We’ll use a TileMap to quickly draw our map.\nNote: See my Tilemap tutorial for details on using TileMaps in Godot.\nThere are two tiles (“grass.png” and “stone.png”) in the art folder. There is also a TileSet called “tiles.tres” to save you the step of making your own. In it, only the stone tile has a collision shape, so it will be our obstacle.\nCreate a new “Main” scene (I usually like to use a plain Node as the root). Add a TileMap and drag “tileset.tres” into its Tile Set property. Also don’t forget to change the Size to (32, 32).\nDraw some walls as you like, and then add a Player instance and a few instances of NPC. Remember, the characters won’t know anything about the map - they just know if they can move one tile or not. If you want them to line up properly, you need to make sure the characters’ starting positions are centered on a tile. This is easy to do if you turn on “Snap to Grid”. Click the “Use Snap” button and then open the grid menu by clicking on the three dots next to it:\nUnder “Configure Snap…” set the Grid Step and Grid Offset:\nNow you can drag the instanced characters around and they’ll always snap to the center of a tile.\nConclusion Imagine we had built this project without using inheritance. The Player and NPC would each have their own scene setup and individual scripts. If we decided to change how we wanted movement to work, we would have to change everything twice. If we added more character types (Monsters, Pets, etc.) the duplicated code would multiply and quickly become unmanageable. With the setup we created above, everything is in one place, and any change to the character automatically propagates to everything that extends it.\nAs you’re working on your own projects, look for opportunities to consolidate code and use inheritance for your scenes and/or scripts. As your projects grow in size and complexity, it will quickly become a lifesaver.\n","description":"","tags":null,"title":"Inheritance","uri":"/godot_recipes/3.x/recipes/godot3_inheritance/"},{"content":"","description":"","tags":null,"title":"Categories","uri":"/godot_recipes/3.x/categories/"},{"content":"Label Label is a Control node for displaying unformatted text, with options for controlling the text’s alignment, wrapping, etc.\nAPI Documentation\nNode properties See the documentation for the full list, but here we’ll review the most commonly used properties of the node:\ntext - this property is the contents of the label. Change this in code to change what the label displays. If you’re displaying numerical values, don’t forget to convert them to strings! For example, to update a label with a given numerical value: func update_label(value): $Label.text = str(value) align - this property allows you to align the text right/center/left.\npercent_visible - this property limits the number of characters displayed. For example setting 0.5 would show half of the contents. Try animating this value to create a “typewriter” effect.\nAdding a font As soon as you type something into the Text property, you’ll see that Godot’s default font is probably too small for your needs. Here’s how you can change the font:\nFirst, make sure you have a TTF or OTF font file in your project folder.\nIn the Label’s properties under “Custom Fonts”, choose “New DynamicFont”. DynamicFont is a Resource type that renders text from a given font.\nClick on the “DynamicFont” you added, and under “Font/Font Data”, choose “Load” and select your font file. You should also set the font’s Size.\n","description":"","tags":null,"title":"Label","uri":"/godot_recipes/3.x/kyn/label/"},{"content":"Path2D \u0026 PathFollow2D A path is a sequence of points in 2D space, defined by a Curve2D resource. The Path2D is a node that allows you to position a path in 2D space, and do create a new path in the editor.\nPaths have a variety of uses. You can make a patrol path for an enemy mob to follow, a winding path for an animated visual effect, a pattern for a moving platform to follow, etc.\nAbout Curve2D The data of the path is held in this Resource object. It contains the mathematical representation of the curve, and provides some ways to interact with that data. The API Documentation contains the details, but here are a few useful methods that you may want to use:\nadd_point() / remove_point() / clear_points() If you need to manipulate the path’s points in code, these functions will help you.\nget_closest_point() This method returns the closest of the path’s points to any given point in space.\nget_closest_offset() Distinct from the above, this method returns the position along the path that’s closest to the given point. Note that this may be in-between two of the path’s defined points.\ntesselate() This method returns a list of points along the curve. These points will be more densely packed in the parts of the path with a higher curvature.\nDrawing paths When you select a Path2D node, some new icons appear on the icon bar:\nSelecting one of these icons changes the behavior of the mouse cursor. You can hover over them to see their names.\nSelect Points - Lets you move existing points by clicking and dragging. Select Control Points - Adds control handles to a point, allowing you to adjust the curve (see below). Add Point - Add a point by clicking in empty space. Delete Point - Click to delete a point. Close Curve - Connects the last point in the curve to the first one, creating a loop. Select “Add Point” and click in the editor window to create points.\nTo create a smoother, rounded curve, select “Select Control Points” and drag any of the points in the curve to adjust their “in” and “out” handles:\nFollowing a path By itself, a Path2D doesn’t have much functionality. In order to move along the path, you need to use a PathFollow2D node as well. This is a node whose function is to move along a parent Path2D.\nMost useful properties:\noffset and unit_offset - these properties represent the distance along the path relative to the beginning. offset is measured in pixels while unit_offset is a percentage (eg 0 is the start, .5 is halfway, 1.0 is the end)\nrotate - this boolean determines whether the node should rotate as it moves along the path.\nloop - if this boolean is true, then offsets greater than the path length will “wrap around”. Use this if you want a repeatable path.\nFor example, consider this plane moving along a path (you can make the path visible by setting Debug\u003eVisible Navigation):\nThis is done by making the plane Sprite a child of the PathFollow2D and adding the following to _process():\nfunc _process(delta): $Path2D/PathFollow2D.offset += 250 * delta As the offset is increased, the node moves along the path.\nNote the Rotate property of PathFollow2D which keeps the node (and therefore its children) rotated to point along the path as it moves.\nExample Find path direction Consider this example, from the AI: Context-based Steering recipe:\nIn this example, the AI agents avoid walls and each other, but also “want” to continue along the track in the correct direction. There is a Path2D drawn along the track, and the agents query it to find out what direction it’s pointing:\nfunc get_path_direction(pos): var offset = $Path2D.curve.get_closest_offset(pos) $Path2D/PathFollow2D.offset = offset return $Path2D/PathFollow2D.transform.x At any given point along the path, the PathFollow2D’s forward direction (transform.x) points along the path.\n","description":"","tags":null,"title":"Path2D \u0026 PathFollow2D","uri":"/godot_recipes/3.x/kyn/path2d/"},{"content":"RayCast2D Raycasting is a common technique in game development. “Casting a ray” means extending a line from a point until it collides with something or reaches its limit.\nNode properties Add a RayCast2D node and take a look at the Inspector:\nHere are the main properties you’ll need to understand:\nEnabled Turn this on to make the raycast work. This property is disabled by default!\nExclude Parent This property causes the ray to ignore collisions with the parent object. Enabled by default.\nCast To This is the destination point of the ray. Note: This is in local coordinates.\nAlso, take note of the Collide With section. By default the ray will only detect bodies, so you’ll need to go here if you want to detect areas as well or instead.\nUseful functions You can see the full list of the node’s functions in the API Documentation. Here are the some of the most useful ones:\nis_colliding() Boolean function, lets you know if the ray is colliding with something.\nget_collision_point() If the ray is colliding, this will return the position of the collision (in global coordinates).\nget_collider() If the ray is colliding, this function will return a reference to the colliding object.\nget_collision_normal() Another useful piece of information, this is the normal of the collided object at the point of collision.\nExample uses There are many uses for raycasts: visibility (can A see B, or is there an obstacle between?), proximity (am I close to a wall/ground/obstacle?), etc. Here are a couple of practical examples in use:\n1. Shooting Fast-moving projectiles often have the problem of “tunneling” through obstacles - they are moving too fast for the collision to be detected in a single frame. As an alternative, you can use a Raycast2D to represent the path (or a laser, etc.).\nHere’s a player sprite with a raycast attached to the end of the gun. The cast_to is set to (250, 0).\nWhen the player shoots, you check to see if the ray is colliding with something:\nfunc _input(event): if event.is_action_pressed(\"shoot\"): if $RayCast2D.is_colliding(): print($RayCast2D.get_collider().name) 2. Edge detection Consider a platformer enemy that walks on platforms, but you don’t want it to fall off the edges. Add two downward-pointing raycasts to the mob like so:\nIn the mob’s script, check for when the ray stops colliding. That means you’ve found the edge and should turn around:\nfunc _physics_process(delta): velocity.y += gravity * delta if not $RayRight.is_colliding(): dir = -1 if not $RayLeft.is_colliding(): dir = 1 velocity.x = dir * speed $AnimatedSprite.flip_h = velocity.x \u003e 0 velocity = move_and_slide(velocity, Vector2.UP) Here’s what it looks like in action:\n","description":"","tags":null,"title":"RayCast2D","uri":"/godot_recipes/3.x/kyn/raycast2d/"},{"content":"RigidBody2D RigidBody2D is the physics body in Godot that provides simulated physics. This means that you don’t control a RigidBody2Ddirectly. Instead you apply forces to it (gravity, impulses, etc.) and Godot’s built-in physics engine calculates the resulting movement, including collisions, bouncing, rotating, etc.\nWarning Setting a RigidBody2D’s physical properties, such as position or linear_velocity directly will not work correctly. The physics engine controls these values.\nThe body’s behavior is also affected by the world, via the Project Settings -\u003e Physics properties, or by entering an Area2D that is overriding the global physics properties.\nWhen used properly, rigid bodies are a powerful tool in your Godot toolkit. Many users get in trouble, however, when they use them for the wrong purposes, or fail to understand exactly how they work.\nAPI Documentation\nNode properties Here are the main properties you’ll need to understand:\nMode (mode) A rigid body can be in one of four modes, which affect its behavior:\nRigid - This is the default mode. The body behaves like a solid physical object, colliding and responding to forces. Static - In this mode, the body does not move, similar to a StaticBody2D. Character - In this mode, the body acts the same as in rigid mode, but does not rotate. Kinematic - In this mode, the body behaves like a KinematicBody2D, meaning it can only move via code. NOTE: This does not mean that it gains KinematicBody2D helper functions such as move_and_slide(). All movement and collision response must be done manually. Gravity Scale (gravity_scale) This value multiplies the gravity applied to the body. Total gravity is the sum of the “Default Gravity” value from Project Settings and any additional gravity that may applied by Area2D nodes.\nApplied Force (applied_force) Using this value you can get or set the total force applied to the body.\nApplied Torque (‘applied_torque`) Using this value you can get or set the total torque applied to the body.\nContinuous CD (continuous_cd) If your fast-moving body is tunneling through objects, you might need to enable this. Continuous collision detection tries to predict collisions by moving the body continuously along its path, rather than moving and then checking for any collisions. It is more accurate but slower, so use with caution.\nUseful functions To add force to a rigid body, you have two functions to choose from:\nadd_force() / add_central_force() Adds a continuous force to the body. Imagine a rocket’s thrust, steadily pushing it faster and faster. Note that this adds to any already existing forces. The force continues to be applied until removed.\napply_impulse() / apply_central_impulse() Adds an instantaneous “kick” to the body. Imagine hitting a baseball with a bat.\n_integrate_forces() Collision detection By default, while a RigidBody2D collides and interacts with other bodies in the space, it does not report those collisions.\nIf you want to get collision information from a rigid body, you must set contact_monitor to true, which enables signals such as body_entered. You can also adjust contacts_reported to set the number of collisions that will be reported.\nControlling Rigid Bodies There are cases where you need more direct control of a rigid body. For example, imagine you’re trying to make a version of the classic game “Asteroids”. The player’s spaceship needs to rotate using the left/right arrow keys, and to move forward when the up arrow is pressed.\nBy default, there is some damping (set in Project Settings), which reduces a body’s velocity and spin. In space there’s no friction, so there shouldn’t be and damping at all. However, for the “Asteroids” feel, we want the ship to coast to a stop and to stop rotating when we let go of the keys. To do that, we set the ship’s Angular/Damp to 5 and Linear/Damp to 1 in the Inspector.\nHere’s the code:\nextends RigidBody2D export var engine_thrust = 500 export var spin_thrust = 15000 var thrust = Vector2() var rotation_dir = 0 var screensize func _ready(): screensize = get_viewport().get_visible_rect().size func get_input(): if Input.is_action_pressed(\"ui_up\"): thrust = transform.x * engine_thrust else: thrust = Vector2() rotation_dir = 0 if Input.is_action_pressed(\"ui_right\"): rotation_dir += 1 if Input.is_action_pressed(\"ui_left\"): rotation_dir -= 1 func _process(delta): get_input() func _physics_process(delta): applied_force = thrust applied_torque = rotation_dir * spin_thrust Let’s walk through what this script is doing. The two variables, engine_thrust and spin_thrust control how fast the ship can accelerate and turn. thrust will represent the ship’s engine state: (0, 0) when coasting, or a vector with the length of engine_thrust when powered on. rotation_dir will represent what direction the ship is turning. The screensize variable will capture the size of the screen, which we’ll be using later.\nNext, the input() function captures the keystates and sets the ship’s thrust on or off, and the rotation direction (rotation_dir) positive or negative. This function is called every frame in _process().\nFinally, physics-related functions should be called in _physics_process(). Here we set applied_force to apply the thrust in whatever direction the ship is facing. Then we set applied_torque to cause the ship to rotate.\nPlay the scene - you should be able to fly around freely:\nThe Position Problem Another feature of “Asteroids” is that the screen “wraps around”. If the player goes off one side, it teleports to the other side. But we already talked above about how you can’t change a rigid body’s position without breaking the physics engine. This presents a huge problem when working with rigid bodies.\nYou could try to do something like this:\nfunc _physics_process(delta): if position.x \u003e screensize.x: position.x = 0 if position.x \u003c 0: position.x = screensize.x if position.y \u003e screensize.y: position.y = 0 if position.y \u003c 0: position.y = screensize.y applied_force = thrust applied_torque = rotation_dir * spin_thrust However, it will fail spectacularly, getting stuck on the edges of the screen.\nTo quote the RigidBody2D documentation:\nYou should not change a RigidBody2D’s position or linear_velocity every frame or even very often. If you need to directly affect the body’s state, use _integrate_forces, which allows you to directly access the physics state.\nSo the answer is to use _integrate_forces() instead of _physics_process(), because in that function you are able to safely modify the body’s Physics2DDirectBodyState. I highly recommend you take a look at the linked document; there is a lot of really useful data provided in the physics state object. For our purposes, the key piece of information is the body’s Transform2D.\nSo, we change to _integrate_forces() and write the code as follows:\nfunc _integrate_forces(state): applied_force = thrust applied_torque = rotation_dir * spin_thrust if position.x \u003e screensize.x: state.transform.origin.x = 0 if position.x \u003c 0: state.transform.origin.x = screensize.x if position.y \u003e screensize.y: state.transform.origin.y = 0 if position.y \u003c 0: state.transform.origin.y = screensize.y By adjusting the body’s transform using the physics state, the engine stays happy, and everything works as expected:\n","description":"","tags":[],"title":"RigidBody2D","uri":"/godot_recipes/3.x/kyn/rigidbody2d/"},{"content":"","description":"","tags":null,"title":"Tags","uri":"/godot_recipes/3.x/tags/"},{"content":"YSort Many 2D games use a “3/4 view” perspective, giving the impression that the camera is looking at the world at an angle. However, to make this art style work, objects that are “farther” away should be rendered behind “nearer” objects. In practice, we want to “y sort”, or make the drawing order tied to the object’s y coordinate: the higher on the screen, the farther away and therefore the lower the render order.\nHere’s an example of the problem:\nThese objects are being drawn in the default render order: tree order. They are arranged like this in the scene tree:\nChanging the render order The YSort node changes the draw order of its children to use each object’s y coordinate. Lower values of y (ie higher on the screen) get rendered first.\nHere are the same objects placed under a YSort node:\nHowever, there is still a problem:\nThe draw order is based on the object’s y coordinate. By default, for most objects this is the center:\nWe can solve this by offsetting the sprite so that the object’s position is aligned with the bottom of the sprite - the feet of the character, for example:\nNow things look a lot better:\nYSort and TileMap A TileMap can perform the same function on its children if you enable the cell_y_sort property.\n","description":"","tags":null,"title":"YSort","uri":"/godot_recipes/3.x/kyn/ysort/"}]
[
{
	"uri": "http://kidscancode.org/godot_recipes/basics/start/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started Have you downloaded Godot yet? You can get it here: https://godotengine.org\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/3d/101_3d_01/",
	"title": "The 3D Editor",
	"tags": [],
	"description": "",
	"content": " In this tutorial, we\u0026rsquo;ll look at how to start working in 3D in Godot. You\u0026rsquo;ll learn how to navigate in the 3D editor, how to create and manipulate 3D objects, and how to work with some of Godot\u0026rsquo;s essential 3D nodes, such as cameras and lighting.\nAre you ready? A word of warning: 3D development can be quite a bit more complex than working in 2D. While many of the same principles apply - such as working with nodes, writing scripts, and handling logic/data - 3D brings with it a number of other considerations. For this reason, it\u0026rsquo;s a good idea to stick to 2D for your first few projects, moving to 3D once you have a good understanding of the game development process. This tutorial will assume you have completed at least an introductory Godot 2D project, such as the one in the official Godot tutorial.\nGetting Started in 3D One of Godot\u0026rsquo;s strengths is its ability to handle both 2D and 3D games. While much of what you\u0026rsquo;ve learned working on 2D projects (nodes, scenes, signals, etc.) applies equally well in 3D, there is also a whole new layer of complexity and capabilities. First, you\u0026rsquo;ll find that there are some additional features available in the 3D editor window, so we\u0026rsquo;ll start there:\nOrienting in 3D Space When you first open a new project in Godot, you will see the 3D project view:\n 3D view   -- The first thing you should notice is the three colored lines in the center. These are the x (red), y (green), and z (blue) axes. The point where they meet is the origin, which has the coordinates (0, 0, 0). You\u0026rsquo;ll find that this color scheme will also apply elsewhere in the Inspector.\nDifferent 3D applications follow different conventions for orientation. Godot uses Y-Up orientation, so that when looking at the axes, if x is pointing to the left/right, then y is up/down, and z is forward/back. Some other popular 3D software uses Z-UP. It\u0026rsquo;s good to keep this in mind when moving between applications.\n Navigation in 3D is performed using the mouse and keyboard. Here are the basic controls for the view camera:\n Mousewheel up/down: zoom in/out Middle button + drag: orbit camera around current target Shift + middle button + drag: pan camera Right-click + drag: rotate camera in place  In addition, if you\u0026rsquo;re familiar with popular 3D games, you might prefer Freelook mode, which you can toggle on/off using Shift+F. In this mode, you can use the WASD keys to fly around the scene while aiming with the mouse.\nYou can also alter the camera\u0026rsquo;s view by clicking on the [Perspective] label in the upper-left corner. Here, you can snap the camera to a particular orientation.\nAdding 3D Objects Now let\u0026rsquo;s add our first 3D node. Just as all 2D nodes inherit from Node2D, which provides properties such as position and rotation, 3D nodes inherit from Spatial. Add one to your scene and you\u0026rsquo;ll see the following object appear at the origin:\nThis object is not the node. It is something called a 3D gizmo. Gizmos are tools that allow you to move and rotate objects in space. The three rings control rotation, while the three arrows move (translate) the object along the three axes. Note that the rings and arrows are color-coded to match the axis colors.\nTake a few minutes to experiment and get familiar with the gizmo. Use Undo if you find yourself getting lost.\nSometimes you may feel the gizmos are getting in your way. You can click on the mode icons to restrict yourself to only one type of transformation: move, rotate, or scale:  Global vs. Local Space By default, the gizmo controls operate in global space. When you rotate the object, the gizmo\u0026rsquo;s arrows still point along the axes. However, if you click the \u0026ldquo;Local Space Mode\u0026rdquo; button, the gizmo will switch to moving the body in local space.\nNow when you rotate the object, the gizmo arrows point along the object\u0026rsquo;s axes and not the world\u0026rsquo;s. Switching back and forth between Local and World space can make it much easier to place an object exactly where you want it.\nTransforms Look at the Inspector for the Spatial node. Instead of a Position property, you have Translation, as well as Rotation Degrees, and Scale. Drag the object around with the gizmo and observe how these values change.\nYou\u0026rsquo;ll also find a Transform property, which changes as you move the object. A transform is a matrix that describes an object\u0026rsquo;s translation, rotation, and scale all in one. The math behind transforms can get quite complex - you\u0026rsquo;ll start working with them in a later tutorial.\nMeshes Just like a Node2D, a Spatial has no size or appearance of its own. In 2D, you would use a Sprite to add a texture to the node. In 3D, you need to add a mesh. A mesh is a mathematical description of a shape. It consists of a collection of points, called vertices. These vertices are connected by lines, called edges, and multiple edges (at least three) together make a face.\nFor example, a cube is made up of 8 vertices, 12 edges, and 6 faces.\nAdding Meshes Typically, meshes are created by using 3D modeling software, such as Blender. You can also find many collections of 3D models available for download, if you\u0026rsquo;re unable to create your own. However, often you just need a basic shape such as a cube or sphere. In this case, Godot provides a way to create simple meshes called primitives.\nAdd a MeshInstance node as a child of the Spatial and in the Inspector, click its Mesh property:\nHere you can see the list of available primitives. They represent a handy collection of common useful shapes. Select \u0026ldquo;New CubeMesh\u0026rdquo; and you\u0026rsquo;ll see a plain cube appear on the screen. Note that the cube is white by default, although it may appear slightly blue on your screen due to the default ambient lighting. We\u0026rsquo;ll talk about lighting a little bit later.\nCameras Try running the scene with your cube object. Did you see anything? In 3D, you won\u0026rsquo;t see anything in the game viewport without adding a Camera. Add one and use the camera\u0026rsquo;s gizmo to position it pointing towards the cube:\nThe pinkish-purple pyramid shape on the camera is called the fustrum and represents the camera\u0026rsquo;s view. Notice the small triangular arrow which represents the camera\u0026rsquo;s \u0026ldquo;up\u0026rdquo; orientation. As you\u0026rsquo;re moving the camera around, try pressing the \u0026ldquo;Preview\u0026rdquo; button in the upper-left to see what the camera sees. Play the scene to verify everything is working as expected.\nWrapping Up In this tutorial you learned how to use Godot\u0026rsquo;s 3D editor, how to add 3D nodes such as Spatial, MeshInstance, and Camera, and how to use gizmos to place your objects. You also learned a bunch of new terminology. Hopefully you\u0026rsquo;re not overwhelmed.\nIn the next part, we\u0026rsquo;ll look at how to build a 3D scene by importing 3D assets and how to use more of Godot\u0026rsquo;s 3D nodes.\nYou can also find a video version of this lesson here:\n    --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/start/101_01/",
	"title": "What is Godot?",
	"tags": [],
	"description": "",
	"content": " Game Engines Game development is complex and involves a wide variety of knowledge and skills. In order to build a modern game, you need a lot of underlying technology before you can make the actual game itself. Imagine if you had to build your own computer and write your own operating system before you could even start programming. Game development would be a lot like that if you truly had to start from scratch and build everything you needed.\nIn addition, there are a number of common needs every game has. For example, no matter what your game is, it\u0026rsquo;s going to need to draw things on the screen. If the code to do that has already been written, it makes more sense to reuse it that to create it all over again for every game. This is where game engines come in.\nA game engine is a collection of tools and technologies designed to assist in developing games. This allows you to focus more on building your game, and less on reinventing the wheel. Here are some of the features a good game engine will provide:\n Rendering (2D/3D)  \u0026ldquo;Rendering\u0026rdquo; is the process of displaying your game on the player\u0026rsquo;s screen. A good rendering pipeline needs to work with modern GPU features, high resolution displays, and effects like lighting and perspective, while maintaining a high frame rate.\n Physics  Building an accurate and usable physics engine is an enormous task. Most games require some sort of collision detection and response, and many need simulated physics (ie. friction, inertia, etc.), but few developers want to take on the task of writing one.\n Platform Support  In today\u0026rsquo;s market, you want to be able to release your game on multiple platforms, such as mobile, web, PC, and/or console. A game engine lets you build your game once and export it to one or more platforms.\n Development Environment  All of these tools are brought together in a single application, combining everything into one environment so you don\u0026rsquo;t have to learn a new workflow for every new project.\nThere are dozens of popular game engines to choose from today, such as Unity, Unreal, and GameMaker Studio, to name a few. It is important to remember that the majority of popular engines are commercial products. They may or may not be free to download, but the will require some kind of licensing or royalty agreement if you plan to release your game (and especially if your game makes money). You need to carefully read and understand what you\u0026rsquo;re agreeing to and what you are and are not allowed to do with the engine.\nWhy use Godot?  Click here to download Godot.\nIn contrast to the above, Godot is completely free and open source, released under the very permissive MIT license. This means there are no fees, hidden costs, or royalties you need to pay. This is in addition to being a fully featured modern game engine.\nAs a developer, the benefits are great. Because it\u0026rsquo;s unencumbered by commercial licensing, you have complete control over exactly how and where your game is distributed. In addition, Godot\u0026rsquo;s open source nature also means there is a much greater level of transparency than you\u0026rsquo;ll find with commercial engines. For example, if you find a particular feature doesn\u0026rsquo;t quite meet your needs, you\u0026rsquo;re free to modify the engine itself - no permission required.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/",
	"title": "Godot 101",
	"tags": [],
	"description": "",
	"content": "  Godot 101 Your introduction to the Godot game engine. If you\u0026rsquo;ve never used a game engine before, or if you’re just new to Godot, this is the place to start.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/splitscreen_demo/",
	"title": "Splitscreen Demo (Using Viewports)",
	"tags": [],
	"description": "",
	"content": " Introduction In this demo, we\u0026rsquo;ll consider a local multiplayer game - a topdown-style maze game with two players (one using arrow keys and the other using WASD controls). This is not a problem if our game world all fits on one screen, but if the map is large, we\u0026rsquo;ll want to have a \u0026ldquo;split screen\u0026rdquo; view tracking the two players separately.\nWe\u0026rsquo;ll also look at a quick way to set up a minimap display.\nGame setup We won\u0026rsquo;t spend a lot of time on the setup of the game world. The two players are KinematicBody2D objects using no-frills 8-way movement.\nIf you need help setting up this part, see the following section in the official Godot docs: 2D Movement Overview.\n Each player has its input actions set up in the Project Settings -\u0026gt; Input Map section: \u0026ldquo;right_1\u0026rdquo; to Right Arrow, \u0026ldquo;right_2\u0026rdquo; to D, etc. Note that by naming them this way, we can save time in the code by using:\nexport var id = 0 func get_input(): velocity = Vector2() if Input.is_action_pressed(\u0026#39;right_%s\u0026#39; % id): velocity.x += 1 # etc. This way both characters can use the same script for movement. Just assign the appropriate value to id for each player.\nThe two players are added to a \u0026ldquo;World\u0026rdquo; scene containing a TileMap:\nIf you like, you can download the starting project, with the world already set up, here:\nsplitscreen_start.zip\nNote that the map is much larger than the game screen, but aside from that everything works as intended. Setting up your game \u0026ldquo;world\u0026rdquo; separately like this will make setting up the viewports much easier and more flexible.\nViewports, Cameras, and Worlds We\u0026rsquo;re going to start with a new scene that\u0026rsquo;s going to contain our two viewports. Create a node to serve as the root. I like to use Node since it has no properties of its own - it\u0026rsquo;s just there to contain the rest of the scene.\nBy themselves, Viewport nodes don\u0026rsquo;t have position information (they don\u0026rsquo;t inherit from Spatial or CanvasItem). We\u0026rsquo;re going to use ViewportContainer, a Control node, to hold each viewport. To keep them arranged side-by-side, we\u0026rsquo;ll use an HBoxContainer.\nSet the HBoxContainer\u0026rsquo;s Alignment to \u0026ldquo;Center\u0026rdquo; and to have a small gap between the two viewports, set Custom Constants/Separation to 5. In the \u0026ldquo;Layout\u0026rdquo; menu, choose \u0026ldquo;Full Rect\u0026rdquo;.\nNow add two ViewportContainers as children, naming them with a 2 and 1 (to match the player they\u0026rsquo;ll display). Set the Size Flags on both to \u0026ldquo;Fill, Expand\u0026rdquo; so that they will each expand to fill half of the screen. Also, check the Stretch property so that the Viewport will automatically be set to the size of the container.\nInside each of these containers add a Viewport. Note that if you set the viewport\u0026rsquo;s Size property, it will be reset by the container.\nIn order for a Viewport to display anything, we\u0026rsquo;ll need a Camera2D which will render onto the Viewport. Add one to each viewport. Don\u0026rsquo;t forget to check the Current property to activate the camera. We can also set each camera\u0026rsquo;s Zoom to (0.75, 0.75) to get a better view of the area around the player.\nYour node setup should look like this:\n┖╴Main (Node) ┖╴Viewports (HBoxContainer) ┠╴ViewportContainer2 ┃ ┖╴Viewport2 ┃ ┖╴Camera2D ┖╴ViewportContainer1 ┖╴Viewport1 ┖╴Camera2D Note that we\u0026rsquo;ve put ViewportContainer1 second in the HBoxContainer. This will place it on the right side since Player 1 uses the arrow keys.\n Adding the World When we run the scene we won\u0026rsquo;t see anything because the viewports don\u0026rsquo;t have any \u0026ldquo;world\u0026rdquo; to render. A viewport\u0026rsquo;s world (for 3D) or world_2d property represent the source for the viewport\u0026rsquo;s environment and determine what will be rendered by its camera. The world can be set in code, but for 2D it will also display any child 2D nodes we add to it.\nLet\u0026rsquo;s instance the \u0026ldquo;World\u0026rdquo; scene as a child of Viewport1. Now when we play the scene we see the world inside the left viewport.\nWe also need to add a world to Viewport2, but we want it to use the same one. We can handle this in code. Attach a script to Main and add the following:\nextends Node onready var viewport1 = $Viewports/ViewportContainer1/Viewport1 onready var viewport2 = $Viewports/ViewportContainer2/Viewport2 onready var camera1 = $Viewports/ViewportContainer1/Viewport1/Camera2D onready var camera2 = $Viewports/ViewportContainer2/Viewport2/Camera2D onready var world = $Viewports/ViewportContainer1/Viewport1/World func _ready(): viewport2.world_2d = viewport1.world_2d The onready node references are for convenience - we\u0026rsquo;ll be using them as we move forward. Remember that when you type \u0026ldquo;$\u0026rdquo; Godot will autosuggest node paths so you don\u0026rsquo;t have to type them. You can also drag a node from the scene tree into the script editor and you\u0026rsquo;ll get the node\u0026rsquo;s path.\nWhen we run the scene now, we see the world rendered in both viewports. However, neither camera is moving so we only see a small part of the world.\nSetting up the cameras Attach the following script to each camera:\nextends Camera2D var target = null func _physics_process(delta): if target: position = target.position Now we can assign a target to each camera and it will follow that node\u0026rsquo;s position. We\u0026rsquo;ll do that in the Main script:\nfunc _ready(): viewport2.world_2d = viewport1.world_2d camera1.target = world.get_node(\u0026#34;Player_1\u0026#34;) camera2.target = world.get_node(\u0026#34;Player_2\u0026#34;) When we run the scene now, each player is centered in its viewport and our splitscreen setup works!\nI find it looks best if you disable the Drag Margin properties of the cameras.\n Camera limits Next, let\u0026rsquo;s add some limits to the player cameras so that they don\u0026rsquo;t scroll outside the bounds of the map. Add this function to the main script and call it in _ready():\nfunc set_camera_limits(): var map_limits = world.get_used_rect() var map_cellsize = world.cell_size for cam in [camera1, camera2]: cam.limit_left = map_limits.position.x * map_cellsize.x cam.limit_right = map_limits.end.x * map_cellsize.x cam.limit_top = map_limits.position.y * map_cellsize.y cam.limit_bottom = map_limits.end.y * map_cellsize.y Minimap Let\u0026rsquo;s add one more fun feature: a minimap showing a zoomed-out view of the entire map so the players can orient themselves.\nWe\u0026rsquo;ll need another ViewportContainer, this one a child of Main. This time, we don\u0026rsquo;t want to use Stretch. Add a Viewport and set its Size to (340, 200) then add a Camera2D. We\u0026rsquo;ll set the Camera2D\u0026rsquo;s Position to (512, 300) to center it on the screen. We\u0026rsquo;ll zoom out by setting Zoom to (9, 9). Don\u0026rsquo;t forget to click Current on this camera as well.\nIn the _ready(), set the minimap to use the same world as the other two viewports:\n$Minimap/Viewport.world_2d = viewport1.world_2d Use the \u0026ldquo;Layout\u0026rdquo; menu to align the Minimap container at \u0026ldquo;Center Bottom\u0026rdquo;. Let\u0026rsquo;s see what it looks like:\nWe need to get rid of that grey area around the edges. We could find the precise zoom level that matches our desired minimap size, but instead, we\u0026rsquo;ll check the Transparent Bg on the Viewport. Now our non-map areas aren\u0026rsquo;t visible and the minimap appears floating directly on top of the main viewports.\nConclusion Viewports can be very powerful, but also confusing. One way of managing them is to try to keep them separate from the game logic and only use them as displays.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_01/",
	"title": "Project setup",
	"tags": [],
	"description": "",
	"content": " Where to start? Depending on the game, and how fleshed-out your idea is, the answer might be very different. In our case, I\u0026rsquo;ve cheated a little bit by making a prototype of the game already and working out a few of the ideas ahead of time. Still, it diverged a bit from my initial idea, and so might this series - time will tell.\nIn a bigger project, you might start with design document, which could be as simple as a page of notes or as complex as a 500-page treatise laying out every detail of your game\u0026rsquo;s world, plot, and mechanics. We\u0026rsquo;ve no need of anything so involved here, so let\u0026rsquo;s just go over the gameplan.\nGameplan In this game, the player controls a \u0026ldquo;character\u0026rdquo; that jumps from circle to circle. Jumping is initiated by a click or touch, and if you don\u0026rsquo;t hit another circle, you lose. The score is related to how long you survive, and the difficulty will increase over time with circles that move, shrink, and/or expire. The idea is fast-paced, short games with a \u0026ldquo;top that\u0026rdquo; feel. As much as possible, the art will remain simple and clean, with visual and audio effects to add appeal.\nWe\u0026rsquo;ll be using GLES 3 to start. It\u0026rsquo;s not yet clear what if any impact this will have. Once we get to the mobile testing phase, we\u0026rsquo;ll see if a switch to GLES 2 is warranted.\n You can also follow this project on  Github.\nGetting started Let\u0026rsquo;s start with the project settings. We need to define our screen size/ behavior. We want this to be a mobile game so it\u0026rsquo;s going to need to be portrait mode and able to adjust to variable screen sizes, since there are so many phone resolutions available.\nOpen Project Settings and find the Display/Window section. Set the screen size to (480, 854), the Handheld/Orientation to \u0026ldquo;Portrait\u0026rdquo;, the Stretch/Mode to \u0026ldquo;2d\u0026rdquo;, and the Stretch/Aspect to \u0026ldquo;Keep\u0026rdquo;.\nNext, in Input Devices/Pointing enable \u0026ldquo;Emulate Touch From Mouse\u0026rdquo;. This will let us write the code only using screen touch events, but still play by using the mouse on PC platforms.\nProject organization To keep things organized, we\u0026rsquo;re going to make a folder to hold the game objects (objects) and one for UI (gui). The game assets (images, audio, etc.) will go in an assets folder. You can download the starting assets here:\n  Attachments   circle_jump_assets.zip  (1596 ko)    Once we have the folders and the assets set up, we\u0026rsquo;re ready to start coding!\nGame Objects We have two game objects to make: the player (\u0026ldquo;jumper\u0026rdquo;) and the circle.\nJumper For movement and collision, we\u0026rsquo;re going to use a Area2D. To be fair, we could use KinematicBody2D here too, and it would work just as well. However, we don\u0026rsquo;t really need collision in this game, we just need to know when the jumper contacts a circle. Let\u0026rsquo;s add the following nodes:\n Area2D (\u0026ldquo;Jumper\u0026rdquo;)  Sprite CollisionPolygon2D VisibilityNotifier2D   Save the scene in res://objects/ and drag the circle image (res://assets/images/jumper.png) into the Sprite\u0026rsquo;s Texture. Note that all the game images are flat white. This will make it easier for us to dynamically color them later.\nSince the art is drawn pointing upwards, set the Sprite\u0026rsquo;s Rotation property to 90.\nSelect the CollisionPolygon2D and add three points to cover the jumper\u0026rsquo;s triangular shape.\nNow let\u0026rsquo;s add a script to the body and start coding its behavior:\nFirst, the signals and variables:\nextends Area2D var velocity = Vector2(100, 0) # start value for testing var jump_speed = 1000 var target = null # if we\u0026#39;re on a circle Next we\u0026rsquo;ll detect the screen touch and, if we\u0026rsquo;re on a circle, call our jump method:\nfunc _unhandled_input(event): if target and event is InputEventScreenTouch and event.pressed: jump() Jumping means leaving a circle and traveling forward at our jump speed:\nfunc jump(): target = null velocity = transform.x * jump_speed We\u0026rsquo;ll detect hitting a circle with the area_entered signal, so connect it. If we hit a circle, we\u0026rsquo;ll stop moving forward.\nfunc _on_Jumper_area_entered(area): target = area velocity = Vector2() If we are captured by a circle, we want to rotate around it. We\u0026rsquo;ll add a pivot on the circle, and match its transform so our orientation will always be facing outwards. Otherwise we move forward in a straight line.\nfunc _physics_process(delta): if target: transform = target.orbit_position.global_transform else: position += velocity * delta Color Shader See the Shaders section for help getting started using shaders.\n We\u0026rsquo;re going to use a small shader to the Sprite so that we can customize its color. Select the Sprite and then in the Material property add a new ShaderMaterial. Click on that, and in Shader select \u0026ldquo;New Shader\u0026rdquo;, then click on that. The shader editor panel will open at the bottom.\nHere is the code for our color shader. It uses a uniform variable for the color, which allows us to choose a value from the Inspector or from our game script. Then it changes all the visible pixels of the texture into that color, preserving the alpha (transparency) value.\nshader_type canvas_item; uniform vec4 color : hint_color; void fragment() { COLOR.rgb = color.rgb; COLOR.a = texture(TEXTURE, UV).a; } You\u0026rsquo;ll now see a Shader Params section in the Inspector where you can set a color value:\nWe\u0026rsquo;ll want to use this same shader elsewhere, so in the Shader property, choose \u0026ldquo;Save\u0026rdquo; and save this as res://objects/color.shader.\nCircle The second game object is the circle, which will be instanced many times as the game progresses. Eventually, we\u0026rsquo;ll add a variety of behaviors such as moving, shrinking, etc., but for this first iteration, we just want it to capture the player.\nHere\u0026rsquo;s the starting node setup:\n Area2D (\u0026ldquo;Circle\u0026rdquo;)  Sprite CollisionShape2D Node2D (\u0026ldquo;Pivot\u0026rdquo;)  Position2D (\u0026ldquo;OrbitPosition\u0026rdquo;)    The \u0026ldquo;Pivot\u0026rdquo; node is how we\u0026rsquo;ll make the player orbit the circle. The \u0026ldquo;OrbitPosition\u0026rdquo; will be offset by whatever the size of the circle is, and the player will follow it.\nUse res://assets/images/circle1_n.png as the Sprite\u0026rsquo;s texture. While we\u0026rsquo;re here, add a ShaderMaterial and choose \u0026ldquo;Load\u0026rdquo; to use the saved color.shader we made earlier.\nAdd a circle shape to the CollisionShape2D and attach a script to the root node.\nextends Area2D onready var orbit_position = $Pivot/OrbitPosition var radius = 100 var rotation_speed = PI func _ready(): init() func init(_radius=radius): radius = _radius $CollisionShape2D.shape = $CollisionShape2D.shape.duplicate() $CollisionShape2D.shape.radius = radius var img_size = $Sprite.texture.get_size().x / 2 $Sprite.scale = Vector2(1, 1) * radius / img_size orbit_position.position.x = radius + 25 func _process(delta): $Pivot.rotation += rotation_speed * delta In the init() function, we\u0026rsquo;re setting up the size of the circle, based on the given radius. We need to size the collision shape as well as scaling the texture to match.\nTry running the scene with different values of radius to test. (Later we\u0026rsquo;ll stop calling init() in _ready()).\nMain Scene Now we can test out the interaction.\nCreate a \u0026ldquo;Main\u0026rdquo; scene using a Node2D and instance both the Jumper and the Circle in it. Arrange them so the jumper will hit the Circle (Jumper\u0026rsquo;s default velocity is (100, 0)).\nTry running. You should see the jumper get captured by the circle and start orbiting it. Clicking the mouse should then send the jumper flying off in whatever direction it\u0026rsquo;s pointing.\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nLike video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/start/101_02/",
	"title": "Godot&#39;s Editor: Finding your way around",
	"tags": [],
	"description": "",
	"content": " Project Manager The Project Manager is the first thing you\u0026rsquo;ll see when opening Godot.\nIn this window you can see a list of your Godot projects. You can choose an existing project and click \u0026ldquo;Run\u0026rdquo; to play the game or click \u0026ldquo;Edit\u0026rdquo; to work on it in the Godot editor. Since you probably don\u0026rsquo;t have any projects yet, let\u0026rsquo;s start by clicking the \u0026ldquo;New Project\u0026rdquo; button.\nHere you can give the project a name and create a folder to store it in.\nEvery Godot project is contained in its own folder. This has many benefits, including making it easy to move, share, and backup projects. It also means that all the project\u0026rsquo;s files (images, sounds, etc.) must be in the project folder.\n When you\u0026rsquo;re naming your project, try to choose a name that describes the project. \u0026ldquo;New Game Project #23\u0026rdquo; is not going to help you remember what that project was. You should also think about compatibility: some operating systems are case-sensitive, and some are not. This can lead to problems if you move or share your project from one computer to another. For this reason, many programmers develop a standardized naming scheme. For example: \u0026ldquo;No spaces, use \u0026lsquo;_\u0026rsquo; between words.\u0026rdquo;\nLet\u0026rsquo;s name this new project \u0026ldquo;getting_started\u0026rdquo;. Type this name, click \u0026ldquo;Create Folder\u0026rdquo;, and then click \u0026ldquo;Create \u0026amp; Edit\u0026rdquo;.\nYou\u0026rsquo;re now looking at the Godot editor window. This is where you\u0026rsquo;ll spend most of your time when working in Godot. The editor is divided into sections.\n Viewport: This is where you\u0026rsquo;ll see the parts of your game as you\u0026rsquo;re working on them. Main Menu: Here you can save and load files, edit project settings, and search for help. Workspaces: At the center-top, you can switch between working in the 2D, 3D, or Script workspaces. You start in 3D. Playtest Buttons: These buttons let you launch and control your game when testing. Docks: On both sides are a number of docks where you can view game items and set their properties.  Project Settings Now we\u0026rsquo;ve talked about the main parts of the Godot window and how they work, let\u0026rsquo;s spend a little time talking about our Project settings. Usually one of the first tasks when starting a new project is make sure it\u0026rsquo;s all set up correctly.\nSo let\u0026rsquo;s click on \u0026ldquo;Project\u0026rdquo; in the menu and select \u0026ldquo;Project Settings\u0026rdquo;.\nThis is the Project settings window. On the left is a list of categories. For most projects, the default settings will be fine, and you shouldn\u0026rsquo;t worry about changing them unless you have a very specific need. For now, we\u0026rsquo;re just going to look at two of the sections. First, \u0026ldquo;Application/Config\u0026rdquo;.\nIn here, you can set your game\u0026rsquo;s title, choose which scene is the \u0026ldquo;main scene\u0026rdquo; (more about that in a bit), and change the icon.\nSecond, let\u0026rsquo;s look at the \u0026ldquo;Display\u0026rdquo; section. This is where you set up your game\u0026rsquo;s display. width \u0026amp; height let you set the size of the game window. If, for example, you were making a mobile game, you\u0026rsquo;d want to set this to the resolution and proportions of your target device. There are also settings for scaling, stretching, fullscreen mode, and more. For now, we\u0026rsquo;ll leave the default size - later on we\u0026rsquo;ll talk about how to adjust these to get our game running on different devices.\nThere are also some tabs across the top. We\u0026rsquo;ve been looking at the \u0026ldquo;General\u0026rdquo; tab. I\u0026rsquo;ll also point out briefly, the \u0026ldquo;Input Map\u0026rdquo;. This is where you can define different input actions for keyboard control, gamepad, mouse, and so on. In your game, you\u0026rsquo;ll just worry about the action, not what individual key or button was pressed. This is a very powerful and flexible way of handling player input.\nWe also have localization options, if you plan to support multiple languages. Autoloading, which we\u0026rsquo;ll get to later, and plugins. The Godot community has created a variety of useful plugins that you can download and add to supply more features, different tools, and so on.\nWe\u0026rsquo;ll come back to the project settings window later. Let\u0026rsquo;s close it for now and we\u0026rsquo;re ready to move on to the next step: working with nodes.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/2d/",
	"title": "2D",
	"tags": [],
	"description": "",
	"content": "  2D Tips, tricks, and tutorials on the 2D side of game development.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/math/transforms/",
	"title": "Transforms",
	"tags": [],
	"description": "",
	"content": " Before reading this, make sure you have an understanding of vectors and how they\u0026rsquo;re used in game development. If you don\u0026rsquo;t, I recommend you read this introduction I wrote for the Godot documentation: Vector Math.\n2D Transforms In 2D space, we use the familiar X-Y coordinate plane. Remember that in Godot, as in most computer graphics applications, the Y axis points downward:\nTo begin, let\u0026rsquo;s consider this spaceship floating in space:\nThe ship is pointing in the same direction as the X axis. If we wanted it to move forward, we could add to its X coordinate and it would move to the left: position += Vector2(10, 0).\nBut what happens when the ship rotates?\nHow do we move the ship forward now? If you remember Trigonometry from school, you might be starting to think about angles, sin and cos and doing something like position += Vector2(10 * cos(angle), 10 * sin(angle)). While this would work, there\u0026rsquo;s a much more convenient way: the Transform.\nLet\u0026rsquo;s look at the rotated ship again, but this time, let\u0026rsquo;s also imagine that the ship has its own X and Y axes that it carries with it, independent of the global axes:\nThese \u0026ldquo;local\u0026rdquo; axes are a part of the transform called the basis.\nKnowing this, we can move the ship forward by moving it along its own X axis and we won\u0026rsquo;t have to worry about angles and trig functions. To do this in Godot, we can use the transform property, which is available to all Node2D derived nodes.\nposition += transform.x * 10 This code says \u0026ldquo;Add the transform\u0026rsquo;s x vector multiplied by 10.\u0026rdquo; Let\u0026rsquo;s break down what that means. The transform contains x and y properties that represent those local axes. They are unit vectors, which means their length is 1. Another term for unit vector is direction vector. They tell us the direction the ship\u0026rsquo;s x axis is pointing. We then multiply by 10 to scale it to a longer distance.\nThe transform property of a node is relative to its parent node. If you need to get the global value, it\u0026rsquo;s available in global_transform.\n In addition to the basis, the transform also contains a component called the origin. The basis represents the body\u0026rsquo;s rotation, while the origin represents the translation, or change in position.\nIn this picture, the blue vector is the transform.origin. It is equal to the object\u0026rsquo;s position vector.\nConverting Between Local and Global Space You can convert coordinates from local to global by applying the transform. To apply a transform, use xform():\nvar global_position = transform.xform(local_position) For convenience, Node2D and Spatial include helper functions for this. Instead of using transform.xform(), you can call to_global():\nvar global_position = to_global(local_position) To convert from global to local coordinates, you can use the opposite (inverse) of the transform with xform_inv().\nLet\u0026rsquo;s use the example of an object in the 2D plane and convert mouse clicks (global space) into coordinates relative to the object:\nextends Sprite func _unhandled_input(event): if event is InputEventMouseButton and event.pressed: if event.button_index == BUTTON_LEFT: printt(event.position, transform.xform_inv(event.position)) As with the previous operation, there are helper functions for this. Instead of using transform.xform_inv(), you can call to_local():\nprintt(event.position, to_local(event.position)) See the Transform2D docs for a list of the available properties and methods.\n3D Transforms In 3D space, the concept of transforms applies in thesame way as in 2D. In fact, it becomes even more necessary, as using angles in 3D can lead to a variety of problems, as we\u0026rsquo;ll see in a bit.\n3D nodes inherit from the base node Spatial, which contains the transform information. The 3D transform requires more information than the 2D version. Position is still held in the origin property, but rotation is in a property called basis, which contains three unit vectors representing the body\u0026rsquo;s local X, Y, and Z axes.\nIn the editor, you can see and manipulate the body\u0026rsquo;s local orientation by clicking the \u0026ldquo;Local Space Mode\u0026rdquo; button.  As in 2D, we can use the local axes to move an object forward. In Godot\u0026rsquo;s 3D orientation (Y-up), this means that by default the body\u0026rsquo;s -Z axis is the forward direction:\ntranslation += -transform.basis.z Godot has default vector values defined, for example: Vector3.FORWARD = Vector3(0, 0, -1). See Vector2 and Vector3 for details.\n "
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/3d/101_3d_02/",
	"title": "Importing 3D Objects",
	"tags": [],
	"description": "",
	"content": " In the last part, we started a 3D project and looked at how to navigate and create 3D objects. In this part, you\u0026rsquo;ll learn how to import existing 3D objects that you\u0026rsquo;ve made or downloaded and how to use more of Godot\u0026rsquo;s 3D nodes.\nImporting 3D Objects If you\u0026rsquo;re familiar with 3D modeling software such as Blender, you can make your own models to use in your game. If not, there are many sources where you can download objects or even collections of objects for particular game types. One of our favorite makers of free game art is Kenney.nl.\nFor our tutorials, we\u0026rsquo;re going to use Kenney\u0026rsquo;s Platformer Kit, which you can download here: https://kenney.nl/assets/platformer-kit\nThis kit has a wide selection of objects that we can use to practice our Godot 3D skills. Here\u0026rsquo;s a sample showing what the kit looks like:\nOnce you\u0026rsquo;ve downloaded the kit, you\u0026rsquo;ll find that the objects inside are provided in a variety of different formats. Godot is able to use several of these, but since GLTF is available in this pack, it\u0026rsquo;s preferred over the others. Copy the \u0026ldquo;GLTF Format\u0026rdquo; folder into your Godot project\u0026rsquo;s folder and rename it to \u0026ldquo;platformer kit\u0026rdquo;.\nIf you\u0026rsquo;re interested in the differences between the formats, here\u0026rsquo;s a brief summary: OBJ files are the simplest, each representing a mesh which you can load into a MeshInstance node. This is likely the most common file type you\u0026rsquo;ll find online. DAE (Collada) files are more robust - Godot loads them as individual scenes, and they can include additional data along with the mesh such as animations. GLTF files are similar, but represent a more modern format with additional features.\n When you switch back to your Godot window, you\u0026rsquo;ll see progress bar while Godot scans the folder and imports all of the objects. Let\u0026rsquo;s click on one of them to see what\u0026rsquo;s going on. In the \u0026ldquo;FileSystem\u0026rdquo; tab, select the \u0026ldquo;crate.glb\u0026rdquo; and then click on the \u0026ldquo;Import\u0026rdquo; tab:\nHere you can see the cube object will be imported as a scene, with its root type set to Spatial and named \u0026ldquo;Scene Root\u0026rdquo;. Let\u0026rsquo;s change these: set the root type to RigidBody and the root name to \u0026ldquo;Crate\u0026rdquo;, then click the \u0026ldquo;Reimport\u0026rdquo; button.\nNow double-click on \u0026ldquo;crate.glb\u0026rdquo; and confirm that you want to make a new inherited scene. Here we have a classic game object: the crate. The root node of the scene is a RigidBody named \u0026ldquo;Crate\u0026rdquo; just as we wanted. However, there\u0026rsquo;s one small problem: it seems Kenney exported this model with an offset:\nIt would much better if the crate were centered relative to the parent node, so that when the RigidBody rotates about its center, so will the mesh. To fix this, select the MeshInstance node and set its Translation property to (-0.5, -0.25, 0.5).\nFinally, we need to add a collision shape to the body. Add a CollisionShape node as a child of the Crate. In its Shape property, choose \u0026ldquo;New BoxShape\u0026rdquo;. Use the three handles (they look like orange circles) to size the box to fit the mesh. You can also set the extents directly in the Inspector:\nNote that since the crate is 0.5 units wide, the Extents, which represent the distance from the center, becomes 0.25 units.\nNow we\u0026rsquo;re finished setting up the object. Save your Crate scene and let\u0026rsquo;s see how we can use it.\nBuilding a 3D Scene Create a new scene with a Spatial root. The first child we\u0026rsquo;ll add is one to give us a \u0026ldquo;ground\u0026rdquo; to stack some crates on. Add a StaticBody called \u0026ldquo;Ground\u0026rdquo;, and to that add a MeshInstance. In the Mesh property, select \u0026ldquo;New PlaneMesh\u0026rdquo; and then click it to open its properties. Set Size to (10, 10) so that we have a nice large surface. However, it would look better if it weren\u0026rsquo;t plain white.\nAlso in the mesh properties is a Material property. Materials are how you define the appearance of an object. Select \u0026ldquo;New SpatialMaterial\u0026rdquo; and then click it to open a large list of properties. To set the color of the mesh, we need the Albedo property. Choose a color, such as brown or dark green.\nIf we add a crate, it will fall right through the mesh, so we also need to give it a collision shape. With the crate, we added a CollisionShape node and assigned a shape. That\u0026rsquo;s one way to add collision, let\u0026rsquo;s look at another: select the mesh and in the menu at the of the viewport, choose \u0026ldquo;Create Convex Collision Sibling\u0026rdquo;. This will automatically create a CollisionShape node as a sibling of the mesh and assign it a shape that matches the mesh.\nNow instance a few crates in the scene and arrange them in a rough stack. Add a Camera and place it where it has a good view of the crates. Run the scene and watch your crates go tumbling!\nRotating Camera Let\u0026rsquo;s make the camera a little more dynamic by having it slowly orbit around the scene. Add a Spatial, which will be located at (0, 0, 0) and name it \u0026ldquo;CameraHub\u0026rdquo;. In the scene tree, drag the camera to make it a child of this new Spatial. Now, if the Spatial rotates around the y axis, it will drag the camera along with it.\nAdd a script to the root node and add the following:\nextends Spatial func _process(delta): $CameraHub.rotate_y(0.01) Run the scene to see what happens.\nLighting There\u0026rsquo;s another thing we can add to the scene to improve how it looks: light. There are multiple light nodes available in 3D, but we\u0026rsquo;re going to start with DirectionalLight. Add one to the scene and use the green (Y) arrow to pull it up into the air.\nA DirectionalLight simulates an infinite number of parallel rays of light, as if from a distant source like the sun. It will not cast shadows by default; to add shadows, click Enabled in the \u0026ldquo;Shadow\u0026rdquo; section. There is also a \u0026ldquo;DirectionalShadow\u0026rdquo; section, which contains a number of advanced properties for fine-tuning the shadow appearance. For full details see this document.\nNote that it really doesn\u0026rsquo;t matter where you place the node - only the direction of the light arrow matters.\nWrapping Up In this tutorial you learned how to import 3D objects from outside sources, and how to combine them into a simple scene. We also investigated lights and moving cameras.\nIn the next part, we\u0026rsquo;ll look at how to build a more complex scene and include a player-controlled character.\nYou can also find a video version of this lesson here:\n    --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_02/",
	"title": "Spawning Circles",
	"tags": [],
	"description": "",
	"content": " In the previous part, we created the Jumper and Circle object that make up the bulk of the game. Now we need to add the progression: a continuous series of spawned circles as long as the player doesn\u0026rsquo;t miss.\nExpanding the Main scene Let\u0026rsquo;s add some more nodes to Main:\n Position2D (\u0026ldquo;StartPosition\u0026rdquo;)\nThis will mark the starting position for the game. Place it near the bottom-center of the screen.\n Camera2D\nThe camera will follow the player as it moves.\nLet\u0026rsquo;s also configure the camera. Set its Offset to (0, -200) - this will ensure we can see more of the world ahead of us. Also set Current to \u0026ldquo;On\u0026rdquo;.\n  Scripting the Main scene Remove the jumper and circle instances we manually created. We\u0026rsquo;ll add them in code moving forward.\nAdd the following to Jumper.gd:\nsignal captured We\u0026rsquo;ll emit this signal when the jumper hits a circle:\nfunc _on_Jumper_area_entered(area): target = area velocity = Vector2.ZERO emit_signal(\u0026#34;captured\u0026#34;, area) And let\u0026rsquo;s change the init() function on the circle to also accept a position:\nfunc init(_position, _radius=radius): position = _position Now let\u0026rsquo;s add a script to the Main scene:\nextends Node var Circle = preload(\u0026#34;res://objects/Circle.tscn\u0026#34;) var Jumper = preload(\u0026#34;res://objects/Jumper.tscn\u0026#34;) var player We need references to both objects so that we can instance them when needed.\nfunc _ready(): randomize() new_game() This is temporary - later we\u0026rsquo;ll have a UI with a start button to call the new game function.\nfunc new_game(): $Camera2D.position = $StartPosition.position player = Jumper.instance() player.position = $StartPosition.position add_child(player) player.connect(\u0026#34;captured\u0026#34;, self, \u0026#34;_on_Jumper_captured\u0026#34;) spawn_circle($StartPosition.position) The new_game() function initializes the game - spawning a player and a circle at the start position, and setting the camera.\nfunc spawn_circle(_position=null): var c = Circle.instance() if !_position: var x = rand_range(-150, 150) var y = rand_range(-500, -400) c.position = player.target.position + Vector2(x, y) add_child(c) c.init(_position) Here\u0026rsquo;s our spawn_circle() function. If it\u0026rsquo;s passed a position, it\u0026rsquo;ll use it, otherwise we pick a random one some distance away from the current target. These are temporary numbers - once we\u0026rsquo;ve got more of the gameplay up and running, we\u0026rsquo;ll see how much they need to be adjusted.\nfunc _on_Jumper_captured(object): $Camera2D.position = object.position call_deferred(\u0026#34;spawn_circle\u0026#34;) Finally, we need the function that processes the jumper\u0026rsquo;s captured signal. We\u0026rsquo;re going to move the camera to the new circle and spawn another. Note that because this function is called during physics processing, we\u0026rsquo;ll get an error if we try and add to the scene tree. Using call_deferred() tells the engine to execute that function as soon as it\u0026rsquo;s safe to do so.\nTry it out. You should be able to jump from circle to circle - how many did you get?\nOne jarring thing is that the camera \u0026ldquo;teleports\u0026rdquo; when it moves to the next circle. We can improve this by enabling Smoothing on the camera. The Smoothing/Speed controls how quickly the camera interpolates to the new position. Try something between 5 and 10.\nAdjustments It\u0026rsquo;s also jarring that when we hit a circle we don\u0026rsquo;t start rotating at the place we hit. Add this to the jumper\u0026rsquo;s _on_Jumper_area_entered() function:\ntarget.get_node(\u0026#34;Pivot\u0026#34;).rotation = (position - target.position).angle() Let\u0026rsquo;s also add this to the circle\u0026rsquo;s init():\nrotation_speed *= pow(-1, randi() % 2) This randomly flips the rotation speed to positive or negative, so we won\u0026rsquo;t always orbit in the same direction.\nTrail Add these nodes to the jumper:\n Node (\u0026ldquo;Trail\u0026rdquo;)  Line2D (\u0026ldquo;Points\u0026rdquo;)   We\u0026rsquo;re going to use this to make a trail that streams out behind the player. Later we\u0026rsquo;ll make it more visually appealing, but for now, let\u0026rsquo;s stick with a simple gradient. In the Fill add a new Gradient, and go from transparent to a color of your choosing:\nNow in the jumper\u0026rsquo;s script, let\u0026rsquo;s add the following:\nonready var trail = $Trail/Points var trail_length = 25 And then in the _physics_process():\nif trail.points.size() \u0026gt; trail_length: trail.remove_point(0) trail.add_point(position) IMAGE/GIF\nCircle animations Finally, we\u0026rsquo;ll add some visuals to the circles. First, we\u0026rsquo;ll add an effect when the player jumps off and the circle disappears. Then, we\u0026rsquo;ll add a capture effect for when we hit a circle.\nAdd an AnimationPlayer node to the Circle.\n\u0026ldquo;Implode\u0026rdquo; animation Add a new animation called \u0026ldquo;implode\u0026rdquo;. Set the length to 0.4 and keyframe two properties of the root Area2D node: Scale at (1, 1) and Modulate at its default ((1, 1, 1, 1)). Then move the scrubber all the way to the end and key the values (0.1, 0.1) and (1, 1, 1, 0) (that\u0026rsquo;s the \u0026ldquo;alpha\u0026rdquo; value of the color).\nCapture animation The capture animation is a little more complex. Duplicate the Sprite and call it SpriteEffect. Set its Visible property off. We\u0026rsquo;re going to animate this second ring zooming in on the main circle.\nHere are the functions to add to the circle script:\nfunc capture(): $AnimationPlayer.play(\u0026#34;capture\u0026#34;) func implode(): if !$AnimationPlayer.is_playing(): $AnimationPlayer.play(\u0026#34;implode\u0026#34;) yield($AnimationPlayer, \u0026#34;animation_finished\u0026#34;) queue_free() And then in Jumper.gd, our jump function becomes:\nfunc jump(): target.implode() target = null velocity = transform.x * jump_speed And in Main, our capture method calls the capture:\nfunc _on_Jumper_captured(object): $Camera2D.position = object.position object.capture() call_deferred(\u0026#34;spawn_circle\u0026#34;) GIF\nFollow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/3d/",
	"title": "3D",
	"tags": [],
	"description": "",
	"content": "  3D Tips, tricks, and tutorials on the 3D side of game development.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/start/101_03/",
	"title": "Nodes: Godot&#39;s building blocks",
	"tags": [],
	"description": "",
	"content": " Nodes are the basic building blocks for creating games in Godot. A node is an object that can represent some kind of specialized game function. A given type of node might display graphics, play an animation, or represent a 3D model of an object. The node also contains a collection of properties, allowing you to customize its behavior. Which nodes you add to your project will depend on what functionality you need. It\u0026rsquo;s a modular system designed to give you flexibility in building your game objects.\nWorking with Nodes Nodes are objects, in the programming sense. They encapsulate data and behavior, and they can inherit properties from other nodes. Rather than use one of the default suggestions, let\u0026rsquo;s click the \u0026ldquo;Add/Create a New Node\u0026rdquo; button in the scene dock.\nHere you\u0026rsquo;ll see the whole hierarchy of node types available in the engine. For example, the nodes with the bluish-purple icons all fall under the \u0026ldquo;Node2D\u0026rdquo; category, meaning they will all have the properties of a Node2D. More about that in a moment.\nThe list is long, and it would be frustrating to have to drill down every time to find the node you need. Instead, you can use the search function to find it using a small number of characters. We\u0026rsquo;re looking for the \u0026ldquo;Sprite\u0026rdquo; node, so I\u0026rsquo;ll just type \u0026ldquo;sp\u0026rdquo; and we\u0026rsquo;ll jump right to it. Click \u0026ldquo;Create\u0026rdquo; to add the node.\nNow we have this Sprite node in our \u0026ldquo;Scene\u0026rdquo; dock. Make sure it\u0026rsquo;s selected, and then look at the Inspector dock on the right side. Over here, you\u0026rsquo;ll see all the properties of whatever node you have selected. Notice that the properties are organized by where they come from. The Sprite node inherits from Node2D, which inherits from CanvasItem, which inherits from the plain old Node.\nOver in the viewport, the sprite doesn\u0026rsquo;t look like much. A sprite\u0026rsquo;s purpose is to display an image, or texture. As you can see in the Inspector, the texture property is currently empty. Fortunately, every new Godot project comes with an image we can use: the Godot icon. Drag the icon from the Filesystem dock and drop it in the texture property.\nIn the Inspector, click to expand the \u0026ldquo;Transform\u0026rdquo; section, and type (50, 50) in the Position property.\nYou can also click and drag the sprite around in the viewport, and you\u0026rsquo;ll see the Position values changing as you move.\nOne important property of nodes is that they can be arranged in a parent-child hierarchy. Make sure you have the Sprite selected and press the add button again. Add another Sprite and also drag the icon into its texture.\nThis new sprite is a child of the first. This means that it\u0026rsquo;s \u0026ldquo;attached\u0026rdquo; to its parent. If the parent sprite moves, so will the child. Click on the child sprite and set its Position to (50, 50). Now click and drag the parent sprite to move it around the screen.\nNotice that the Position of the parent is changing as you move it around. Now check the child: it\u0026rsquo;s still (50, 50). That\u0026rsquo;s because its \u0026ldquo;Transform\u0026rdquo; properties are relative to its parent.\nScenes Grouping nodes together like this is a powerful tool, enabling you to construct complex objects out of node \u0026ldquo;building blocks\u0026rdquo;. For example, a \u0026ldquo;Player\u0026rdquo; node in your game might have many child nodes attached to it: a Sprite for display, an AnimationPlayer to animate it, a Camera to follow it around, and so on.\nA group of nodes arranged in a \u0026ldquo;tree\u0026rdquo; structure like this is called a Scene. In the next part, we\u0026rsquo;ll look at how you can use scenes to organize your game\u0026rsquo;s objects into independent parts that all work together. You\u0026rsquo;ll see this in practice was you work through the examples in later lessons.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/3d/101_3d_03/",
	"title": "Creating a 3D Character",
	"tags": [],
	"description": "",
	"content": " In the last part, we covered how to import 3D objects and how to arrange them in a scene. In this installment, we\u0026rsquo;ll add more objects to the scene, including a user-controlled character.\nBuilding the Scene We\u0026rsquo;re going to continue using the Kenney Platformer Kit we downloaded last time. Select all the \u0026ldquo;block*.glb\u0026rdquo; files and in the \u0026ldquo;Import\u0026rdquo; tab set their \u0026ldquo;Root Type\u0026rdquo; to StaticBody and click \u0026ldquo;Reimport\u0026rdquo;. Select \u0026ldquo;blockLarge.glb\u0026rdquo; and make a new inherited scene. Add a \u0026ldquo;Convex Collision Sibling\u0026rdquo; to the mesh using the menu as you did in the last tutorial. Rename the root node to \u0026ldquo;BlockLarge\u0026rdquo; and save the scene - I recommend making a separate folder for this, as soon you\u0026rsquo;re going to have a bunch of scenes representing the differently shaped platform parts.\nYou can download a starter project with all the block objects already configured and ready to use here: LINK\nOpen the scene from the last tutorial with the \u0026ldquo;Ground\u0026rdquo; plane and the crates. Delete the crates and add an instance of the large block. We want to be able to place these blocks so that they line up. To do this, select \u0026ldquo;Configure Snap\u0026rdquo; from the \u0026ldquo;Transform\u0026rdquo; menu at the top of the Viewport and set Translate Snap to 0.5. Then click on the \u0026ldquo;Snap Mode\u0026rdquo; button (or press the Y key). Now duplicate the block a few times and drag them to arrange.\nIf you like, go ahead and add scenes for some of the other platform blocks and arrange them into a pleasing level. Be creative!\nAdding a Character Now we\u0026rsquo;re going to make a character so we can walk around on the platforms. Open a new scene and start with a KinematicBody named \u0026ldquo;Character\u0026rdquo;. This PhysicsBody node behaves very much like its 2D equivalent (you\u0026rsquo;ve already done the 2D tutorials, right?). It has a move_and_slide() method that we\u0026rsquo;ll use to perform the movement and collision detection. Gravity will be added manually each frame, accelerating in the -Y direction.\nAdd a sphere-shaped MeshInstance and a matching CollisionShape. Remember, you can add a SpatialMaterial to the mesh and set its Albedo property to change the color.\nThe sphere is nice, but it\u0026rsquo;s going to be hard to tell what direction it\u0026rsquo;s facing. Let\u0026rsquo;s add another MeshInstance, this time with a PrismMesh shape. Set its Size to (0.5, 0.5, 0.1) and then its x rotation to -90 degrees. Arrange it so it\u0026rsquo;s pointing along the negative z axis. (You can tell which way is negative because the gizmo arrows point in the positive direction).\nLet\u0026rsquo;s also add a Camera to the scene, so it will follow the player around. Position the camera behind and above the character, angling it down a bit. Click the \u0026ldquo;Preview\u0026rdquo; button to check the camera\u0026rsquo;s view.\nBefore we add a script, open the \u0026ldquo;Project Settings\u0026rdquo; and add the following inputs on the \u0026ldquo;Input Map\u0026rdquo; tab:\n   Input Action Key     move_forward W   move_back S   strafe_right D   strafe_left A   jump Space    Now let\u0026rsquo;s add a script to the body.\nextends KinematicBody var gravity = -12 # strength of gravity Vector3.DOWN * 12 var speed = 4 # movement speed var jump_speed = 6 # jump strength var spin = 0.1 # rotation speed var velocity = Vector3() var jump = false func get_input(): velocity.x = 0 velocity.z = 0 if Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): velocity.z -= speed if Input.is_action_pressed(\u0026#34;move_back\u0026#34;): velocity.z += speed if Input.is_action_pressed(\u0026#34;strafe_right\u0026#34;): velocity.x += speed if Input.is_action_pressed(\u0026#34;strafe_left\u0026#34;): velocity.x -= speed func _physics_process(delta): velocity += gravity * delta get_input(delta) velocity = move_and_slide(velocity, Vector3.UP) The code in _physics_process() is pretty straightforward: add gravity to accelerate in the positive Y direction (downward), call get_input() to check for input, and then use move_and_slide() to move in the direction of the velocity vector.\nIn get_input() we check to see which key is pressed and then move in that direction. Run the program and test:\nThis is all good, but we need to be able to rotate. Let\u0026rsquo;s add a camera to the body and we\u0026rsquo;ll use the mouse to rotate. Place the camera above and behind the character so you have a good view, then add the following code to the character\u0026rsquo;s script:\nfunc _unhandled_input(event): if event is InputEventMouseMotion: if event.relative.x \u0026gt; 0: rotate_y(-lerp(0, spin, event.relative.x/10)) elif event.relative.x \u0026lt; 0: rotate_y(-lerp(0, spin, event.relative.x/10) This will convert any mouse motion in the x direction into a rotation around the y axis. We use lerp() to smooth it out based on how fast you move the mouse.\nRun the scene and confirm that moving the mouse rotates the character:\nHowever, there\u0026rsquo;s a problem. No matter which way we\u0026rsquo;re facing, pressing W moves us along the Z axis. Our movement is using global coordinates, but we need to move in the object\u0026rsquo;s forward direction.\nThe Power of Transforms This is where transforms come in. A transform is a mathematical matrix that contains the object\u0026rsquo;s translation, rotation, and scale information all in one. In Godot it\u0026rsquo;s stored in the Transform data type. The position information is called the transform.origin and the orientation information is in the transform.basis.\nRemember how the 3D gizmo can be set to \u0026ldquo;Local Space Mode\u0026rdquo;? When in this mode, the gizmo\u0026rsquo;s X/Y/Z axes point along the object\u0026rsquo;s axes. This is the basis of the transform. The basis contains three Vector3 objects callsd x, y, and z that represent these directions. We can use this to ensure that pressing the W key will always move us in the object\u0026rsquo;s forward direction.\nChange the get_input() function like so:\nfunc get_input(): var vy = velocity.y velocity = Vector3() if Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): velocity += -transform.basis.z * speed if Input.is_action_pressed(\u0026#34;move_back\u0026#34;): velocity += transform.basis.z * speed if Input.is_action_pressed(\u0026#34;strafe_right\u0026#34;): velocity += transform.basis.x * speed if Input.is_action_pressed(\u0026#34;strafe_left\u0026#34;): velocity += -transform.basis.x * speed velocity.y = vy Now forward and back will always move along the objects\u0026rsquo; Z axis, and the strafe keys along its X.\nJumping Let\u0026rsquo;s add one more movement to the player: jumping.\nAdd these lines to the end of get_input(): jump = false if Input.is_action_just_pressed(\u0026#34;jump\u0026#34;): jump = true\nAnd add these to the end of _physics_process(): if jump and is_on_floor(): velocity.y = jump_speed\nWrapping Up In this tutorial you learned how to build a more complex scene, and how to write movement code for a user-controlled character. You also learned about transforms, which are a very important concept in 3D - you\u0026rsquo;re going to be using a lot in the future.\nIn the next part, we\u0026rsquo;ll add some more objects to our 3D world.\nYou can also find a video version of this lesson here:\n    --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/input/",
	"title": "Input",
	"tags": [],
	"description": "",
	"content": "  Input Handling input - from keyboard and mouse to game controllers and touchscreens.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/physics/",
	"title": "Physics",
	"tags": [],
	"description": "",
	"content": "  Physics Learn how to use Godot\u0026rsquo;s physics nodes.\nIn this section:\n When and how to use different physics nodes Collision detection and response  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/3d/101_3d_04/",
	"title": "Using Areas",
	"tags": [],
	"description": "",
	"content": " In the last part, we learned about transforms, a very important concept in 3D that records an object\u0026rsquo;s local orientation in space, and used it to move our KinematicBody character. This time, we\u0026rsquo;re going to look at another type of 3D node: the Area.\nAreas Area nodes are used for detection and influence. They can detect when objects overlap, and when an object enters or exits a region. An Area can also be used to override physics properties, such as gravity or damping, in a region.\nWe\u0026rsquo;re going to use Area to create three types of objects:\n A coin the character can pick up A bullet the character can shoot Spikes that damage the character  To begin, let\u0026rsquo;s set up some collision layers so that we can more easily control what objects the areas can interact with. Open the Project Settings and find the \u0026ldquo;Layer Names/3D Physics\u0026rdquo; section. Name the first three layers \u0026ldquo;environment\u0026rdquo;, \u0026ldquo;player\u0026rdquo;, and \u0026ldquo;pickups\u0026rdquo;.\nCoin Create a new inherited scene from the CoinGold.glb object in the Kenney Platformer Kit (see Part 03). Right-click on the root node, choose \u0026ldquo;Change Type\u0026rdquo;, and pick Area. In the Inspector, set the collision mask and layer so that the coin is in \u0026ldquo;pickups\u0026rdquo; and scans \u0026ldquo;player\u0026rdquo;.\nNow we need a collision shape, so add a CollisionShape node and choose a CylinderShape for it. If you rotate it 90 degrees around z, it will fit the coin shape pretty well.\nAdd a script to the Area and connect its body_entered signal, which we\u0026rsquo;ll use to remove the coin:\nextends Area func _on_Coin_body_entered(body): queue_free() Add a few coins to your scene and see if you can pick them up:\nBullets Make a new scene with an Area2D root, and name it \u0026ldquo;Bullet\u0026rdquo;. Add a MeshInstance, a CollisionShape, and a Timer. I\u0026rsquo;m using a sphere shape for the mesh and collision, scaled to a radius of 0.2 so that it won\u0026rsquo;t be too big compared with the character. The Timer is to give the bullet a time limit. Set its One Shot and Autostart properties both on.\nAdd a script and connect the Timer\u0026rsquo;s timeout signal and the Area\u0026rsquo;s body_entered signal. Then add the following:\nextends Area var speed = 15 var velocity = Vector3() func start(xform): transform = xform velocity = -transform.basis.z * speed func _process(delta): transform.origin += velocity * delta func _on_Timer_timeout(): queue_free() func _on_Bullet_body_entered(body): if body is StaticBody: queue_free() Since we want the bullet to start at a certain location and travel directly ahead of the player, we\u0026rsquo;ll pass the player\u0026rsquo;s transform to start() and use it to orient the bullet and make it move forward (remember in Godot\u0026rsquo;s orientation, \u0026ldquo;forward\u0026rdquo; is along the negative z axis).\nNow we can go to the character scene and add a Position3D node, placing it at the tip of the character\u0026rsquo;s \u0026ldquo;arrow\u0026rdquo; mesh. Name this node \u0026ldquo;Muzzle\u0026rdquo;. Next, add the following code to the character\u0026rsquo;s script:\nvar Bullet = preload(\u0026#34;res://Bullet.tscn\u0026#34;) func _unhandled_input(event): if event.is_action_pressed(\u0026#34;shoot\u0026#34;): var b = Bullet.instance() b.start($Muzzle.global_transform) get_parent().add_child(b) Spikes Finally, we\u0026rsquo;re going to add some danger to the environment. Make in instance of the spikes.glb object and make it an Area like we did with the coin. Add a script and connect the body_entered signal, but this time, we want the object to do something to the character:\nextends Area func _on_Spikes_body_entered(body): if body.has_method(\u0026#34;take_damage\u0026#34;): body.take_damage() Now we need to define how the character reacts to taking \u0026ldquo;damage\u0026rdquo;. Since we haven\u0026rsquo;t really built a health system, we\u0026rsquo;re just going to \u0026ldquo;bounce\u0026rdquo; the character as if it got hurt. We need to add the following to the character script:\nvar can_move = true func take_damage(): velocity *= -1 velocity.y = jump_speed can_move = false yield(get_tree().create_timer(1), \u0026#34;timeout\u0026#34;) can_move = true The purpose of this code is to disable input temporarily so the player will fly backwards from the spikes. If we just tried to set the velocity, it would immediately be overridden by the velocity set by the key inputs. So add this at the beginning of get_input():\nif !can_move: return Add a spike instance to your level and try it out:\nWrapping Up In this tutorial you learned how to use Area nodes to detect and react to 3D bodies.\nIn the next part: a collection of small improvements.\nYou can also find a video version of this lesson here:\n    --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/gdscript/",
	"title": "GDScript",
	"tags": [],
	"description": "",
	"content": "  GDScript GDScript is Godot\u0026rsquo;s built-in scripting language. Its syntax is based on Python, so if you\u0026rsquo;re familiar with that language, you\u0026rsquo;ll feel right at home. In this chapter, we\u0026rsquo;ll introduce the language and get you up to speed with how it works.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/3d/",
	"title": "Intro to 3D",
	"tags": [],
	"description": "",
	"content": "  Intro to 3D A gentle introduction to the 3D side of Godot development.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/circle_jump/",
	"title": "Mobile Game: Circle Jump",
	"tags": [],
	"description": "",
	"content": "  Circle Jump An end-to-end game development series. In this series, we build a one-touch mobile game called \u0026ldquo;Circle Jump\u0026rdquo;. Here\u0026rsquo;s a prototype image:\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/ui/",
	"title": "UI",
	"tags": [],
	"description": "",
	"content": "  UI Building user interfaces.\nIn this section:\n Displaying game data HUDs and overlays Game menus Start/end screens Interactive screens: inventory, maps, and more.  "
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/3d/101_3d_05/",
	"title": "Edge Detection &amp; Mouse Capture",
	"tags": [],
	"description": "",
	"content": " In the last part, we learned how to use Area nodes to detect contact between objects, making coin, bullet, and spike objects for our character to interact with. In this part, we\u0026rsquo;ll look at a few small improvements: capturing the mouse, animating the coins, and detecting edges so our character doesn\u0026rsquo;t fall.\nCapturing the Mouse One issue with our mouse-based controls is that as you move the mouse from side to side, it eventually moves out of the game window and hits the edge of your screen. To solve this, we need to \u0026ldquo;capture\u0026rdquo; the mouse. However, if we do that, we won\u0026rsquo;t be able to close the window or anything else - our mouse will be gone! We\u0026rsquo;ll need a way to release the mouse again.\nFirst, to capture the mouse, add the following to the main scene:\nfunc _ready(): Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) This takes care of the first part: the mouse will now be captured by our game window. Now we need it to be released when we press the \u0026ldquo;Escape\u0026rdquo; key. Let\u0026rsquo;s put this in the main script as well:\nfunc _input(event): if event.is_action_pressed(\u0026#34;ui_cancel\u0026#34;): Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE) Run the game and try it out.\nLet\u0026rsquo;s also ignore mouse motion when it\u0026rsquo;s not captured. In the character script, change this line in _unhandled_input():\nif event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED: Now we have another issue: once you\u0026rsquo;ve pressed \u0026ldquo;Escape\u0026rdquo;, we don\u0026rsquo;t have a way to go back to being captured. Let\u0026rsquo;s do that if we click on the window:\nfunc _input(event): if event.is_action_pressed(\u0026#34;ui_cancel\u0026#34;): Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE) if event.is_action_pressed(\u0026#34;shoot\u0026#34;): if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE: Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) This works OK, but when we click to recapture the mouse, we also fire a bullet, since the mouse click does that as well. We can solve this by marking the input as \u0026ldquo;handled\u0026rdquo;, so that Godot won\u0026rsquo;t send it on to any other nodes:\nif event.is_action_pressed(\u0026#34;shoot\u0026#34;): if Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE: Input.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) get_tree().set_input_as_handled() Now that first click capturing the mouse won\u0026rsquo;t also fire a bullet.\nAnimated Coins Now we\u0026rsquo;re going to make the coins from the last part a bit more dynamic and appealing. Open Coin.tscn and add an AnimationPlayer to the scene.\nClick the \u0026ldquo;Animation\u0026rdquo; button and select \u0026ldquo;New\u0026rdquo; to create a new animation called \u0026ldquo;bounce\u0026rdquo;. A duration of 1 second is fine, but make sure to enable looping.\nWe\u0026rsquo;re going to animate two properties of the coin: position (on the Y axis, up and down) and rotation. Ensure the scrubber is at time 0 and add a keyframe for both Translation and Rotation Degrees.\nMove the scrubber to the 0.5 second mark, change the Y component of the translation to 0.3, and click the keyframe button. Then move the scrubber all the way to 1.0 and keyframe the rotation at 180 degrees in Y.\nPress \u0026ldquo;Play\u0026rdquo; to see how your animation looks. Try clicking on the individual translation keyframes and adjusting the Easing value.\nFinally, click the \u0026ldquo;Autoplay\u0026rdquo; button to ensure the animation will automatically start when the game is run.\nEdge Detection Finally, let\u0026rsquo;s see if we can keep our character from running off a cliff and falling to its death.\nStart by adding a RayCast node to the player. It appears as a thin blue line. By default, its Cast To property is set to (0, -1, 0), which is pointing down. This is good, but we also need to move it forward so that it\u0026rsquo;s pointing down at the front of the character:\nAlso, make sure to check the Enabled property, or the RayCast won\u0026rsquo;t work.\nNow, in our character script, we need to check that when moving forward, if the RayCast is colliding, it\u0026rsquo;s safe to move.\nRight now, we have the following:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): velocity += -transform.basis.z * speed Let\u0026rsquo;s try only adding to the velocity if the ray is colliding:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;) and $RayCast.is_colliding(): velocity += -transform.basis.z * speed Try it out. When you run up to an edge, you\u0026rsquo;ll stop. But wait - have you tried jumping forward? Our forward movement is now canceled when we\u0026rsquo;re in the air! Back to the drawing board.\nNow we need to also check if we\u0026rsquo;re on the ground, so that if we walk forward and the ray stops colliding, we do nothing. Otherwise, we move as normal:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): if is_on_floor() and !$RayCast.is_colliding(): pass else: velocity += -transform.basis.z * speed You may be wondering why I wrote it this way. Keep reading, there\u0026rsquo;s a reason!\n This works, but something feels off about the code. We have a conditional statement that does nothing. Surely we can simplify this. We can, with a little bit of Boolean Algebra.\nOur conditional statement is essentially this:\nif A: do_nothing else: do_something Which is equivalent to:\nif not A: do_something So what we really need to do is convert our conditional statement to:\nif !(is_on_floor() and !$RayCast.is_colliding()) This works, but it\u0026rsquo;s hard to read. Can it be simplified? It can, using a Boolean Algebra method called \u0026ldquo;De Morgan\u0026rsquo;s Law\u0026rdquo;. De Morgan\u0026rsquo;s Law states that\nnot (A and B) = not A or not B So we can apply that here and we get the following:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): if !is_on_floor() or $RayCast.is_colliding(): velocity += -transform.basis.z * speed In English:\n\u0026ldquo;If we\u0026rsquo;re not on the floor or there is floor in front of us, move forward.\u0026rdquo;\nThis is a very simplistic implementation - you can still walk sideways or backwards off the edge, for example. Feel free to take this idea and run with it to make improvements. Some games let you fall if you move off the edge slowly, but stop you if you\u0026rsquo;re moving fast.\nWrapping Up In this tutorial, we added a few small improvements to the game. Capturing the mouse is useful in many types of 3D games (first-person, for example), and RayCasts have a wide range of uses - we only touched on one here. The animation we added was very small, but a good start - we\u0026rsquo;ll be using them for many things as we move forward.\nIn the next part: Using Constructed Solid Geometry (CSG).\nYou can also find a video version of this lesson here:    --\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/math/",
	"title": "Gamedev Math",
	"tags": [],
	"description": "",
	"content": "  Gamedev Math Math is a big part of game development. Some of it you may remember from school, or it may be something you\u0026rsquo;ve never encountered before. Here you\u0026rsquo;ll find guides to help you get up to speed and examples of how these concepts are applied to making games.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/recipes/",
	"title": "Misc",
	"tags": [],
	"description": "",
	"content": "  Misc Other recipes that just don\u0026rsquo;t fit in anywhere else.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/3d/101_3d_06/",
	"title": "Using CSG",
	"tags": [],
	"description": "",
	"content": " Earlier, we saw how to design a 3D environment using imported models. But what if you want to make something like a room, with walls, doors, ramps, and other features, but you don\u0026rsquo;t have any models handy? CSG to the rescue!\nWhat is CSG? CSG stands for Constructive Solid Geometry. It allows you to combine primitive shapes to build complex geometry. Shapes can be combined with boolean operations such as Union, Intersection, and Subtraction.\nCSG is a great tool for prototyping environments and game objects. Later in this tutorial, we\u0026rsquo;ll use it to make a small FPS-style level with some ramps, walls and platforms.\nBefore we do that, let\u0026rsquo;s get introduced to how the CSG nodes work.\nCSG Basics Create a new scene with a Spatial root, then add a child node and type \u0026ldquo;CSG\u0026rdquo; in the search box.\nThese are the available CSG shapes. Choose a CSGBox to start. You\u0026rsquo;ll see a plain cube mesh with the following properties:\nThe Operation property is the one that determines how CSG shapes will be combined. The options are:\n Union - The shapes will be merged, removing any \u0026ldquo;inside\u0026rdquo; geometry. Intersection - Only the intersecting (overlapping) geometry will be kept. Subtraction - The second shape is \u0026ldquo;cut out\u0026rdquo; of the first.  CSG operations are performed on a shape by adding children. Add a child CSGCylinder to the CSGBox. Drag the top size handle (orange dot) to make it a bit taller. You can also increase the Sides property to make it look more circular (here it\u0026rsquo;s set to 20):\nBy default, the shape\u0026rsquo;s operation is set to \u0026ldquo;Union\u0026rdquo;. The cylinder shape is being \u0026ldquo;added\u0026rdquo; to the cube. Try changing it to \u0026ldquo;Intersection\u0026rdquo;:\nAnd \u0026ldquo;Subtraction\u0026rdquo;:\nHopefully you\u0026rsquo;re already seeing the possibilities of creating complex shapes through these 3 operations.\nCSGCombiner This node is an \u0026ldquo;empty\u0026rdquo; shape. It\u0026rsquo;s used to organize your shapes. Children of a CSGCombiner will be combined following the same rules as above.\nBuilding a Room Now we\u0026rsquo;re going to make something useful: a large room with some obstacles and features that our character can interact with, and that we can use in the upcoming tutorials. Make a new scene with a Spatial root that we can start working with.\nStart with a CSGBox, and set its Width and Depth to 20 and its Height to 5. We need this to be a box that we go inside, so click the Invert Faces property as well. This reverses the shape so that the solid walls are on the inside rather than the outside. Also check the Use Collision property, so that the physics engine will treat this shape as a static body object.\nAdd an instance of the player character and test that you can walk around in your new room.\nYou may remember that in the last part we added code to capture/release the mouse. You\u0026rsquo;ll need to copy that code over to this scene as well.\n Adding features Now let\u0026rsquo;s add some features - some internal walls, a ledge running around the edge with a ramp, and so on. Feel free to get creative and add your own ideas. Here are a few to get started:\nIf you use a CSGCombiner for each of these objects it will be easier to organize and duplicate them. Make sure to enable Use Collision on it.\n  Wall with door  Add a CSGBox and set its Width to 0.5 and its Height to 5 (the same height as the original room). Make the depth about half the size of the room. You can enable snapping here to make it easier to align.\nAdd another CSGBox as a child and set it to \u0026ldquo;Subtract\u0026rdquo;. Size it to resemble a door. You can also use a cylinder shape to get an arched portal.\n Ramp  For the ramp, we\u0026rsquo;ll use a CSGPolygon. This CSG shape lets you extrude a given polygon to a desired depth. The default shape is a square, but you can add or remove points. For a ramp, we want 3 points.\nAfter adding the CSGPolygon, you can click the Polygon property to adjust its number of points. After that, you can drag the three points to whatever location you like. To ensure everything lines up, you can type the coordinates into the Inspector:\nIn this picture, we\u0026rsquo;ve created a ramp and added a couple of CSGBox shapes to make the ledge.\nPutting it together Make sure to add a Material to your shapes, choosing an Albedo color that seems pleasant to you. In the following examples, we\u0026rsquo;ve picked a tan color.\nHere\u0026rsquo;s an example of a possible room setup:\nHit play and you should be able to walk around the rooms:\nThe area is featureless right now, but to make things more visually interesting, you can add individual lights in each room (more about lighting in a later tutorial). Here\u0026rsquo;s an example of adding some OmniLight and SpotLight nodes to the scene:\nWrapping Up CSG is a powerful tool for building objects directly in Godot without having to move to another modeling application such as Blender. It can be helpful if you need to mock up a test level for your game, or for the final environment. Keep in mind that as the CSG tree becomes more complex, it can incur a performance penalty. Try to use CSGCombiner to separate your scene into separate CSG trees to minimize this.\nIn the next part, we\u0026rsquo;ll look at a popular style of 3D game: first person.\nYou can also find a video version of this lesson here:   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/shaders/",
	"title": "Shaders",
	"tags": [],
	"description": "",
	"content": "  Shaders Deep voodoo. Coming soon.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/basics/3d/101_3d_07/",
	"title": "First-person Character",
	"tags": [],
	"description": "",
	"content": " In this installment, we\u0026rsquo;ll look at how to make a first-person character. We\u0026rsquo;ll use the CSG-based level we designed in the previous part as a place to walk around and test our movement.\nCharacter Scene In an FPS or similar game, we want to give the player the illusion that they\u0026rsquo;re looking out of the character\u0026rsquo;s eyes. One nice aspect of this is that we don\u0026rsquo;t really need a model, at least to get started.\nStart with a KinematicBody. To this we\u0026rsquo;ll add two CollisionShape nodes (\u0026ldquo;Body\u0026rdquo; and \u0026ldquo;Feet\u0026rdquo;). We also want to have a Camera, but we need to be careful about how we handle rotation. The character should rotate in Y, but only the camera should rotate in X (for looking up and down). To make this work, add a Spatial node, which we\u0026rsquo;ll call \u0026ldquo;RotationPivot\u0026rdquo;, and add the Camera to that.\nThe \u0026ldquo;Body\u0026rdquo; collision shape is going to represent the player\u0026rsquo;s body. We can use a CapsuleShape (rotated 90 degrees around X). Set its Radius to 0.5 and Height to 1.\nOne issue with using a CapsuleShape is that the bottom is rounded. This is good for moving over small bumps in a natural way, but it also means that when standing on the edge of a surface, the player will \u0026ldquo;roll\u0026rdquo; off in a strange way. We can prevent this by using a BoxShape for the \u0026ldquo;Feet\u0026rdquo; collision. Make its extents (.4, .1, .4) and place it so that its bottom is just above the bottom of the capsule. We\u0026rsquo;ll still have the round bottom to move over things, but the box will keep us from sliding off ledges.\nMove the RotationPivot up a bit, so that it\u0026rsquo;s not pointing the camera out of the \u0026ldquo;middle\u0026rdquo; of the body.\nMoving around Much of the code for movement is the same as we used for the third-person character earlier in this series. We\u0026rsquo;ll start with declaring our variables:\nextends KinematicBody onready var camera = $RotationHelper/Camera onready var rotation_helper = $RotationHelper var gravity = -30 var max_speed = 8 var mouse_sensitivity = 0.002 # radians/pixel var velocity = Vector3() The value of mouse_sensitivity maps the movement of the mouse, which is in pixels, to rotation, in degrees. So for each pixel the mouse moves, we\u0026rsquo;ll rotate by 0.002 radians (or about 0.1 degrees).\n func get_input(): var input_dir = Vector3() # desired move in camera direction if Input.is_action_pressed(\u0026#34;move_forward\u0026#34;): input_dir += -camera.global_transform.basis.z if Input.is_action_pressed(\u0026#34;move_back\u0026#34;): input_dir += camera.global_transform.basis.z if Input.is_action_pressed(\u0026#34;strafe_left\u0026#34;): input_dir += -camera.global_transform.basis.x if Input.is_action_pressed(\u0026#34;strafe_right\u0026#34;): input_dir += camera.global_transform.basis.x input_dir = input_dir.normalized() return input_dir When detecting input, we want to move in the direction the camera is facing, which is not necessarily the current movement direction. Although we\u0026rsquo;re not going to do it yet, this will allow us to implement friction and acceleration for a more natural movement feel.\nWe add up the inputs and return the resulting direction vector.\nfunc _unhandled_input(event): if event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED: rotation_helper.rotate_x(-event.relative.y * mouse_sensitivity) rotate_y(-event.relative.x * mouse_sensitivity) rotation_helper.rotation.x = clamp(rotation_helper.rotation.x, -1.2, 1.2) We also need to capture mouse movement for camera rotation. As discussed above, horizontal mouse movement rotates the entire body in Y, while vertical motion rotates the helper node in X.\nWe also need to limit that vertical rotation to prevent the camera from flipping upside-down.\nfunc _physics_process(delta): velocity.y += gravity * delta var desired_velocity = get_input() * max_speed velocity.x = desired_velocity.x velocity.z = desired_velocity.z velocity = move_and_slide(velocity, Vector3.UP, true) In _physics_process() we get the desired_velocity, the direction vector returned by get_input(), and multiply it by max_speed to set its length. We don\u0026rsquo;t want to alter our velocity.y because that\u0026rsquo;s set by gravity, so we only set the x and z components based on the input.\nWe\u0026rsquo;re also setting true for the stop_on_slope parameter of move_and_slide(). This keeps us from sliding down the ramp if we stand on it.\nTest your movement and ensure everything is working as expected.\nAdding a weapon First person characters typically have some sort of item, or at least empty hands, visible in front of them. We\u0026rsquo;re going to use the shotgun model from the following art pack:\nKenney Weapon Pack\nAddd a MeshInstance to the Pivot node and use the shotgun.obj model from the art pack. You\u0026rsquo;ll notice that the model is too small for our player\u0026rsquo;s scale, so set Scale to (8, 8, 8).\nWe need to position the model so that it\u0026rsquo;s projecting out \u0026ldquo;through\u0026rdquo; the camera. Aligning it can be difficult, so click the \u0026ldquo;View\u0026rdquo; menu and choose \u0026ldquo;2 Viewports\u0026rdquo;. In the bottom one, select the Camera and click \u0026ldquo;Preview\u0026rdquo;, and in the top you can move the gun until it looks right.\nWrapping up We now have a basic first-person character controller. This could make a good foundation for a wide variety of game types by adding features and behaviors, as we\u0026rsquo;ll see in later lessons.\nYou can also find a video version of this lesson here:   "
},
{
	"uri": "http://kidscancode.org/godot_recipes/games/",
	"title": "Game Tutorials",
	"tags": [],
	"description": "",
	"content": "  Games Demo games and tutorials.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/",
	"title": "Home",
	"tags": [],
	"description": "",
	"content": "  Godot Recipes  Godot\u0026rsquo;s nodes are your ingredients. What can you cook up?\n Are you ready to learn game development? Whether it\u0026rsquo;s as a hobby or working towards your dream career, there\u0026rsquo;s never been a better time to get started. Modern programming languages and tools have made it easier than ever to build high-quality games and distribute them to the world. One of these tools is the Godot game engine. For beginners, it offers a friendly way to learn gamedev techniques. For experienced developers, it\u0026rsquo;s a powerful, customizable and open tool for bringing your visions to life.\nOverview On this site you\u0026rsquo;ll find a gentle introduction to the Godot game engine, as well as a wide variety of gamedev tips and techniques. Feel free to browse the categories in the sidebar and see what catches your interest.\nIf you\u0026rsquo;re new to Godot, start here: What is Godot?.\nHow to use this site Beginners If you\u0026rsquo;re new to game development, start with the \u0026ldquo;Godot 101: Basics\u0026rdquo; section. There you\u0026rsquo;ll find an introduction to the Godot application, and a step-by-step guide to creating your first project. There is a lot of material to absorb here. Don\u0026rsquo;t feel discouraged if you feel you don\u0026rsquo;t get it at first. Repetition is the key to learning complex topics; the more you work with Godot\u0026rsquo;s features, the more familiar and easy they will start to feel.\nIt\u0026rsquo;s assumed that you have at least some general programming experience. If you\u0026rsquo;re completely new to programming, click here for tips on how to get started.\n Experienced Developers If you\u0026rsquo;re an experienced developer and/or you\u0026rsquo;re familiar with other modern game engine(s), feel free to explore the menu on the left. You\u0026rsquo;ll find a number of useful guides and tutorials to show you how to do things the \u0026ldquo;Godot Way\u0026rdquo;. Code samples and example projects are available for all articles.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/physics/godot3_kinematic2d/",
	"title": "Using KinematicBody2D",
	"tags": [],
	"description": "",
	"content": " Godot offers a number of collision objects to provide both collision detection and response. Trying to decide which one to use for your project can be confusing. You can avoid problems and simplify development if you understand how each each works and what their pros and cons are. In this tutorial, we\u0026rsquo;ll look at the KinematicBody2D node and show some examples of how it can be used.\nIntroduction: Physics bodies In game development you often need to know when two objects in the game space intersect or come into contact. This is known as collision detection. When a collision is detected, you typically want something to happen. This is known as collision response.\nGodot offers three kinds of physics bodies, grouped under the PhysicsBody2D type:\n StaticBody2D  A static body is one that is not moved by the physics engine. It participates in collision detection, but does not move in response to the collision. This type of body is most often used for objects that are part of the environment or that do not need to have any dynamic behavior.\n RigidBody2D  This is the node that implements simulated 2D physics. You do not control a RigidBody2D directly, but instead you apply forces to it (gravity, impulses, etc.) and the physics engine calculates the resulting movement. See Godot 3.0: Rigid Bodies for more information.\n KinematicBody2D  A body that provides collision detection, but no physics. All movement must be implemented in code.\nCollision shapes A physics body can hold any number of Shape2D objects as children. These shapes are used to define the object\u0026rsquo;s collision bounds and to detect contact with other objects.\n Note: In order to detect collisions, at least one Shape2D must be assigned to the object.\n The most common way to assign a shape is by adding a CollisionShape2D or CollisionPolygon2D as a child of the object. These nodes allow you to draw the shape directly in the editor workspace.\n Note: Be careful to never scale your collision shapes in the editor. The Scale property in the Inspector should remain at (1, 1). When changing the size of the collision shape, you should always use the shape\u0026rsquo;s handles, not the Node2D scale handles. Changing the scale can result in unexpected collision behavior.\n !player_coll_shape.png\nCollision Layers and Masks One of the most powerful but frequently misunderstood collision features in Godot is the collision layer system. This system allows you to build up very complex interactions between a variety of objects. The key concepts are layers and masks. Each CollisionObject2D has 32 different physics layers it can interact with.\nLet\u0026rsquo;s look at each of the properties in turn:\n collision_layer describes the layers that the object appears in. By default, all bodies are on layer 1.\n collision_mask describes what layers the body will scan for collisions. If an object isn\u0026rsquo;t in one of the mask layers, the body will ignore it. By default, all bodies scan layer 1.\n  You can also assign names to layers. In \u0026ldquo;Project Settings\u0026rdquo;, look for the \u0026ldquo;Layer Names -\u0026gt; 2D Physics\u0026rdquo; section:\nA body\u0026rsquo;s layer properties can be configured via code, or directly in the Inspector:\nExample:\nYou have three nodes with the following configuration:\n    Layers Mask     Player 1 2, 3   Enemy 2 1   Coin 3 1    In this scenario, the Player node would detect collisions with both Enemy and Coin nodes (because they are in layers it scans). However, Enemy and Coin nodes would not detect each other, because they only scan layers they are not in.\nKinematic Bodies KinematicBody2D is for implementing bodies that are to be controlled via code. They detect collisions with other bodies when moving, but are not affected by engine physics properties like gravity or friction. While this means that you have to write some code to create their behavior, it also means you have more precise control over how they move and react.\n Note: A KinematicBody2D can be affected by gravity and other forces, but you must calculate the movement in code. The physics engine will not move a KinematicBody2D.\n Movement and collision When moving a KinematicBody2D, you should not set its position directly. Instead, you use the move_and_collide() or move_and_slide() methods. These methods move the body along a given vector and will instantly stop if a collision is detected with another body. After a KinematicBody2D has collided, any collision response must be coded manually.\n Note: Kinematic body movement should only be done in the _physics_process() callback.\n move_and_collide This method takes one parameter: a Vector2 indicating the body\u0026rsquo;s relative movement. Typically, this is your velocity vector multiplied by the frame timestep (delta). If the engine detects a collision anywhere along this vector, the body will immediately stop moving. If this happens, the method will return a KinematicCollision2D object.\nKinematicCollision2D When a KinematicBody2D detects a collision, Godot provides a KinematicCollision2D object. This object contains data about the collision and the colliding object. Using this data you can calculate your collision response.\nmove_and_slide The move_and_slide() method is intended to simplify the collision response in the common case where you want one body to slide along the other. This is especially useful in platformers or top-down games, for example.\n NOTE: move_and_slide() automatically calculates frame-based movement using delta. Do not multiply your velocity vector by delta before passing it to move_and_slide().\n In addition to the velocity vector, move_and_slide takes a number of other parameters allowing you to customize the slide behavior:\nfloor_normal - default value: Vector2( 0, 0 )\nThis parameter allows you to define what surfaces the engine should consider to be the floor. Setting this lets you use the is_on_floor(), is_on_wall(), and is_on_ceiling() methods to detect what type of surface the body is in contact with. The default value means that all surfaces are considered walls.\nslope_stop_min_velocity - default value: 5\nThis is the minimum velocity when standing on a slope. This prevents a body from sliding down a slope when standing still.\nmax_bounces - default value: 4\nThis is the maximum number of collisions before the body stops moving. Setting this too low may prevent movement entirely.\nfloor_max_angle - default value: 0.785398 (in radians, equivalent to 45 degrees)\nThis is the maximum angle before a surface is no longer considered a \u0026ldquo;floor\u0026rdquo;.\nWhich to use? A common question from new Godot users is: \u0026ldquo;How do you decide which movement function to use?\u0026rdquo; Often the response is to use move_and_slide() because it\u0026rsquo;s \u0026ldquo;simpler\u0026rdquo;, but this is not necessarily the case. One way to think of it is that move_and_slide() is a special case, and move_and_collide() is more general. For example, the following two code snippets result in the same collision response:\nvar collision = move_and_collide(velocity * delta) if collision: velocity = velocity.slide(collision.normal) velocity = move_and_slide(velocity)\nAnything you do with move_and_slide() can also be done with move_and_collide(), it just might take a little more code. However, as we\u0026rsquo;ll see in the examples below, there are cases where move_and_slide() isn\u0026rsquo;t the response you want.\nExamples Download the Sample Project for the examples below.\nBasic movement If you\u0026rsquo;ve downloaded the sample project, this example is in the \u0026ldquo;BasicMovement.tscn\u0026rdquo; scene.\nFor this example, Add a KinematicBody2D with two children: a Sprite and a CollisionShape2D. As with many demos, we\u0026rsquo;ll use the Godot \u0026ldquo;icon.png\u0026rdquo; as the Sprite\u0026rsquo;s texture (drag it from the Filesystem dock to the \u0026ldquo;Texture\u0026rdquo; property of the Sprite). In the CollisionShape2D\u0026rsquo;s \u0026ldquo;Shape\u0026rdquo; property, select \u0026ldquo;New RectangleShape2D\u0026rdquo; and size the rectangle to fit over the sprite image.\nAttach a script to the KinematicBody2D and add the following code:\nextends KinematicBody2D var speed = 250 var velocity = Vector2() func get_input(): # Detect up/down/left/right keystate and only move when pressed velocity = Vector2() if Input.is_action_pressed(\u0026#39;ui_right\u0026#39;): velocity.x += 1 if Input.is_action_pressed(\u0026#39;ui_left\u0026#39;): velocity.x -= 1 if Input.is_action_pressed(\u0026#39;ui_down\u0026#39;): velocity.y += 1 if Input.is_action_pressed(\u0026#39;ui_up\u0026#39;): velocity.y -= 1 velocity = velocity.normalized() * speed func _physics_process(delta): get_input() move_and_collide(velocity * delta) Run this scene and you\u0026rsquo;ll see that move_and_collide() works as expected, moving the body along the velocity vector. Now let\u0026rsquo;s see what happens when you add some obstacles. Add a StaticBody2D with a rectangular collision shape. For visibility, you can use a sprite, a Polygon2D, or just turn on \u0026ldquo;Visible Collision Shapes\u0026rdquo; from the \u0026ldquo;Debug\u0026rdquo; menu.\nRun the scene again and try moving into the obstacle. You\u0026rsquo;ll see that the KinematicBody2D can\u0026rsquo;t penetrate the obstacle. However, try moving into the obstacle at an angle and you\u0026rsquo;ll find that the obstacle acts like glue - it feels like the body gets stuck.\nThis happens because there is no collision response. move_and_collide() just stops the body\u0026rsquo;s movement when a collision occurs. We need to code whatever response we want from the collision.\nTry changing the function to move_and_slide(velocity) and running again. Note that we removed delta from the velocity calculation.\nmove_and_slide() provides a default collision response of sliding the body along the collision object. This is useful for a great many game types, and may be all you need to get the behavior you want.\nNext, we\u0026rsquo;ll look at a few other examples.\nBouncing/reflecting and collision detection What if you don\u0026rsquo;t want a sliding collision response? For this example (\u0026ldquo;BounceandCollide.tscn\u0026rdquo; in the sample project), we have a character shooting bullets and we want the bullets to bounce off the walls.\nFor this example, we have three scenes: the main scene containing the Player, a Bullet, and a Wall. The Bullet and Wall are separate scenes so that they can be instanced.\nThe Player is controlled by W/S for forward/back and aims using the mouse. Here is the code for the Player, using move_and_slide():\nextends KinematicBody2D export (PackedScene) var Bullet export (int) var speed var velocity = Vector2() func get_input(): # add these actions in Project Settings -\u0026gt; Input Map velocity = Vector2() if Input.is_action_pressed(\u0026#39;backward\u0026#39;): velocity = Vector2(-speed/3, 0).rotated(rotation) if Input.is_action_pressed(\u0026#39;forward\u0026#39;): velocity = Vector2(speed, 0).rotated(rotation) if Input.is_action_just_pressed(\u0026#39;mouse_click\u0026#39;): shoot() func shoot(): # \u0026#34;Muzzle\u0026#34; is a Position2D placed at the barrel of the gun var b = Bullet.instance() b.start($Muzzle.global_position, rotation) get_parent().add_child(b) func _physics_process(delta): get_input() var dir = get_global_mouse_position() - global_position # Don\u0026#39;t move if too close to the mouse pointer if dir.length() \u0026gt; 5: rotation = dir.angle() velocity = move_and_slide(velocity) And the code for the Bullet:\nextends KinematicBody2D var speed = 750 var velocity = Vector2() func start(pos, dir): rotation = dir position = pos velocity = Vector2(speed, 0).rotated(rotation) func _physics_process(delta): var collision = move_and_collide(velocity * delta) if collision: velocity = velocity.bounce(collision.normal) if collision.collider.has_method(\u0026#34;hit\u0026#34;): collision.collider.hit() func _on_VisibilityNotifier2D_screen_exited(): queue_free() The action happens in _physics_process(). After using move_and_collide() if a collision occurs, a KinematicCollision2D object is returned (otherwise, the return is Nil).\nIf there is a returned collision, we use the normal of the collision to reflect the bullet\u0026rsquo;s velocity. bounce() is a Vector2 method.\nIf the colliding object (collider) has a hit method, we also call it. In the example project, we\u0026rsquo;ve added a flashing color effect to the Wall to demonstrate this.\nPlatforming with move_and_slide Let\u0026rsquo;s try one more example - one that often gets asked about - the 2D platformer. move_and_slide() is ideal for quickly getting a functional character controller up and running. If you\u0026rsquo;ve downloaded the sample project, you can find this in \u0026ldquo;Platformer.tscn\u0026rdquo;.\nFor this example, we\u0026rsquo;ll assume you have a level made of StaticBody2D objects. They can be any shape and size. In the sample project, we\u0026rsquo;re using a TileMap to lay out the level, but for the purposes of this demo, they could just as well be individual static bodies.\nWe\u0026rsquo;re also using the adorable \u0026ldquo;Sunny Land\u0026rdquo; art pack by Ansimuz for the art and character animations.\nHere\u0026rsquo;s the code for the player body:\nextends KinematicBody2D export (int) var run_speed export (int) var jump_speed export (int) var gravity enum {IDLE, RUN, JUMP} var velocity = Vector2() var state var anim var new_anim func _ready(): change_state(IDLE) func change_state(new_state): state = new_state match state: IDLE: new_anim = \u0026#39;idle\u0026#39; RUN: new_anim = \u0026#39;run\u0026#39; JUMP: new_anim = \u0026#39;jump_up\u0026#39; func get_input(): velocity.x = 0 var right = Input.is_action_pressed(\u0026#39;ui_right\u0026#39;) var left = Input.is_action_pressed(\u0026#39;ui_left\u0026#39;) var jump = Input.is_action_just_pressed(\u0026#39;ui_select\u0026#39;) if jump and is_on_floor(): change_state(JUMP) velocity.y = jump_speed if right: change_state(RUN) velocity.x += run_speed if left: change_state(RUN) velocity.x -= run_speed $Sprite.flip_h = velocity.x \u0026lt; 0 if !right and !left and state == RUN: change_state(IDLE) func _process(delta): get_input() if new_anim != anim: anim = new_anim $AnimationPlayer.play(anim) func _physics_process(delta): velocity.y += gravity * delta if state == JUMP: if is_on_floor(): change_state(IDLE) velocity = move_and_slide(velocity, Vector2(0, -1)) if position.y \u0026gt; 600: get_tree().reload_current_scene() We\u0026rsquo;re using a very rudimentary state machine to handle the transitions between the character\u0026rsquo;s idle, running, and jumping states.\nWhen using move_and_slide() the function returns a vector representing the movement that remained after the slide collision occurred. Setting that value back to the character\u0026rsquo;s velocity allows us to smoothly move up and down slopes. Try removing velocity = and see what happens if you don\u0026rsquo;t do this.\nAlso note that we\u0026rsquo;ve added Vector2(0, -1) as the floor normal. This is a vector pointing straight upward. This means that if the character collides with an object that has this normal, it will be considered a floor.\nUsing the floor normal allows us to make jumping work, using is_on_floor(). This function will only return true after a move_and_slide() collision where the colliding body\u0026rsquo;s normal is within 45 degrees of the given floor vector (this can be adjusted by setting floor_max_angle).\nThis also allows you to implement other features like wall jumps using is_on_wall(), for example.\nConclusion This introduction only scratches the surface of what\u0026rsquo;s possible with KinematicBody2D. As with all Godot nodes, the API documentation is your friend, so reference it frequently until you\u0026rsquo;re comfortable with the class methods.\nKinematic bodies are so useful, that I\u0026rsquo;ll probably do a followup \u0026ldquo;Know Your Nodes\u0026rdquo; exploring more uses. Please comment below if you have ideas or suggestions for other examples you\u0026rsquo;d like to see.\nDownload the sample project "
},
{
	"uri": "http://kidscancode.org/godot_recipes/recipes/godot3_inheritance/",
	"title": "Inheritance",
	"tags": [],
	"description": "",
	"content": " In this tutorial, we\u0026rsquo;ll explore how inheritance works in Godot. You can use inheritance in Godot to reuse code and create powerful hierarchies of object and scenes in your game.\nWe\u0026rsquo;ll imagine we\u0026rsquo;re making a classic top-down RPG and use Godot\u0026rsquo;s inheritance capabilities to create two different kinds of characters in the game.\nIntroduction In object oriented programming (OOP), inheritance is a powerful tool. Put briefly, you can define a class that inherits from another class. An object created using the first class will contain the methods and member variables of the \u0026ldquo;master\u0026rdquo; class as well as its own.\nGodot is strongly object-oriented, and offers the opportunity to use inheritance not just with objects (scripts) but also with scenes.\nHere\u0026rsquo;s a preview of what we\u0026rsquo;re making:\nThe green character is controlled by the player, and the other characters are NPCs, walking around the tile-based map semi-randomly.\nProject setup In Project Settings create four new input actions called \u0026ldquo;left\u0026rdquo;, \u0026ldquo;right\u0026rdquo;, \u0026ldquo;up\u0026rdquo;, and \u0026ldquo;down\u0026rdquo; and assign each of them to the matching arrow key. We\u0026rsquo;ll be using those names as dictionary keys, so make sure to note the spelling and capitalization.\nSet the display Width and Height to 640 by 480 (we\u0026rsquo;re using 32x32 tiles, so we don\u0026rsquo;t need much screen space for this demo).\nDownload the art (character spritesheets) and unzip it in the project folder.\nCreating Characters Both kinds of characters share a number of properties and functions:\n A spritesheet containing the 4-directional movement animations An AnimationPlayer to play the movement animations Grid-based movement (the character can only move one full \u0026ldquo;square\u0026rdquo; at a time) Collision detection with walls  We\u0026rsquo;ll start by creating a scene that will contain all of the above. Start with an Area2D and name it \u0026ldquo;Character\u0026rdquo;. Give it the following children:\n Sprite CollisionShape2D Tween (named MoveTween) AnimationPlayer  We\u0026rsquo;ll leave the Sprite without a texture for now, but in the Inspector set its Vframes and Hframes properties to 4 and 3 respectively.\nNext, create a RectangleShape2D in the collision shape and set its Extents property in the Inspector to (10, 18).\n NOTE: Because all the characters are drawn to the same scale, we can be confident that the same sized collision shape will work for all characters. If this isn\u0026rsquo;t the case with the art you\u0026rsquo;re using, you can skip setting the collision shape here and configure it later for the inherited scenes.\n Animations Create four animations in the AnimationPlayer node. Name them to match the four directions we used in the input actions. For each animation, we\u0026rsquo;re going to set the length to 0.8 and add a track for the Sprite\u0026rsquo;s Frame property. The pattern for each direction is listed below. See the screenshot for an example of the end result.\n   direction frames     left 9, 10, 11, 10   down 6, 7, 8, 7   right 3, 4, 5, 4   up 0, 1, 2, 1    Collision Detection Because the characters are moving on a grid, they will either move the full amount to the next tile or not at all. This means that before moving, the character needs to check if the move is possible. Add four RayCast2D nodes and set their names and Cast To properties as follows:\n   Name Cast To     RayCastRight (32, 0)   RayCastLeft (-32, 0)   RayCastDown (0, 32)   RayCastUp (0, -32)    Make sure to set the Enabled property on each one (RayCast2Ds are disabled by default). Your final node setup should look something like this:\nCharacter Script Now add a script to the Character node (it will automatically be named \u0026ldquo;Character.gd\u0026rdquo;).\nFirst, we\u0026rsquo;ll define our class variables:\nextends Area2D var tile_size = 32 var can_move = true var facing = \u0026#39;right\u0026#39; var moves = {\u0026#39;right\u0026#39;: Vector2(1, 0), \u0026#39;left\u0026#39;: Vector2(-1, 0), \u0026#39;up\u0026#39;: Vector2(0, -1), \u0026#39;down\u0026#39;: Vector2(0, 1)} var raycasts = {\u0026#39;right\u0026#39;: \u0026#39;RayCastRight\u0026#39;, \u0026#39;left\u0026#39;: \u0026#39;RayCastLeft\u0026#39;, \u0026#39;up\u0026#39;: \u0026#39;RayCastUp\u0026#39;, \u0026#39;down\u0026#39;: \u0026#39;RayCastDown\u0026#39;}  can_move is a flag that will track whether the character can move. It will be false while a movement is already underway. facing is the current direction of movement. Note that the moves and raycasts dictionaries\u0026rsquo; keys match the input actions we created.\nNext is the code that will execute a movement from one square to another:\nfunc move(dir): if get_node(raycasts[facing]).is_colliding(): return facing = dir can_move = false $AnimationPlayer.play(facing) $MoveTween.interpolate_property(self, \u0026#34;position\u0026#34;, position, position + moves[facing] * tile_size, 0.8, Tween.TRANS_SINE, Tween.EASE_IN_OUT) $MoveTween.start() return true We pass a direction to move(). If the RayCast2D for that direction detects a collision, the move is canceled. Otherwise, we change facing to that direction, disable movement, and start playing the matching animation. To actually execute the movement, we use the Tween node to interpolate the position property from its current value to its current value plus a 32-pixel movement in the given direction. The duration is set to 0.8 which matches the animation length.\n Note: See the Tween documentation for details on how the interpolate_property() method works.\n Finally, to enable movement again, we need to reset can_move when the movement has finished. Connect the tween_completed signal from MoveTween and add the following:\nfunc _on_MoveTween_tween_completed( object, key ): can_move = true Implementing the Player The player character needs to inherit all the properties we gave to Character as well as adding keyboard controlled movement.\nWe\u0026rsquo;ll start by making a new scene. However, instead of making a new empty scene, click on Scene -\u0026gt; New Inherited Scene in the menu. Select the Character.tscn. Rename the root node from \u0026ldquo;Character\u0026rdquo; to \u0026ldquo;Player\u0026rdquo; and save the new scene.\nAll we need to do for the Sprite is set the texture, so choose a character you like from the \u0026ldquo;res://art/rpgsprites1\u0026rdquo; folder and drag it to the Texture property.\nNext, we need a new script for the player, so remove the attached one (\u0026ldquo;Character.gd\u0026rdquo;) and attach a new one. In the \u0026ldquo;Attach Node Script\u0026rdquo; dialog, click the folder icon next to the Inherits option and choose \u0026ldquo;Character.gd\u0026rdquo;.\nHere\u0026rsquo;s our player script (note that it extends the character script):\nextends \u0026#34;res://Character.gd\u0026#34; func _process(delta): if can_move: for dir in moves.keys(): if Input.is_action_pressed(dir): move(dir) Because we\u0026rsquo;ve inherited all the behavior from \u0026ldquo;Character.gd\u0026rdquo;, we only need to worry about control. Here, we\u0026rsquo;re using the _process() function to check the keystate each frame. However, only if can_move allows it do we actually check the keys and call move().\nRun the scene and try it out.\nNPC characters Hopefully you\u0026rsquo;re seeing how inheritance works by now, but let\u0026rsquo;s make another type of character: an NPC that will wander around the screen randomly. Make another scene inheriting from \u0026ldquo;Character.tscn\u0026rdquo; and name it NPC.\nThis time, leave the sprite\u0026rsquo;s Texture blank and add a new script, again inheriting from \u0026ldquo;Character.gd\u0026rdquo;.\nextends \u0026#34;res://Character.gd\u0026#34; var textures = [\u0026#39;mage_f.png\u0026#39;, \u0026#39;mage_m.png\u0026#39;, \u0026#39;healer_f.png\u0026#39;, \u0026#39;healer_m.png\u0026#39;, \u0026#39;townfolk1_f.png\u0026#39;, \u0026#39;townfolk1_m.png\u0026#39;] func _ready(): randomize() var texture = textures[randi() % textures.size()] texture = load(\u0026#34;res://art/rpgsprites1/%s\u0026#34; % texture) $Sprite.texture = texture facing = moves.keys()[randi() % 4] func _process(delta): if can_move: if not move(facing) or randi() % 10 \u0026gt; 5: facing = moves.keys()[randi() % 4] This time, we\u0026rsquo;re using _ready() to select a random texture and assign it. We\u0026rsquo;re also choosing a random starting direction.\nAs with the player, we\u0026rsquo;ll use _process() to trigger the movement, but this time we\u0026rsquo;ll use the fact that the move() function returns true if it successfully executes (if the raycast detects an obstacle, it returns false). So if the NPC can\u0026rsquo;t move, it will pick a new random direction. For variety, we also add a 50% chance that it will change direction anyway.\nRun the scene and observe the NPC wandering randomly around the screen.\nTesting Collisions Finally, to confirm that the collision detection is working, let\u0026rsquo;s create a small scene for the characters to wander around in. We\u0026rsquo;ll use a TileMap to quickly draw our map.\n Note: See my Tilemap tutorial for details on using TileMaps in Godot.\n There are two tiles (\u0026ldquo;grass.png\u0026rdquo; and \u0026ldquo;stone.png\u0026rdquo;) in the art folder. There is also a TileSet called \u0026ldquo;tiles.tres\u0026rdquo; to save you the step of making your own. In it, only the stone tile has a collision shape, so it will be our obstacle.\nCreate a new \u0026ldquo;Main\u0026rdquo; scene (I usually like to use a plain Node as the root). Add a TileMap and drag \u0026ldquo;tileset.tres\u0026rdquo; into its Tile Set property. Also don\u0026rsquo;t forget to change the Size to (32, 32).\nDraw some walls as you like, and then add a Player instance and a few instances of NPC. Remember, the characters won\u0026rsquo;t know anything about the map - they just know if they can move one tile or not. If you want them to line up properly, you need to make sure the characters\u0026rsquo; starting positions are centered on a tile. This is easy to do if you turn on \u0026ldquo;Snap to Grid\u0026rdquo;. Click the \u0026ldquo;Use Snap\u0026rdquo; button and then open the grid menu by clicking on the three dots next to it:\nUnder \u0026ldquo;Configure Snap\u0026hellip;\u0026rdquo; set the Grid Step and Grid Offset:\nNow you can drag the instanced characters around and they\u0026rsquo;ll always snap to the center of a tile.\nConclusion Imagine we had built this project without using inheritance. The Player and NPC would each have their own scene setup and individual scripts. If we decided to change how we wanted movement to work, we would have to change everything twice. If we added more character types (Monsters, Pets, etc.) the duplicated code would multiply and quickly become unmanageable. With the setup we created above, everything is in one place, and any change to the character automatically propagates to everything that extends it.\nAs you\u0026rsquo;re working on your own projects, look for opportunities to consolidate code and use inheritance for your scenes and/or scripts. As your projects grow in size and complexity, it will quickly become a lifesaver.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/physics/godot3_kyn_rigidbody1/",
	"title": "Using Rigid Bodies",
	"tags": [],
	"description": "",
	"content": " At the time of this writing, Godot 3.0 is nearing release, and many new users are trying it out. Recently I\u0026rsquo;ve seen a lot of confusion around physics and physics bodies, especially rigid bodies, which are Godot\u0026rsquo;s \u0026ldquo;true\u0026rdquo; physics nodes.\nIn this tutorial, I\u0026rsquo;ll explain when (and when not) to use rigid bodies, how they work, and demonstrate a few handy tricks to bend them to your will. The examples will use RigidBody2D, but the lessons apply equally to 3D.\nIntroduction  RigidBody2D is the physics body in Godot that provides simulated physics. This means that you don\u0026rsquo;t control a RigidBody2D directly. Instead you apply forces to it (gravity, impulses, etc.) and Godot\u0026rsquo;s built-in physics engine calculates the resulting movement, including collisions, bouncing, rotating, etc.\nYou can modify a RigidBody2D\u0026rsquo;s behavior via properties such as \u0026ldquo;Mass\u0026rdquo;, \u0026ldquo;Friction\u0026rdquo;, or \u0026ldquo;Bounce\u0026rdquo;, which can be set in the Inspector:\nThe body\u0026rsquo;s behavior is also affected by the world, via the Project Settings -\u0026gt; Physics properties, or by entering an  Area2D that is overriding the global physics properties.\nUsing RigidBody2D One of the benefits of using a rigid body is that a lot of behavior can be gotten \u0026ldquo;for free\u0026rdquo; without writing any code. For example, let\u0026rsquo;s look at making a rudimentary \u0026ldquo;Angry Birds\u0026rdquo;-style game with falling blocks. You only need to create RigidBody2Ds for the blocks and projectile, and set their properties. Stacking, falling, and bouncing will automatically be handled by the physics engine.\nStacking blocks Start by making a RigidBody2D for the block and adding Sprite and CollisionShape2D children:\nAdd a texture to the Sprite and a rectangular collision shape. IMPORTANT: Do not change the Scale of the collision shape! In general this is a bad idea, and will result in unexpected collision behavior. Always use the shape\u0026rsquo;s inner size handles and not the outer Node2D-derived scale handles.\n NOTE: For the textures in this example, I\u0026rsquo;m using the Physics Asset pack from Kenney.nl. It contains a wide variety of blocks in different shapes and materials.\n Press \u0026ldquo;Play\u0026rdquo; and you\u0026rsquo;ll see the block fall slowly downward. This is due to the default global gravity. You can find this setting in \u0026ldquo;Project Settings\u0026rdquo; under Physics -\u0026gt; 2d. You can also try changing the Block\u0026rsquo;s Gravity Scale property in the Inspector. I\u0026rsquo;m using a value of 3.\nNow create a Main scene (I usually use a Node) for the root). Add a few StaticBody2D nodes with rectangular collision shapes to serve as your \u0026ldquo;ground\u0026rdquo; and walls.\nInstance a Block, and then duplicate it (Ctrl-D on Windows and Cmd-D on MacOS) so you can make a nice stack. Something like this:\nProjectile Create another scene with the same node setup as your Block, but name this one \u0026ldquo;Ball\u0026rdquo;. Use one of the round textures and a circular collision shape. Instance this in your Main scene and place it somewhere to the side of the stack of blocks.\nTo cause a rigid body to move, it must have some velocity. You can give the body an initial velocity using the Linear -\u0026gt; Velocity property. Try setting this to (500, 0).\nYou can also tinker with the ball\u0026rsquo;s Friction and Bounce properties. Both of these properties can range from zero to one. I like a bounce of around 0.5.\n IMPORTANT: NEVER scale a physics body! If you try, a warning will appear, and when the scene runs, the physics engine will automatically set the scale back to (1, 1).\n Forces Reset the linear velocity to (0, 0). Now what if you want to be able to toss the ball? You should never set a rigid body\u0026rsquo;s velocity or position manually - remember, these are simulating \u0026ldquo;real-world\u0026rdquo; style physics. In the real world, objects can\u0026rsquo;t instantly jump from place to place or from a standstill to a high speed. If you try and do so, the physics engine will resist it, and unexpected movement can occur. Instead, we must apply forces which create an acceleration in a certain direction (also known as Newton\u0026rsquo;s Second Law). Godot physics objects work in the same way.\nTo add force to a rigid body, you have two functions to choose from:\n add_force()  Adds a continuous force to the body. Imagine a rocket\u0026rsquo;s thrust, steadily pushing it faster and faster. Note that this adds to any already existing forces. The force continues to be applied until removed.\n apply_impulse()  Adds an instantaneous \u0026ldquo;kick\u0026rdquo; to the body. Imagine hitting a baseball with a bat.\nWe\u0026rsquo;ll use apply_impulse() to kick the ball when we click, drag, and release the mouse button.\nOpen \u0026ldquo;Project Settings\u0026rdquo; and in the \u0026ldquo;Input Map\u0026rdquo; tab, add a new action called \u0026ldquo;click\u0026rdquo;. Connect it to the left mouse button.\nNext, add a script to the Ball, and add the following code:\nextends RigidBody2D var dragging var drag_start = Vector2() func _input(event): if event.is_action_pressed(\u0026#34;click\u0026#34;) and not dragging: dragging = true drag_start = get_global_mouse_position() if event.is_action_released(\u0026#34;click\u0026#34;) and dragging: dragging = false var drag_end = get_global_mouse_position() var dir = drag_start - drag_end apply_impulse(Vector2(), dir * 5) This script toggles dragging on when the mouse button is pressed and records the location of the click. When the button is released, we find the vector from the click point to the release point and use that to apply the impulse (multiplying by 5 to scale it up). apply_impulse() also takes an offset as its first parameter. This lets you \u0026ldquo;hit\u0026rdquo; the body off center, if you wish. For instance, try setting it to Vector2(25, 0) and you\u0026rsquo;ll add some spin to the ball when it\u0026rsquo;s launched.\nControlling Rigid Bodies There are cases where you need more direct control of a rigid body. For example, imagine you\u0026rsquo;re trying to make a version of the classic game \u0026ldquo;Asteroids\u0026rdquo;. The player\u0026rsquo;s spaceship needs to rotate using the left/right arrow keys, and to move forward when the up arrow is pressed.\nHere\u0026rsquo;s the image I\u0026rsquo;m using for my ship:\nI recommend you also go to OpenGameArt and search for a nice space background (but this is totally optional).\nCreate a new scene for the ship as we did above with the following node structure:\n RigidBody2D  Sprite CollisionShape2D    Note: In Godot 3.0, 0 degrees points to the right (along the x axis). This means you need to add a Rotation of 90 to the Sprite so it will match the body\u0026rsquo;s direction.\n By default, the physics settings provide some damping, which reduces a body\u0026rsquo;s velocity and spin. In space, there\u0026rsquo;s no friction, so there shouldn\u0026rsquo;t be any damping at all. However, for the \u0026ldquo;Asteroids\u0026rdquo; feel, we want the ship to stop rotating when we let go of the keys, so set the ship\u0026rsquo;s Angular -\u0026gt; Damp to 5.\nextends RigidBody2D export (int) var engine_thrust export (int) var spin_thrust var thrust = Vector2() var rotation_dir = 0 var screensize func _ready(): screensize = get_viewport().get_visible_rect().size func get_input(): if Input.is_action_pressed(\u0026#34;ui_up\u0026#34;): thrust = Vector2(engine_thrust, 0) else: thrust = Vector2() rotation_dir = 0 if Input.is_action_pressed(\u0026#34;ui_right\u0026#34;): rotation_dir += 1 if Input.is_action_pressed(\u0026#34;ui_left\u0026#34;): rotation_dir -= 1 func _process(delta): get_input() func _physics_process(delta): set_applied_force(thrust.rotated(rotation)) set_applied_torque(rotation_dir * spin_thrust) Let\u0026rsquo;s walk through what this script is doing. The two variables, engine_thrust and spin_thrust control how fast the ship can accelerate and turn. In the Inspector, set them to 500 and 25000 respectively (the units of torque make for large numbers). thrust will represent the ship\u0026rsquo;s engine state: (0, 0) when coasting, or a vector with the length of engine_thrust when powered on. rotation_dir will represent what direction the ship is turning. The screensize variable will capture the size of the screen, which we\u0026rsquo;ll be using later.\nNext, the input() function captures the keystates and sets the ship\u0026rsquo;s thrust on or off, and the rotation direction (rotation_dir) positive or negative. This function is called every frame in _process().\nFinally, physics-related functions should be called in _physics_process(). Here we use set_applied_force() to apply the thrust in whatever direction the ship is facing. Then we use set_applied_torque() to cause the ship to rotate.\nPlay the scene - you should be able to fly around freely.\nThe Position Problem Another feature of \u0026ldquo;Asteroids\u0026rdquo; is that the screen \u0026ldquo;wraps around\u0026rdquo;. If the player goes off one side, it teleports to the other side. But we already talked above about how you can\u0026rsquo;t change a rigid body\u0026rsquo;s position without breaking the physics engine. This presents a huge problem when working with rigid bodies.\nA common mistake is to try adding something like this to _physics_process():\nfunc _physics_process(delta): if position.x \u0026gt; screensize.x: position.x = 0 if position.x \u0026lt; 0: position.x = screensize.x if position.y \u0026gt; screensize.y: position.y = 0 if position.y \u0026lt; 0: position.y = screensize.y set_applied_force(thrust.rotated(rotation)) set_applied_torque(rotation_dir * spin_thrust) This fails spectacularly, trapping the player on the edge of the screen (with occasional glitches). So why doesn\u0026rsquo;t this work? The docs say _physics_process() is for physics-related stuff, right?\nNot exactly. _physics_process() is synced to the physics timestep, but that doesn\u0026rsquo;t make it OK to use for just anything. Hope is not lost, however, the answer is in the docs.\nTo quote the RigidBody2D docs:\n You should not change a RigidBody2D’s position or linear_velocity every frame or even very often. If you need to directly affect the body’s state, use _integrate_forces, which allows you to directly access the physics state.\n And the description for _integrate_forces:\n Allows you to read and safely modify the simulation state for the object. Use this instead of _physics_process if you need to directly change the body’s position or other physics properties.\n So there\u0026rsquo;s our answer. Instead of using _physics_process() we need to use _integrate_forces(), which gives us access to the Physics2DDirectBodyState. I highly recommend you take a look at the linked document, there is a lot of really useful data provided in the physics state object. For our purposes, the key piece of information is the body\u0026rsquo;s Transform2D. (Explaining transforms is beyond the scope of this document - see Matrices and transforms for more information.)\nThe body\u0026rsquo;s position is contained in the transform\u0026rsquo;s origin. Change _physics_process() to _integrate_forces() and add the following code:\nfunc _integrate_forces(state): set_applied_force(thrust.rotated(rotation)) set_applied_torque(rotation_dir * spin_thrust) var xform = state.get_transform() if xform.origin.x \u0026gt; screensize.x: xform.origin.x = 0 if xform.origin.x \u0026lt; 0: xform.origin.x = screensize.x if xform.origin.y \u0026gt; screensize.y: xform.origin.y = 0 if xform.origin.y \u0026lt; 0: xform.origin.y = screensize.y state.set_transform(xform) We grab the current transform, change it as necessary, and set it back as the new transform. The physics engine stays happy, and everything works as expected:\nConclusion When used properly, rigid bodies are a powerful tool in your Godot toolkit. Many users get in trouble, however, when they use them for the wrong purposes, or fail to understand exactly how they work.\n"
},
{
	"uri": "http://kidscancode.org/godot_recipes/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://kidscancode.org/godot_recipes/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]
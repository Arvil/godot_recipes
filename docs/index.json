[{"uri":"http://kidscancode.org/godot_recipes/recent/","title":"Fresh Recipes","tags":[],"description":"","content":"Here you can find the most recently added recipes:\n AI: Context-based Steering 3D Kinematic Car: Base 3D: Smooth rotation 2D: Multitarget camera 2D: Draw trajectory 2D: Ballistic bullet UI: Displaying debug data 3D: KinematicBody: Align with surface UI: Radial popup menu UI: Cooldown button  "},{"uri":"http://kidscancode.org/godot_recipes/g101/start/","title":"Getting Started","tags":[],"description":"","content":"Getting Started Have you downloaded Godot yet? You can get it here: https://godotengine.org\nIn this section: \rWhat is Godot?\r\r\rGodot\u0026#39;s Editor: Finding your way around\r\r\rNodes: Godot\u0026#39;s building blocks\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/g101/3d/101_3d_01/","title":"The 3D Editor","tags":[],"description":"","content":"In this tutorial, we\u0026rsquo;ll look at how to start working in 3D in Godot. You\u0026rsquo;ll learn how to navigate in the 3D editor, how to create and manipulate 3D objects, and how to work with some of Godot\u0026rsquo;s essential 3D nodes, such as cameras and lighting.\nAre you ready? A word of warning: 3D development can be quite a bit more complex than working in 2D. While many of the same principles apply - such as working with nodes, writing scripts, and handling logic/data - 3D brings with it a number of other considerations. For this reason, it\u0026rsquo;s a good idea to stick to 2D for your first few projects, moving to 3D once you have a good understanding of the game development process. This tutorial will assume you have completed at least an introductory Godot 2D project, such as the one in the [official Godot tutorial] (https://docs.godotengine.org/en/latest/getting_started/step_by_step/your_first_game.html).\nGetting Started in 3D One of Godot\u0026rsquo;s strengths is its ability to handle both 2D and 3D games. While much of what you\u0026rsquo;ve learned working on 2D projects (nodes, scenes, signals, etc.) applies equally well in 3D, there is also a whole new layer of complexity and capabilities. First, you\u0026rsquo;ll find that there are some additional features available in the 3D editor window, so we\u0026rsquo;ll start there:\nOrienting in 3D Space When you first open a new project in Godot, you will see the 3D project view:\n 3D view   --\rThe first thing you should notice is the three colored lines in the center. These are the x (red), y (green), and z (blue) axes. The point where they meet is the origin, which has the coordinates (0, 0, 0). You\u0026rsquo;ll find that this color scheme will also apply elsewhere in the Inspector.\nDifferent 3D applications follow different conventions for orientation. Godot uses Y-Up orientation, so that when looking at the axes, if x is pointing to the left/right, then y is up/down, and z is forward/back. Some other popular 3D software uses Z-UP. It\u0026rsquo;s good to keep this in mind when moving between applications.\n\rNavigation in 3D is performed using the mouse and keyboard. Here are the basic controls for the view camera:\n Mousewheel up/down: zoom in/out Middle button + drag: orbit camera around current target Shift + middle button + drag: pan camera Right-click + drag: rotate camera in place  In addition, if you\u0026rsquo;re familiar with popular 3D games, you might prefer Freelook mode, which you can toggle on/off using Shift+F. In this mode, you can use the WASD keys to fly around the scene while aiming with the mouse.\nYou can also alter the camera\u0026rsquo;s view by clicking on the [Perspective] label in the upper-left corner. Here, you can snap the camera to a particular orientation.\nAdding 3D Objects Now let\u0026rsquo;s add our first 3D node. Just as all 2D nodes inherit from Node2D, which provides properties such as position and rotation, 3D nodes inherit from Spatial. Add one to your scene and you\u0026rsquo;ll see the following object appear at the origin:\nThis object is not the node. It is something called a 3D gizmo. Gizmos are tools that allow you to move and rotate objects in space. The three rings control rotation, while the three arrows move (translate) the object along the three axes. Note that the rings and arrows are color-coded to match the axis colors.\nTake a few minutes to experiment and get familiar with the gizmo. Use Undo if you find yourself getting lost.\nSometimes you may feel the gizmos are getting in your way. You can click on the mode icons to restrict yourself to only one type of transformation: move, rotate, or scale: \rGlobal vs. Local Space By default, the gizmo controls operate in global space. When you rotate the object, the gizmo\u0026rsquo;s arrows still point along the axes. However, if you click the \u0026ldquo;Local Space Mode\u0026rdquo; button, the gizmo will switch to moving the body in local space.\nNow when you rotate the object, the gizmo arrows point along the object\u0026rsquo;s axes and not the world\u0026rsquo;s. Switching back and forth between Local and World space can make it much easier to place an object exactly where you want it.\nTransforms Look at the Inspector for the Spatial node. Instead of a Position property, you have Translation, as well as Rotation Degrees, and Scale. Drag the object around with the gizmo and observe how these values change.\nYou\u0026rsquo;ll also find a Transform property, which changes as you move the object. A transform is a matrix that describes an object\u0026rsquo;s translation, rotation, and scale all in one. The math behind transforms can get quite complex - you\u0026rsquo;ll start working with them in a later tutorial.\nMeshes Just like a Node2D, a Spatial has no size or appearance of its own. In 2D, you would use a Sprite to add a texture to the node. In 3D, you need to add a mesh. A mesh is a mathematical description of a shape. It consists of a collection of points, called vertices. These vertices are connected by lines, called edges, and multiple edges (at least three) together make a face.\nFor example, a cube is made up of 8 vertices, 12 edges, and 6 faces.\nAdding Meshes Typically, meshes are created by using 3D modeling software, such as Blender. You can also find many collections of 3D models available for download, if you\u0026rsquo;re unable to create your own. However, often you just need a basic shape such as a cube or sphere. In this case, Godot provides a way to create simple meshes called primitives.\nAdd a MeshInstance node as a child of the Spatial and in the Inspector, click its Mesh property:\nHere you can see the list of available primitives. They represent a handy collection of common useful shapes. Select \u0026ldquo;New CubeMesh\u0026rdquo; and you\u0026rsquo;ll see a plain cube appear on the screen. Note that the cube is white by default, although it may appear slightly blue on your screen due to the default ambient lighting. We\u0026rsquo;ll talk about lighting a little bit later.\nCameras Try running the scene with your cube object. Did you see anything? In 3D, you won\u0026rsquo;t see anything in the game viewport without adding a Camera. Add one and use the camera\u0026rsquo;s gizmo to position it pointing towards the cube:\nThe pinkish-purple pyramid shape on the camera is called the fustrum and represents the camera\u0026rsquo;s view. Notice the small triangular arrow which represents the camera\u0026rsquo;s \u0026ldquo;up\u0026rdquo; orientation. As you\u0026rsquo;re moving the camera around, try pressing the \u0026ldquo;Preview\u0026rdquo; button in the upper-left to see what the camera sees. Play the scene to verify everything is working as expected.\nWrapping Up In this tutorial you learned how to use Godot\u0026rsquo;s 3D editor, how to add 3D nodes such as Spatial, MeshInstance, and Camera, and how to use gizmos to place your objects. You also learned a bunch of new terminology. Hopefully you\u0026rsquo;re not overwhelmed.\nIn the next part, we\u0026rsquo;ll look at how to build a 3D scene by importing 3D assets and how to use more of Godot\u0026rsquo;s 3D nodes.\nYou can also find a video version of this lesson here:\n  \r--\r"},{"uri":"http://kidscancode.org/godot_recipes/g101/start/101_01/","title":"What is Godot?","tags":[],"description":"","content":"Game Engines Game development is complex and involves a wide variety of knowledge and skills. In order to build a modern game, you need a lot of underlying technology before you can make the actual game itself. Imagine if you had to build your own computer and write your own operating system before you could even start programming. Game development would be a lot like that if you truly had to start from scratch and build everything you needed.\nIn addition, there are a number of common needs every game has. For example, no matter what your game is, it\u0026rsquo;s going to need to draw things on the screen. If the code to do that has already been written, it makes more sense to reuse it that to create it all over again for every game. This is where game engines come in.\nA game engine is a collection of tools and technologies designed to assist in developing games. This allows you to focus more on building your game, and less on reinventing the wheel. Here are some of the features a good game engine will provide:\n Rendering (2D/3D)  \u0026ldquo;Rendering\u0026rdquo; is the process of displaying your game on the player\u0026rsquo;s screen. A good rendering pipeline needs to work with modern GPU features, high resolution displays, and effects like lighting and perspective, while maintaining a high frame rate.\n Physics  Building an accurate and usable physics engine is an enormous task. Most games require some sort of collision detection and response, and many need simulated physics (ie. friction, inertia, etc.), but few developers want to take on the task of writing one.\n Platform Support  In today\u0026rsquo;s market, you want to be able to release your game on multiple platforms, such as mobile, web, PC, and/or console. A game engine lets you build your game once and export it to one or more platforms.\n Development Environment  All of these tools are brought together in a single application, combining everything into one environment so you don\u0026rsquo;t have to learn a new workflow for every new project.\nThere are dozens of popular game engines to choose from today, such as Unity, Unreal, and GameMaker Studio, to name a few. It is important to remember that the majority of popular engines are commercial products. They may or may not be free to download, but the will require some kind of licensing or royalty agreement if you plan to release your game (and especially if your game makes money). You need to carefully read and understand what you\u0026rsquo;re agreeing to and what you are and are not allowed to do with the engine.\nWhy use Godot? \nClick here to download Godot.\rIn contrast to the above, Godot is completely free and open source, released under the very permissive MIT license. This means there are no fees, hidden costs, or royalties you need to pay. This is in addition to being a fully featured modern game engine.\nAs a developer, the benefits are great. Because it\u0026rsquo;s unencumbered by commercial licensing, you have complete control over exactly how and where your game is distributed. In addition, Godot\u0026rsquo;s open source nature also means there is a much greater level of transparency than you\u0026rsquo;ll find with commercial engines. For example, if you find a particular feature doesn\u0026rsquo;t quite meet your needs, you\u0026rsquo;re free to modify the engine itself - no permission required.\n"},{"uri":"http://kidscancode.org/godot_recipes/g101/","title":"Godot 101","tags":[],"description":"","content":" Godot 101 Your introduction to the Godot game engine. If you\u0026rsquo;ve never used a game engine before, or if you’re just new to Godot, this is the place to start.\nIn this section: \rGetting Started\r\r\r\rWhat is Godot?\r\r\rGodot\u0026#39;s Editor: Finding your way around\r\r\rNodes: Godot\u0026#39;s building blocks\r\r\r\rGDScript\r\r\r\r\rIntro to 3D\r\r\r\rThe 3D Editor\r\r\rImporting 3D Objects\r\r\rCreating a 3D Character\r\r\rUsing Areas\r\r\rEdge Detection \u0026amp; Mouse Capture\r\r\rUsing CSG\r\r\rFirst-person Character\r\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/3d/kinematic_car/car_base/","title":"3D Kinematic Car: Base","tags":[],"description":"","content":"Problem You\u0026rsquo;re looking to make a 3D driving or racing game and don\u0026rsquo;t know where to start.\nSolution Even in 3D, cars tend to remain on the ground. For this reason, movement can (mostly) be treated as if it were 2D. Much of the car\u0026rsquo;s movement code will be very much like the 2D: Car Steering recipe. It\u0026rsquo;s recommended that you review that recipe before proceeding with this one.\n\rGodot does provide a VehicleBody node, which is based on RigidBody and includes a complex simulation of engine, braking, suspension, etc. However, this introduces a lot of complexity and tends to be overkill for most casual racing/driving games. For that reason, we\u0026rsquo;re going with a KinematicBody based solution here.\nIf you\u0026rsquo;re interested in how to work with VehicleBody, I highly recommend this series by Bastiaan Olij.\n\rSetting up the car Before we start coding, we need to find a 3D model of a car and import it to Godot.\nImporting the Model Here\u0026rsquo;s the car model we\u0026rsquo;ll use for this demonstration:\nYou can find this and other car models in Kenney\u0026rsquo;s \u0026ldquo;Car Kit\u0026rdquo;, available here: https://kenney.nl/assets/car-kit. Download the whole kit, you can use some of the other cars later.\n\rTo import the car, find the model in the \u0026quot;Models/GLTF format\u0026quot; folder. In our case, we want the sedanSports.glb. Drop this file in your new Godot project, preferably in a separate folder such as res://assets/cars/.\nSelect the file in Godot and go to the \u0026ldquo;Import\u0026rdquo; tab. Change the Root Type to \u0026ldquo;KinematicBody\u0026rdquo; and click \u0026ldquo;Reimport\u0026rdquo;. Now we\u0026rsquo;re ready to use this car.\nSetting up the KinematicBody Double-click on the sedanSports.glb file and choose \u0026ldquo;New Inherited\u0026rdquo;. You\u0026rsquo;ll have a new scene that looks like this:\nNote the individual meshes for each of the car\u0026rsquo;s parts. There\u0026rsquo;s also a stray \u0026ldquo;tmpParent\u0026rdquo; Spatial node, but we can ignore that.\nThe KinematicBody has a warning about missing collision shapes, so we\u0026rsquo;ll need to fix that first. We\u0026rsquo;re going to add 3 CollisionShapes: a BoxShape for the car\u0026rsquo;s body, and a CylinderShape for each of the front and rear axles.\nOnce the shapes are set up they should look something like this:\nTo ensure the front and rear shapes match, just create and size one of them, then duplicate it. It is also a good idea to name the CollisionShape nodes to help keep track of them - CollisionBody, CollisionWheelsFront, and CollisionWheelsRear would be a good example.\n\rBase script We want to be able to make cars that can be driven by human or AI control. In either case, most of the movement code will be the same - it\u0026rsquo;s really just the input that will be different. For this reason, we can use a base car script that can be shared between them.\nMake a new script called car_base.gd. We\u0026rsquo;ll start with our variables: some exports to allow for adjusting the car\u0026rsquo;s behavior, and some others to track its state.\nextends KinematicBody # Car behavior parameters, adjust as needed export var gravity = -20.0 export var wheel_base = 0.6 # distance between front/rear axles export var steering_limit = 10.0 # front wheel max turning angle (deg) export var engine_power = 6.0 export var braking = -9.0 export var friction = -2.0 export var drag = -2.0 export var max_speed_reverse = 3.0 # Car state properties var acceleration = Vector3.ZERO # current acceleration var velocity = Vector3.ZERO # current velocity var steer_angle = 0.0 # current wheel angle   Note that rather than using a gravity variable you can set the global value in \u0026ldquo;Project Settings\u0026rdquo;. Having it separate does allow for different behavior for different game objects. It\u0026rsquo;s up to you, use whichever works best for your game.\n  engine_power and braking will apply for accelerating and decelerating the car.\n  drag and friction are explained here.\n  The rest of the script will be very similar to the 2D version, which a few changes to work correctly with Spatials and Transforms.\nWe\u0026rsquo;ll start with _physics_process().\nHere we check if the car is on the ground before applying controls - you can\u0026rsquo;t steer in mid-air! Then we apply the standard movement equations.\nNote that we\u0026rsquo;re using move_and_slide_with_snap(), which will keep the car from coming off slopes (if your track has them). We\u0026rsquo;re also using the car\u0026rsquo;s local down vector as the snap - again, to handle slopes correctly.\nfunc _physics_process(delta): if is_on_floor(): get_input() apply_friction(delta) calculate_steering(delta) acceleration.y = gravity velocity += acceleration * delta velocity = move_and_slide_with_snap(velocity, -transform.basis.y, Vector3.UP, true) This function applies friction (proportional to the car\u0026rsquo;s velocity) and drag (proportional to the velocity squared). This will not only slow the car when not applying power, but it will also determine the car\u0026rsquo;s maximum speed.\nfunc apply_friction(delta): if velocity.length() \u0026lt; 0.2 and acceleration.length() == 0: velocity.x = 0 velocity.z = 0 var friction_force = velocity * friction * delta var drag_force = velocity * velocity.length() * drag * delta acceleration += drag_force + friction_force Finally, we need to calculate turning, using the same simplified \u0026ldquo;bicycle\u0026rdquo; model we used in the 2D car. Once the new velocity is found, look_at() rotates the body to point in the correct direction. We\u0026rsquo;re not including drifting/traction here - that will come later.\nWe can also handle reverse by checking the dot product of the new heading (the direction the car is facing) with the velocity.\nfunc calculate_steering(delta): var rear_wheel = transform.origin + transform.basis.z * wheel_base / 2.0 var front_wheel = transform.origin - transform.basis.z * wheel_base / 2.0 rear_wheel += velocity * delta front_wheel += velocity.rotated(transform.basis.y, steer_angle) * delta var new_heading = rear_wheel.direction_to(front_wheel) var d = new_heading.dot(velocity.normalized()) if d \u0026gt; 0: velocity = new_heading * velocity.length() if d \u0026lt; 0: velocity = -new_heading * min(velocity.length(), max_speed_reverse) look_at(transform.origin + new_heading, transform.basis.y) Finally, we\u0026rsquo;ll have a function to \u0026ldquo;decide\u0026rdquo; how the car is controlled. We\u0026rsquo;ll override this in the individual cars - with key/gamepad input for player-controlled cars, and with AI decision-making in computer-controlled ones.\nfunc get_input(): # Override this in inherited scripts for controls pass Player controls Now we\u0026rsquo;re ready to add some player controls. Here\u0026rsquo;s the InputMap setup:\nIf you have a gamepad with an analog stick, it\u0026rsquo;s highly recommended you use it. With keyboard controls, which can only be pressed or not, you can only turn the \u0026ldquo;steering wheel\u0026rdquo; to the maximum value. An analog stick allows for a much better experience. We\u0026rsquo;ll make sure the code works with both.\nHere\u0026rsquo;s the script to attach to the car KinematicBody:\nextends \u0026#34;res://cars/car_base.gd\u0026#34; func get_input(): var turn = Input.get_action_strength(\u0026#34;steer_left\u0026#34;) turn -= Input.get_action_strength(\u0026#34;steer_right\u0026#34;) steer_angle = turn * deg2rad(steering_limit) $tmpParent/sedanSports/wheel_frontRight.rotation.y = steer_angle*2 $tmpParent/sedanSports/wheel_frontLeft.rotation.y = steer_angle*2 acceleration = Vector3.ZERO if Input.is_action_pressed(\u0026#34;accelerate\u0026#34;): acceleration = -transform.basis.z * engine_power if Input.is_action_pressed(\u0026#34;brake\u0026#34;): acceleration = -transform.basis.z * braking First, we get the input action for steering, which results in a value between -1 and 1. Then we convert that to an angle in radians based on the maximum allowed angle.\nThe next step rotates the wheel meshes to give some visual feedback of the steering. Note that we\u0026rsquo;re multiplying it by 2 to make it more exaggerated, since you\u0026rsquo;ll typically be looking at the car from some distance.\nAfter steering, we check the accelerate/brake inputs to set the car\u0026rsquo;s acceleration.\nWrapping up That\u0026rsquo;s the bare-bones car controller. Feel free to use this as a starter for your game. If you\u0026rsquo;re looking to add more, here are some of the topics we\u0026rsquo;ll address in follow-up recipes:\n Traction and drifting Chase camera and camera control AI/NPC control (steering, obstacle avoidance, track following) Slopes and ramps  Download the project file here: https://github.com/kidscancode/3d_car_tutorial/releases\n\rRelated recipes  2D: Car Steering recipe Input Actions 3D: KinematicBody Movement  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/audio/audio_manager/","title":"Audio Manager","tags":[],"description":"","content":"Problem You\u0026rsquo;ve tried adding an AudioStreamPlayer to your mob/coin/etc. to play when the object dies or is collected. But the problem is that when you remove the object, the audio player goes with it, chopping off the sound. You need an easier way to manage playing audio.\nSolution We\u0026rsquo;ll solve this problem with a node that is available from anywhere in the SceneTree. This node manages a set of AudioStreamPlayer nodes and a queue of sound streams to play.\nCreate a new script in the script editor.\nextends Node\rvar num_players = 8\rvar bus = \u0026#34;master\u0026#34;\rvar available = [] # The available players.\r var queue = [] # The queue of sounds to play.\r func _ready():\r# Create the pool of AudioStreamPlayer nodes.\r for i in num_players:\rvar p = AudioStreamPlayer.new()\radd_child(p)\ravailable.append(p)\rp.connect(\u0026#34;finished\u0026#34;, self, \u0026#34;_on_stream_finished\u0026#34;, [p])\rp.bus = bus\rfunc _on_stream_finished(stream):\r# When finished playing a stream, make the player available again.\r available.append(stream)\rfunc play(sound_path):\rqueue.append(sound_path)\rfunc _process(delta):\r# Play a queued sound if any players are available.\r if not queue.empty() and not available.empty():\ravailable[0].stream = load(queue.pop_front())\ravailable[0].play()\ravailable.pop_front()\rSet this script as an autoload in Project Settings. Give it an easily recognizable name, such as \u0026ldquo;AudioStreamManager\u0026rdquo;.\nAnywhere in your project that you want to play a sound, use:\nAudioStreamManager.play(\u0026#34;res://path/to/sound\u0026#34;)\r\rThis audio manager is adapted with thanks from [SFXPlayer by TheDuriel] (https://github.com/TheDuriel/DurielsGodotUtilities).\n\rExample project Below you can download an example project showing the use of the audio manager node. This project reads a folder full of audio files and generates a grid of buttons. Click the button to play the sound.\nAt the top, you can see the audio manager\u0026rsquo;s live statistics.\nDownload the project file here: audio_manager.zip\n\rRelated recipes   --  "},{"uri":"http://kidscancode.org/godot_recipes/3d/camera_gimbal/","title":"Camera Gimbal","tags":[],"description":"","content":"Problem You need a camera controller, using mouse or keyboard, that remains level while rotating and following a target.\nSolution Try this: take a Camera node and rotate it a small amount around X (the red ring on the gizmo), then a small amount around Z (the blue ring). Now reverse the X rotation and click the \u0026ldquo;Preview\u0026rdquo; button. Observe how the camera is now tilted.\nThe solution to this problem is to place the camera on a gimbal - a device designed to keep an object level during movement. We can create a gimbal using two Spatial nodes, which will control the camera\u0026rsquo;s left/right and up/down rotation respectively.\nThe node setup should look like this:\n- CameraGimbal (Spatial)\r- InnerGimbal (Spatial)\r- Camera\rSet the Transform/Translation of the Camera to (0, 0, 4).\nHere\u0026rsquo;s how the gimbal works: the outer spatial node can only be rotated in Y, while the inner one rotates only in X. You can test this out by rotating them manually, but make sure you change to \u0026ldquo;Local Space Mode\u0026rdquo; first (that\u0026rsquo;s the cube icon next to the lock in the menu bar - the keyboard shortcut to toggle is \u0026ldquo;T\u0026rdquo;). Remember to only move the green ring of the outer node and only the red ring of the inner one. Don\u0026rsquo;t touch the camera node at all.\n\nReset all the rotations to 0 once you\u0026rsquo;ve finished experimenting.\nKeyboard control We\u0026rsquo;ll start with the keyboard controls, then add an option to use the mouse as well. Here are the required actions and their assigned inputs:\n   Action Name Input     \u0026quot;cam_up\u0026quot; W   \u0026quot;cam_down\u0026quot; S   \u0026quot;cam_right\u0026quot; D   \u0026quot;cam_left\u0026quot; A   \u0026quot;cam_zoom_in\u0026quot; Wheel Up   \u0026quot;cam_zoom_out\u0026quot; Wheel Down    Here\u0026rsquo;s the initial script. Note that we\u0026rsquo;re making sure to rotate each Spatial in its local space around the specific axis, as described above.\nextends Spatial\rvar rotation_speed = PI/2\rfunc get_input_keyboard(delta):\r# Rotate outer gimbal around y axis\r var y_rotation = 0\rif Input.is_action_pressed(\u0026#34;cam_right\u0026#34;):\ry_rotation += 1\rif Input.is_action_pressed(\u0026#34;cam_left\u0026#34;):\ry_rotation += -1\rrotate_object_local(Vector3.UP, y_rotation * rotation_speed * delta)\r# Rotate inner gimbal around local x axis\r var x_rotation = 0\rif Input.is_action_pressed(\u0026#34;cam_up\u0026#34;):\rx_rotation += -1\rif Input.is_action_pressed(\u0026#34;cam_down\u0026#34;):\rx_rotation += 1\r$InnerGimbal.rotate_object_local(Vector3.RIGHT, x_rotation * rotation_speed * delta)\rfunc _process(delta):\rget_input_keyboard(delta)\rMake a test scene with a MeshInstance and instance the CameraGimbal in it to test out the movement.\nYou\u0026rsquo;ll notice that holding the up/down control will cause the camera to rotate all the way around, eventually becoming upside-down. To prevent this, we can clamp the rotation.\nfunc _process(delta):\rget_input_keyboard(delta)\r$InnerGimbal.rotation.x = clamp($InnerGimbal.rotation.x, -1.4, -0.01)\rThe -1.4 value lets it go almost to 90 degrees up, while setting a very small value for the minimum keeps the camera from clipping into the ground. Feel free to experiment with other values.\nMouse control We\u0026rsquo;ll add a flag called mouse_control to enable easy toggling of mouse/keyboard controls.\n# mouse properties\r var invert_y = false\rvar invert_x = false\rvar mouse_control = false\rvar mouse_sensitivity = 0.005\rfunc _unhandled_input(event):\rif mouse_control and event is InputEventMouseMotion:\rif event.relative.x != 0:\rvar dir = 1 if invert_x else -1\rrotate_object_local(Vector3.UP, dir * event.relative.x * mouse_sensitivity)\rif event.relative.y != 0:\rvar dir = 1 if invert_y else -1\r$InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * event.relative.y * mouse_sensitivity)\rfunc _process(delta):\rif !mouse_control:\rget_input_keyboard(delta)\rThis code works by converting horizontal mouse motion to Y rotation of the outer gimbal and vertical to X rotation for the inner gimbal. We\u0026rsquo;ve also added invert_x and invert_y flags so that you can flip the motion in either axis - many players prefer one over the other, so it\u0026rsquo;s best to allow for both options.\nAlso, in _process() we disable keyboard input when using mouse control.\nYou may notice a problem with the up/down movement if you move the mouse too quickly. A large value for event.relative.y results in \u0026ldquo;skipping\u0026rdquo; to the opposite side of the clamped value. We can solve this by clamping the vertical mouse movement to a reasonable value. Change the above code for y to this:\nif event.relative.y != 0:\rvar dir = 1 if invert_y else -1\rvar y_rotation = clamp(event.relative.y, -30, 30)\r$InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * y_rotation * mouse_sensitivity)\r\rIn your project, you\u0026rsquo;ll probably also want to capture the mouse during gameplay. See the linked recipe at the end of this document for details.\n\rCamera zoom Camera zoom works by varying the scale of the gimbal system.\n# zoom settings\r var max_zoom = 3.0\rvar min_zoom = 0.5\rvar zoom_speed = 0.09\rvar zoom = 1.5\rfunc _unhandled_input(event):\rif event.is_action_pressed(\u0026#34;cam_zoom_in\u0026#34;):\rzoom -= zoom_speed\rif event.is_action_pressed(\u0026#34;cam_zoom_out\u0026#34;):\rzoom += zoom_speed\rzoom = clamp(zoom, min_zoom, max_zoom)\rfunc _process(delta):\rscale = lerp(scale, Vector3.ONE * zoom, zoom_speed)\rUsing lerp() to change the zoom level results in smoother zooming.\nFollowing a target Once you have the camera gimbal set up, it can follow a target by adding the following:\nexport (NodePath) var target\rfunc _process(delta):\rif target:\rglobal_transform.origin = get_node(target).global_transform.origin\rInstance the camera in your scene and use the Inspector to choose the node you want to follow.\nFinal script For completeness, here\u0026rsquo;s the full script, including export variables for all the camera settings, so that you can configure it in your project.\nextends Spatial\rexport (NodePath) var target\rexport (float, 0.0, 2.0) var rotation_speed = PI/2\r# mouse properties\r export (bool) var mouse_control = false\rexport (float, 0.001, 0.1) var mouse_sensitivity = 0.005\rexport (bool) var invert_y = false\rexport (bool) var invert_x = false\r# zoom settings\r export (float) var max_zoom = 3.0\rexport (float) var min_zoom = 0.4\rexport (float, 0.05, 1.0) var zoom_speed = 0.09\rvar zoom = 1.5\rfunc _unhandled_input(event):\rif Input.get_mouse_mode() != Input.MOUSE_MODE_CAPTURED:\rreturn\rif event.is_action_pressed(\u0026#34;cam_zoom_in\u0026#34;):\rzoom -= zoom_speed\rif event.is_action_pressed(\u0026#34;cam_zoom_out\u0026#34;):\rzoom += zoom_speed\rzoom = clamp(zoom, min_zoom, max_zoom)\rif mouse_control and event is InputEventMouseMotion:\rif event.relative.x != 0:\rvar dir = 1 if invert_x else -1\rrotate_object_local(Vector3.UP, dir * event.relative.x * mouse_sensitivity)\rif event.relative.y != 0:\rvar dir = 1 if invert_y else -1\rvar y_rotation = clamp(event.relative.y, -30, 30)\r$InnerGimbal.rotate_object_local(Vector3.RIGHT, dir * y_rotation * mouse_sensitivity)\rfunc get_input_keyboard(delta):\r# Rotate outer gimbal around y axis\r var y_rotation = 0\rif Input.is_action_pressed(\u0026#34;cam_right\u0026#34;):\ry_rotation += 1\rif Input.is_action_pressed(\u0026#34;cam_left\u0026#34;):\ry_rotation += -1\rrotate_object_local(Vector3.UP, y_rotation * rotation_speed * delta)\r# Rotate inner gimbal around local x axis\r var x_rotation = 0\rif Input.is_action_pressed(\u0026#34;cam_up\u0026#34;):\rx_rotation += -1\rif Input.is_action_pressed(\u0026#34;cam_down\u0026#34;):\rx_rotation += 1\rx_rotation = -x_rotation if invert_y else x_rotation\r$InnerGimbal.rotate_object_local(Vector3.RIGHT, x_rotation * rotation_speed * delta)\rfunc _process(delta):\rif !mouse_control:\rget_input_keyboard(delta)\r$InnerGimbal.rotation.x = clamp($InnerGimbal.rotation.x, -1.4, -0.01)\rscale = lerp(scale, Vector3.ONE * zoom, zoom_speed)\rif target:\rglobal_transform.origin = get_node(target).global_transform.origin\rRelated recipes  Capturing the Mouse Intro to 3D  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/ai/chase/","title":"Chasing the player","tags":[],"description":"","content":"Problem You want an enemy to chase the player.\nSolution The first step in getting an enemy to chase the player is to determine what direction the enemy needs to move. To get the vector pointing from A to B, you subtract: B - A. Normalize the result and you have a direction vector.\nThis makes the solution quite straightforward. Every frame, set the enemy\u0026rsquo;s velocity to point in the direction of the player.\nvelocity = (player.position - position).normalized() * speed\rGodot\u0026rsquo;s Vector2 object has a built-in helper for this:\nvelocity = position.direction_to(player.position) * speed\rHowever, this would allow the enemy to chase the player from any distance, even if it\u0026rsquo;s far away. To fix this, we can add an Area2D to the enemy, and only chase the player when it\u0026rsquo;s inside this \u0026ldquo;detect radius\u0026rdquo;.\nHere\u0026rsquo;s some example code:\nextends KinematicBody2D\rvar run_speed = 25\rvar velocity = Vector2.ZERO\rvar player = null\rfunc _physics_process(delta):\rvelocity = Vector2.ZERO\rif player:\rvelocity = position.direction_to(player.position) * run_speed\rvelocity = move_and_slide(velocity)\rfunc _on_DetectRadius_body_entered(body):\rplayer = body\rfunc _on_DetectRadius_body_exited(body):\rplayer = null\rWe\u0026rsquo;ve connected the body_entered and body_exited signals from the Area2D so that the enemy knows whether it\u0026rsquo;s in range or not.\nThe above assumes that the player is the only body that will enter/exit, which is usually done by setting the appropriate collision layers/masks.\n\r\nThis concept can be extended to other types of games as well. The key is to find the direction vector from the enemy to the player:\n# 2D\r (player.position - position).normalized()\r# 3D\r (player.transform.origin - transform.origin).normalized()\rIf, for example, your game is a side-scroller or has other constraints in movement, you can use only the x component of the resulting vector to determine movement.\nLimitations Note that this method results in very simplistic straight-line movement. The enemy will not move around obstacles such as walls, nor will it stop if it gets too close to the player.\nAnother problem is more apparent with fast-moving enemies. As the player moves, the enemies using this technique will change direction instantly. For a more natural-looking movement, you\u0026rsquo;ll want to use a steering behavior.\nFor more advanced behaviors, see the other recipes in this chapter.\nRelated recipes  Top-down character Homing missile  "},{"uri":"http://kidscancode.org/godot_recipes/2d/enter_exit_screen/","title":"Entering/Exiting the screen","tags":[],"description":"","content":"Problem You want to detect when an object enters or exits the screen.\nSolution The engine provides a node for this: VisibilityNotifier2D. Attach this node to your object, and you\u0026rsquo;ll be able to use its screen_entered and screen_exited signals.\nExample 1 Consider a projectile that travels in a straight line after it\u0026rsquo;s fired. If we continue firing, eventually we\u0026rsquo;ll have a large number of objects for the engine to track, event though they\u0026rsquo;re offscreen, which can cause lag.\nHere\u0026rsquo;s the movement code for the projectile:\nextends Area2D\rvar velocity = Vector2(500, 0)\rfunc _process(delta):\rposition += velocity * delta\rTo have the projectile automatically deleted when it moves offscreen, add a VisibilityNotifier2D and connect its screen_exited signal.\nfunc _on_VisibilityNotifier2D_screen_exited():\rqueue_free()\rExample 2 We have an enemy that performs some actions, such as moving along a path or playing an animation. On a large map with many enemies, only a few of them will be onscreen at the same time. We can disable the enemy\u0026rsquo;s actions while it\u0026rsquo;s offscreen using VisibilityNotifier2D.\nPartial code:\nvar active = false\rfunc _process(delta):\rif active:\rplay_animation()\rmove()\rfunc _on_VisibilityNotifier2D_screen_entered():\ractive = true\rfunc _on_VisibilityNotifier2D_screen_exited():\ractive = false\r"},{"uri":"http://kidscancode.org/godot_recipes/math/interpolation/","title":"Interpolation","tags":[],"description":"","content":"Linear Interpolation, or its commonly-used abbreviation lerp, is a term that comes up often in game development. If you\u0026rsquo;ve never come across it before it can seem mysterious and highly-technical, but as you\u0026rsquo;ll see in this tutorial, it\u0026rsquo;s actually a straightforward concept with a wide variety of applications in game programming.\nNumeric Interpolation The core formula for linear interpolation is this:\nfunc lerp(a, b, t):\rreturn (1 - t) * a + t * b\rIn this formula, a and b represent the two values and t is the amount of interpolation, typically expressed as a value between 0 (which returns a), and 1 (which returns b). The function finds a value the given amount between the two. For example:\nx = lerp(0, 1, 0.75) # x is 0.75\r x = lerp(0, 100, 0.5) # x is 50\r x = lerp(10, 75, 0.3) # x is 29.5\r x = lerp(30, 2, 0.75) # x is 9\r It\u0026rsquo;s called linear interpolation because the path between the two points is a straight line.\nYou can animate a node\u0026rsquo;s properties with lerp(). For example, if you divide the elapsed time by the desired duration, you\u0026rsquo;ll get a value between zero and one you can use to alter a property smoothly over time. This script scales a sprite up to five times its starting size while fading it out (using modulate.a) over two seconds:\nextends Sprite\rvar time = 0\rvar duration = 2 # length of the effect\r func _process(delta):\rif time \u0026lt; duration:\rtime += delta\rmodulate.a = lerp(1, 0, time / duration)\rscale = Vector2.ONE * lerp(1, 5, time / duration)\rVector interpolation You can also interpolate between vectors. Both Vector2 and Vector3 provide linear_interpolate() methods for this.\nFor example, to find a vector that\u0026rsquo;s halfway between a Spatial node\u0026rsquo;s forward and left direction vectors:\nvar forward = -transform.basis.z\rvar left = transform.basis.x\rvar forward_left = forward.linear_interpolate(left, 0.5)\rThe following example moves a Sprite node towards the mouse click position. Each frame the node moves 10% of the way to the target. This results in an \u0026ldquo;approach\u0026rdquo; effect, where the object\u0026rsquo;s speed becomes slower the closer it gets to the target.\nextends Sprite\rvar target\rfunc _input(event):\rif event is InputEventMouseButton and event.pressed:\rtarget = event.position\rfunc _process(delta):\rif target:\rposition = position.linear_interpolate(target, 0.1)\rFor more advanced applications of interpolation, see Tween.\n"},{"uri":"http://kidscancode.org/godot_recipes/ui/labels/","title":"Labels","tags":[],"description":"","content":"Problem You want to display some text on the screen.\nSolution Sooner or later you\u0026rsquo;re going to need to display some text on your screen. Examples include a title, countdown timer, score counter, and many others. For the majority of these, Godot\u0026rsquo;s Label node is the answer.\nWorking with fonts Before you can start, you\u0026rsquo;re going to need a font. We\u0026rsquo;ll go into the full details of Godot\u0026rsquo;s font support in a separate recipe, but for our purposes, let\u0026rsquo;s assume you have a TTF or OTF font file. For using bitmap fonts, see the associated recipe.\nFor this example, we\u0026rsquo;ll use \u0026ldquo;Roboto\u0026rdquo; - a popular free font, which you can find on Google Fonts. You can also download here: Roboto_font.zip\n\rAdding a Label Add a new Label node to your scene. In the Inspector, you\u0026rsquo;ll see the node\u0026rsquo;s properties, most of which are self-explanatory (hover them with the mouse to see a description):\nGo ahead and add something in the Text field and experiment with how it looks. You\u0026rsquo;ll notice there is a default font, but it\u0026rsquo;s very plain (and small).\nAdding a DynamicFont To add your font in the Inspector, scroll down to and expand the Custom Fonts section. In the empty Font property, choose \u0026ldquo;New DynamicFont\u0026rdquo; and then click the new DynamicFont to expand it.\nDrag your font file (in this example we\u0026rsquo;re using Roboto-Medium.ttf) into the Font Data property (or choose \u0026ldquo;Load\u0026rdquo; and navigate to the file). There are several properties to adjust but for now let\u0026rsquo;s make Size a bit bigger.\nFeel free to tinker with how the others affect the text appearance. For example, in the picture below, the second label has the Filter property enabled:\nAdjusting color You can adjust the label\u0026rsquo;s font color in the Custom Colors section. Here you can change Font Color as well as add a shadow color. Shadow properties are set in the Custom Constants section.\nDynamically changing text If all you need in your scene is static text, then you\u0026rsquo;re done. However, if you need to update the label dynamically, you can do so in code by using the text property.\nFor example, if we had a Timer node in our scene, we could do the following:\nextends Control\rvar counter = 0\rfunc _ready():\r$Label.text = str(counter)\rfunc _on_Timer_timeout():\rcounter += 1\r$Label.text = str(counter)\rSee the \u0026ldquo;related recipes\u0026rdquo; section for more examples of using labels and working with UI nodes.\nDownload the project file here: screen_shake.zip\n\r--\rRelated recipes Like video?   --"},{"uri":"http://kidscancode.org/godot_recipes/2d/platform_character/","title":"Platform character","tags":[],"description":"","content":"Problem You need to make a 2D platform-style character.\nSolution New developers are often surprised at how complex a platform character can be to program. Godot provides some built-in tools to assist, but there are as many solutions as there are games. In this tutorial, we won\u0026rsquo;t be going in-depth with features like double-jumps, crouching, wall-jumps, or animation. Here we\u0026rsquo;ll discuss the fundamentals of platformer movement. See the rest of the recipes for other solutions.\nWhile it\u0026rsquo;s possible to use RigidBody2D to make a platform character, we\u0026rsquo;ll be focusing on KinematicBody2D. Kinematic bodies are well-suited for platformers, where you are less interested in realistic physics than in responsive, arcade feel.\n\rStart with a KinematicBody2D node, and add a Sprite and CollisionShape2D to it.\nAttach the following script to the root node of the character. Note that we\u0026rsquo;re using input actions we\u0026rsquo;ve defined in the InputMap: \u0026quot;walk_right\u0026quot;, \u0026quot;walk_left\u0026quot;, and \u0026quot;jump\u0026quot;. See InputActions.\nextends KinematicBody2D\rexport (int) var speed = 1200\rexport (int) var jump_speed = -1800\rexport (int) var gravity = 4000\rvar velocity = Vector2.ZERO\rfunc get_input():\rvelocity.x = 0\rif Input.is_action_pressed(\u0026#34;walk_right\u0026#34;):\rvelocity.x += speed\rif Input.is_action_pressed(\u0026#34;walk_left\u0026#34;):\rvelocity.x -= speed\rfunc _physics_process(delta):\rget_input()\rvelocity.y += gravity * delta\rvelocity = move_and_slide(velocity, Vector2.UP)\rif Input.is_action_just_pressed(\u0026#34;jump\u0026#34;):\rif is_on_floor():\rvelocity.y = jump_speed\rThe values used for speed, gravity, and jump_speed depend greatly on the size of your player sprite. The player\u0026rsquo;s texture in this example is 108x208 pixels. If your sprite is smaller, you\u0026rsquo;ll want to use smaller values. We also want high values so that everything feels fast and responsive. A low gravity results in a floaty-feeling game while a high value means you\u0026rsquo;re soon back on the ground and ready to jump again.\nNote that we\u0026rsquo;re checking is_on_floor() after using move_and_slide(). The move_and_slide() function sets the value of this method, so it\u0026rsquo;s important not to check it before, or you\u0026rsquo;ll be getting the value from the previous frame.\nFriction and acceleration The above code is a great start, and you can use it as the foundation for a wide variety of platform controllers. One problem it has, though, is the instantaneous movement. For a more natural feel, it\u0026rsquo;s better if the character has to accelerate up to its max speed and that it coasts to a stop when there is no input.\nOne way to add this behavior is to use linear interpolation (\u0026ldquo;lerp\u0026rdquo;). When moving, we will lerp between the current speed and the max speed and while stopping we\u0026rsquo;ll lerp between the current speed and 0. Adjusting the lerp amount will give us a variety of movement styles.\nFor an overview of linear interpolation, see Gamedev Math: Interpolation.\n\rexport (float, 0, 1.0) var friction = 0.1\rexport (float, 0, 1.0) var acceleration = 0.25\rfunc get_input():\rvar dir = 0\rif Input.is_action_pressed(\u0026#34;walk_right\u0026#34;):\rdir += 1\rif Input.is_action_pressed(\u0026#34;walk_left\u0026#34;):\rdir -= 1\rif dir != 0:\rvelocity.x = lerp(velocity.x, dir * speed, acceleration)\relse:\rvelocity.x = lerp(velocity.x, 0, friction)\rTry changing the values for friction and acceleration to see how they affect the game\u0026rsquo;s feel. An ice level, for example, could use very low values, making it harder to maneuver.\nConclusion This code gives you a starting point for building your own platformer controller. For more advanced platforming features such as wall jumps, see the other recipes in this section.\nDownload an example project using this recipe:\nDownload the project file here: platform_character.zip\n\rRelated Recipes  Input Intro Kinematic Friction  "},{"uri":"http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_01/","title":"Project setup","tags":[],"description":"","content":"Where to start? Depending on the game, and how fleshed-out your idea is, the answer might be very different. In our case, I\u0026rsquo;ve cheated a little bit by making a prototype of the game already and working out a few of the ideas ahead of time. Still, it diverged a bit from my initial idea, and so might this series - time will tell.\nIn a bigger project, you might start with design document, which could be as simple as a page of notes or as complex as a 500-page treatise laying out every detail of your game\u0026rsquo;s world, plot, and mechanics. We\u0026rsquo;ve no need of anything so involved here, so let\u0026rsquo;s just go over the gameplan.\nGameplan In this game, the player controls a \u0026ldquo;character\u0026rdquo; that jumps from circle to circle. Jumping is initiated by a click or touch, and if you don\u0026rsquo;t hit another circle, you lose. The score is related to how long you survive, and the difficulty will increase over time with circles that move, shrink, and/or expire. The idea is fast-paced, short games with a \u0026ldquo;top that\u0026rdquo; feel. As much as possible, the art will remain simple and clean, with visual and audio effects to add appeal.\nWe\u0026rsquo;ll be using GLES 3 to start. It\u0026rsquo;s not yet clear what if any impact this will have. Once we get to the mobile testing phase, we\u0026rsquo;ll see if a switch to GLES 2 is warranted.\n\rYou can also follow this project on  Github.\nGetting started Let\u0026rsquo;s start with the project settings. We need to define our screen size/ behavior. We want this to be a mobile game so it\u0026rsquo;s going to need to be portrait mode and able to adjust to variable screen sizes, since there are so many phone resolutions available.\nOpen Project Settings and find the Display/Window section. Set the screen size to (480, 854), the Handheld/Orientation to \u0026ldquo;Portrait\u0026rdquo;, the Stretch/Mode to \u0026ldquo;2d\u0026rdquo;, and the Stretch/Aspect to \u0026ldquo;Keep\u0026rdquo;.\nNext, in Input Devices/Pointing enable \u0026ldquo;Emulate Touch From Mouse\u0026rdquo;. This will let us write the code only using screen touch events, but still play by using the mouse on PC platforms.\nProject organization To keep things organized, we\u0026rsquo;re going to make a folder to hold the game objects (objects) and one for UI (gui). The game assets (images, audio, etc.) will go in an assets folder. You can download the starting assets here:\nDownload the project file here: circle_jump_assets.zip\n\rOnce we have the folders and the assets set up, we\u0026rsquo;re ready to start coding!\nGame Objects We have two game objects to make: the player (\u0026ldquo;jumper\u0026rdquo;) and the circle.\nJumper For movement and collision, we\u0026rsquo;re going to use a Area2D. To be fair, we could use KinematicBody2D here too, and it would work just as well. However, we don\u0026rsquo;t really need collision in this game, we just need to know when the jumper contacts a circle. Let\u0026rsquo;s add the following nodes:\n Area2D (\u0026ldquo;Jumper\u0026rdquo;)  Sprite CollisionPolygon2D VisibilityNotifier2D    Save the scene in res://objects/ and drag the circle image (res://assets/images/jumper.png) into the Sprite\u0026rsquo;s Texture. Note that all the game images are flat white. This will make it easier for us to dynamically color them later.\nSince the art is drawn pointing upwards, set the Sprite's Rotation property to 90.\nSelect the CollisionPolygon2D and add three points to cover the jumper\u0026rsquo;s triangular shape.\nNow let\u0026rsquo;s add a script to the body and start coding its behavior:\nFirst, the signals and variables:\nextends Area2D\rvar velocity = Vector2(100, 0) # start value for testing\r var jump_speed = 1000\rvar target = null # if we\u0026#39;re on a circle\r Next we\u0026rsquo;ll detect the screen touch and, if we\u0026rsquo;re on a circle, call our jump method:\nfunc _unhandled_input(event):\rif target and event is InputEventScreenTouch and event.pressed:\rjump()\rJumping means leaving a circle and traveling forward at our jump speed:\nfunc jump():\rtarget = null\rvelocity = transform.x * jump_speed\rWe\u0026rsquo;ll detect hitting a circle with the area_entered signal, so connect it. If we hit a circle, we\u0026rsquo;ll stop moving forward.\nfunc _on_Jumper_area_entered(area):\rtarget = area\rvelocity = Vector2()\rIf we are captured by a circle, we want to rotate around it. We\u0026rsquo;ll add a pivot on the circle, and match its transform so our orientation will always be facing outwards. Otherwise we move forward in a straight line.\nfunc _physics_process(delta):\rif target:\rtransform = target.orbit_position.global_transform\relse:\rposition += velocity * delta\rColor Shader See the Shaders section for help getting started using shaders.\n\rWe\u0026rsquo;re going to use a small shader to the Sprite so that we can customize its color. Select the Sprite and then in the Material property add a new ShaderMaterial. Click on that, and in Shader select \u0026ldquo;New Shader\u0026rdquo;, then click on that. The shader editor panel will open at the bottom.\nHere is the code for our color shader. It uses a uniform variable for the color, which allows us to choose a value from the Inspector or from our game script. Then it changes all the visible pixels of the texture into that color, preserving the alpha (transparency) value.\nshader_type canvas_item;\runiform vec4 color : hint_color;\rvoid fragment() {\rCOLOR.rgb = color.rgb;\rCOLOR.a = texture(TEXTURE, UV).a;\r}\rYou\u0026rsquo;ll now see a Shader Params section in the Inspector where you can set a color value:\nWe\u0026rsquo;ll want to use this same shader elsewhere, so in the Shader property, choose \u0026ldquo;Save\u0026rdquo; and save this as res://objects/color.shader.\nCircle The second game object is the circle, which will be instanced many times as the game progresses. Eventually, we\u0026rsquo;ll add a variety of behaviors such as moving, shrinking, etc., but for this first iteration, we just want it to capture the player.\nHere\u0026rsquo;s the starting node setup:\n Area2D (\u0026ldquo;Circle\u0026rdquo;)  Sprite CollisionShape2D Node2D (\u0026ldquo;Pivot\u0026rdquo;)  Position2D (\u0026ldquo;OrbitPosition\u0026rdquo;)      The \u0026ldquo;Pivot\u0026rdquo; node is how we\u0026rsquo;ll make the player orbit the circle. The \u0026ldquo;OrbitPosition\u0026rdquo; will be offset by whatever the size of the circle is, and the player will follow it.\nUse res://assets/images/circle1_n.png as the Sprite's texture. While we\u0026rsquo;re here, add a ShaderMaterial and choose \u0026ldquo;Load\u0026rdquo; to use the saved color.shader we made earlier.\nAdd a circle shape to the CollisionShape2D and attach a script to the root node.\nextends Area2D\ronready var orbit_position = $Pivot/OrbitPosition\rvar radius = 100\rvar rotation_speed = PI\rfunc _ready():\rinit()\rfunc init(_radius=radius):\rradius = _radius\r$CollisionShape2D.shape = $CollisionShape2D.shape.duplicate()\r$CollisionShape2D.shape.radius = radius\rvar img_size = $Sprite.texture.get_size().x / 2\r$Sprite.scale = Vector2(1, 1) * radius / img_size\rorbit_position.position.x = radius + 25\rfunc _process(delta):\r$Pivot.rotation += rotation_speed * delta\rIn the init() function, we\u0026rsquo;re setting up the size of the circle, based on the given radius. We need to size the collision shape as well as scaling the texture to match.\nTry running the scene with different values of radius to test. (Later we\u0026rsquo;ll stop calling init() in _ready()).\nMain Scene Now we can test out the interaction.\nCreate a \u0026ldquo;Main\u0026rdquo; scene using a Node2D and instance both the Jumper and the Circle in it. Arrange them so the jumper will hit the Circle (Jumper\u0026rsquo;s default velocity is (100, 0)).\nTry running. You should see the jumper get captured by the circle and start orbiting it. Clicking the mouse should then send the jumper flying off in whatever direction it\u0026rsquo;s pointing.\n Follow this project on Github: https://github.com/kidscancode/circle_jump\nLike video?   "},{"uri":"http://kidscancode.org/godot_recipes/2d/screen_wrap/","title":"Screen wrap","tags":[],"description":"","content":"Problem You want to allow the player to \u0026ldquo;wrap around\u0026rdquo; the screen, teleporting from one side of the screen to the other. This is a common feature, especially in old-school 2D games (think Pac-man).\nSolution   Get your screen (viewport) size\nonready var screen_size = get_viewport_rect().size\rget_viewport_rect() is available to any CanvasItem derived node.\n  Compare your player\u0026rsquo;s position\nif position.x \u0026gt; screen_size.x:\rposition.x = 0\rif position.x \u0026lt; 0:\rposition.x = screen_size.x\rif position.y \u0026gt; screen_size.y:\rposition.y = 0\rif position.y \u0026lt; 0:\rposition.y = screen_size.y\rNote that this is using the node\u0026rsquo;s position, which is usually the center of your sprite and/or body.\n  Simplifying with wrapf()\nThe above code can be simplified using GDScript\u0026rsquo;s wrapf() function, which \u0026ldquo;loops\u0026rdquo; a value between the given limits.\nposition.x = wrapf(position.x, 0, screen_size.x)\rposition.y = wrapf(position.y, 0, screen_size.y)\r  "},{"uri":"http://kidscancode.org/godot_recipes/shaders/intro/","title":"Shaders: intro","tags":[],"description":"","content":"Problem You want to get started coding shaders.\nSolution A shader is a special program that runs on the computer\u0026rsquo;s GPU (graphics card). The GPU is optimized to perform certain types of math very efficiently. Shader code can be attached to objects to affect how they\u0026rsquo;re rendered on the screen.\nThe output of a shader program is the color of the set of pixels of the object. Shaders can be used in 2d (canvas_item shaders) and 3D (spatial shaders).\nThe most difficult part for newcomers to understand about shaders is that they run in parallel. A shader runs simultaneously on all pixels. This allows for great speed, but also limits what information you have access to in the shader.\nTo add a shader to an object, find its Material property and select \u0026ldquo;New ShaderMaterial\u0026rdquo;. Click the new material to open it, and select \u0026ldquo;New Shader\u0026rdquo;. Click that, and you\u0026rsquo;ll see a shader editor open at the bottom of the screen.\nThe first line of the shader must specify its type. If the node it\u0026rsquo;s attached to is a CanvasItem:\nshader_type canvas_item;\rOr for a Spatial node:\nshader_type spatial;\rFor these first examples, let\u0026rsquo;s stick to 2D. Add a Sprite node and add shader following the steps above. You can use the Godot icon for its texture.\nThere are two basic types of shader we\u0026rsquo;ll discuss here: vertex and fragment.\nFragment shader Fragment shaders calculate the color of the pixel. Let\u0026rsquo;s look at an example:\nvoid fragment() {\rCOLOR = vec4(1.0, 0.0, 0.0, 1.0);\r}\rEvery pixel is red. COLOR is the output of the fragment shader and is applied to every pixel simultaneously. But what if we want some variation?\nUV coordinates In shaders, the pixel coordinates are specified in UV notation. These are normalized values ranging from (0, 0) (top-left) to (1, 1) (bottom-right).\nShaders use vectors (vec4) to represent RGBA colors. Individual compenents can be accessed using e.g. color.r. Treating colors as vectors allows for a variety of interesting effects based on vector math.\n\rvoid fragment() {\rCOLOR = vec4(UV.x, 0.0, 0.0, 1.0);\r}\rNow the red channel ranges from 0 on the left to 1.0 on the right, varying along with the UV.\nAnother example:\nvoid fragment() {\rCOLOR = vec4(UV.x, 1.0 - UV.y, 0.5, 1.0);\rTextures Notice that since we\u0026rsquo;re setting the pixel color directly, we\u0026rsquo;ve thrown away the Godot icon\u0026rsquo;s data. You can access that texture data using the TEXTURE input and texture() function:\nvoid fragment() {\rCOLOR = texture(TEXTURE, UV);\r}\rNow we\u0026rsquo;re back to the original image. Each pixel\u0026rsquo;s color is being set to the color value of the texture at the same UV position.\nIt\u0026rsquo;s also possible to change only one channel of the COLOR output:\nvoid fragment() {\rCOLOR = texture(TEXTURE, UV);\rCOLOR.a = 1.0 - UV.x;\r}\rThis ramps the alpha channel down, resulting in a fade-out effect.\nVarying with time Another useful built-in shader property is TIME, which gives an ever-increasing value representing the current elapsed time. If we also use the sin() function, which returns a value between -1 and 1, we can produce this effect:\nvoid fragment() {\rCOLOR = texture(TEXTURE, UV);\rCOLOR.a = abs(sin(TIME * 0.5));\r}\rOr this one:\nvoid fragment() {\rCOLOR = texture(TEXTURE, UV);\rCOLOR.a = max(0.0, UV.x - abs(sin(TIME)));\r}\rVertex shader Vertex shaders alter the vertices of the object, allowing for deformations and scaling. Just as fragment shaders run on every pixel, vertex shaders run on every vertex of an object. In a canvas_item shader, this typically means the four corners of the texture. In a spatial shader, it\u0026rsquo;s each vertex of the mesh.\nFor example, observe what happens with the following:\nvoid vertex() {\rVERTEX.x += UV.x * 10.0;\r}\rIn this shader, the two left vertices (0, 0) and (0, 1) are unchanged, but the right vertices become (10, 0) and (10, 1).\nVarying the vertex positions over time can produce a variety of interesting effects:\nvoid vertex() {\rVERTEX.y += sin(UV.x * TIME) * 10.0;\r}\rUniforms To pass a value to the shader, you need a variable declared with the uniform keyword. Once you do this, the variable appears in the Inspector in much the same way an export variable. However, a uniform\u0026rsquo;s value can not be changed in the shader!\nUniform values are global to the shader and can be accessed from any function.\nHints You can also use optional hints to assist in setting the value in the Inspector.\nuniform float radius : hint_range(0, 1);\rHints are available for a variety of data types. See the Shader Language Reference for a full list.\nWrapping up This is just a tiny introduction to what\u0026rsquo;s possible with shaders. See the rest of the recipes in this section for more examples you can use in your projects.\nRelated Recipes "},{"uri":"http://kidscancode.org/godot_recipes/2d/splitscreen_demo/","title":"Splitscreen multiplayer","tags":[],"description":"","content":"Introduction In this demo, we\u0026rsquo;ll consider a local multiplayer game - a topdown-style maze game with two players (one using arrow keys and the other using WASD controls). This is not a problem if our game world all fits on one screen, but if the map is large, we\u0026rsquo;ll want to have a \u0026ldquo;split screen\u0026rdquo; view tracking the two players separately.\nWe\u0026rsquo;ll also look at a quick way to set up a minimap display.\nGame setup We won\u0026rsquo;t spend a lot of time on the setup of the game world. The two players are KinematicBody2D objects using no-frills 8-way movement.\nIf you need help setting up this part, see the following section in the official Godot docs: 2D Movement Overview.\n\rEach player has its input actions set up in the Project Settings -\u0026gt; Input Map section: \u0026ldquo;right_1\u0026rdquo; to Right Arrow, \u0026ldquo;right_2\u0026rdquo; to D, etc. Note that by naming them this way, we can save time in the code by using:\nexport var id = 0\rfunc get_input():\rvelocity = Vector2()\rif Input.is_action_pressed(\u0026#39;right_%s\u0026#39; % id):\rvelocity.x += 1\r# etc. This way both characters can use the same script for movement. Just assign the appropriate value to id for each player.\nThe two players are added to a \u0026ldquo;World\u0026rdquo; scene containing a TileMap:\nIf you like, you can download the starting project, with the world already set up, here:\nsplitscreen_start.zip\nNote that the map is much larger than the game screen, but aside from that everything works as intended. Setting up your game \u0026ldquo;world\u0026rdquo; separately like this will make setting up the viewports much easier and more flexible.\nViewports, Cameras, and Worlds We\u0026rsquo;re going to start with a new scene that\u0026rsquo;s going to contain our two viewports. Create a node to serve as the root. I like to use Node since it has no properties of its own - it\u0026rsquo;s just there to contain the rest of the scene.\nBy themselves, Viewport nodes don\u0026rsquo;t have position information (they don\u0026rsquo;t inherit from Spatial or CanvasItem). We\u0026rsquo;re going to use ViewportContainer, a Control node, to hold each viewport. To keep them arranged side-by-side, we\u0026rsquo;ll use an HBoxContainer.\nSet the HBoxContainer\u0026rsquo;s Alignment to \u0026ldquo;Center\u0026rdquo; and to have a small gap between the two viewports, set Custom Constants/Separation to 5. In the \u0026ldquo;Layout\u0026rdquo; menu, choose \u0026ldquo;Full Rect\u0026rdquo;.\nNow add two ViewportContainers as children, naming them with a 2 and 1 (to match the player they\u0026rsquo;ll display). Set the Size Flags on both to \u0026ldquo;Fill, Expand\u0026rdquo; so that they will each expand to fill half of the screen. Also, check the Stretch property so that the Viewport will automatically be set to the size of the container.\nInside each of these containers add a Viewport. Note that if you set the viewport\u0026rsquo;s Size property, it will be reset by the container.\nIn order for a Viewport to display anything, we\u0026rsquo;ll need a Camera2D which will render onto the Viewport. Add one to each viewport. Don\u0026rsquo;t forget to check the Current property to activate the camera. We can also set each camera\u0026rsquo;s Zoom to (0.75, 0.75) to get a better view of the area around the player.\nYour node setup should look like this:\n┖╴Main (Node)\r┖╴Viewports (HBoxContainer)\r┠╴ViewportContainer2\r┃ ┖╴Viewport2\r┃ ┖╴Camera2D\r┖╴ViewportContainer1\r┖╴Viewport1\r┖╴Camera2D\r\rNote that we\u0026rsquo;ve put ViewportContainer1 second in the HBoxContainer. This will place it on the right side since Player 1 uses the arrow keys.\n\rAdding the World When we run the scene we won\u0026rsquo;t see anything because the viewports don\u0026rsquo;t have any \u0026ldquo;world\u0026rdquo; to render. A viewport\u0026rsquo;s world (for 3D) or world_2d property represent the source for the viewport\u0026rsquo;s environment and determine what will be rendered by its camera. The world can be set in code, but for 2D it will also display any child 2D nodes we add to it.\nLet\u0026rsquo;s instance the \u0026ldquo;World\u0026rdquo; scene as a child of Viewport1. Now when we play the scene we see the world inside the left viewport.\nWe also need to add a world to Viewport2, but we want it to use the same one. We can handle this in code. Attach a script to Main and add the following:\nextends Node\ronready var viewport1 = $Viewports/ViewportContainer1/Viewport1\ronready var viewport2 = $Viewports/ViewportContainer2/Viewport2\ronready var camera1 = $Viewports/ViewportContainer1/Viewport1/Camera2D\ronready var camera2 = $Viewports/ViewportContainer2/Viewport2/Camera2D\ronready var world = $Viewports/ViewportContainer1/Viewport1/World\rfunc _ready():\rviewport2.world_2d = viewport1.world_2d The onready node references are for convenience - we\u0026rsquo;ll be using them as we move forward. Remember that when you type \u0026ldquo;$\u0026rdquo; Godot will autosuggest node paths so you don\u0026rsquo;t have to type them. You can also drag a node from the scene tree into the script editor and you\u0026rsquo;ll get the node\u0026rsquo;s path.\nWhen we run the scene now, we see the world rendered in both viewports. However, neither camera is moving so we only see a small part of the world.\nSetting up the cameras Attach the following script to each camera:\nextends Camera2D\rvar target = null\rfunc _physics_process(delta):\rif target:\rposition = target.position Now we can assign a target to each camera and it will follow that node\u0026rsquo;s position. We\u0026rsquo;ll do that in the Main script:\nfunc _ready():\rviewport2.world_2d = viewport1.world_2d\rcamera1.target = world.get_node(\u0026#34;Player_1\u0026#34;)\rcamera2.target = world.get_node(\u0026#34;Player_2\u0026#34;) When we run the scene now, each player is centered in its viewport and our splitscreen setup works!\nI find it looks best if you disable the Drag Margin properties of the cameras.\n\rCamera limits Next, let\u0026rsquo;s add some limits to the player cameras so that they don\u0026rsquo;t scroll outside the bounds of the map. Add this function to the main script and call it in _ready():\nfunc set_camera_limits():\rvar map_limits = world.get_used_rect()\rvar map_cellsize = world.cell_size\rfor cam in [camera1, camera2]:\rcam.limit_left = map_limits.position.x * map_cellsize.x\rcam.limit_right = map_limits.end.x * map_cellsize.x\rcam.limit_top = map_limits.position.y * map_cellsize.y\rcam.limit_bottom = map_limits.end.y * map_cellsize.y Minimap Let\u0026rsquo;s add one more fun feature: a minimap showing a zoomed-out view of the entire map so the players can orient themselves.\nWe\u0026rsquo;ll need another ViewportContainer, this one a child of Main. This time, we don\u0026rsquo;t want to use Stretch. Add a Viewport and set its Size to (340, 200) then add a Camera2D. We\u0026rsquo;ll set the Camera2D\u0026rsquo;s Position to (512, 300) to center it on the screen. We\u0026rsquo;ll zoom out by setting Zoom to (9, 9). Don\u0026rsquo;t forget to click Current on this camera as well.\nIn the _ready(), set the minimap to use the same world as the other two viewports:\n$Minimap/Viewport.world_2d = viewport1.world_2d Use the \u0026ldquo;Layout\u0026rdquo; menu to align the Minimap container at \u0026ldquo;Center Bottom\u0026rdquo;. Let\u0026rsquo;s see what it looks like:\nWe need to get rid of that grey area around the edges. We could find the precise zoom level that matches our desired minimap size, but instead, we\u0026rsquo;ll check the Transparent Bg on the Viewport. Now our non-map areas aren\u0026rsquo;t visible and the minimap appears floating directly on top of the main viewports.\nConclusion Viewports can be very powerful, but also confusing. One way of managing them is to try to keep them separate from the game logic and only use them as displays.\n"},{"uri":"http://kidscancode.org/godot_recipes/animation/spritesheet_animation/","title":"Spritesheet animation","tags":[],"description":"","content":"Problem You want to use a spritesheet containing 2D animations.\nSolution Spritesheets are a common way for 2D animations to be distributed. In a spritesheet, all of the animation frames are packed into a single image.\nFor this demo, we\u0026rsquo;ll be using the excellent \u0026ldquo;Adventurer\u0026rdquo; sprite by Elthen. You can get this and lots of other great art athttps://elthen.itch.io/.\n![alt](/godot_recipes/img/Adventurer Sprite Sheet v1.1.png)\nMake sure the images in your spritesheet are laid out in a constant-sized grid. This will enable Godot to automatically slice them. If they\u0026rsquo;re packed irregularly, you will not be able to use the following technique.\n\rNode setup This animation technique uses a Sprite node to display the texture, and then we animate the changing frames with AnimationPlayer. This can work with any 2D node, but for this demo, we\u0026rsquo;ll use a KinematicBody2D.\nAdd the following nodes to your scene:\n KinematicBody2D (\u0026ldquo;Player\u0026rdquo;)  Sprite CollisionShape2D AnimationPlayer    Drag the spritesheet texture into the Texture property of the Sprite. You\u0026rsquo;ll see the entire spritesheet displayed in the viewport. To slice it up into individual frames, expand the \u0026ldquo;Animation\u0026rdquo; section in the Inspector and set the Hframes to 13 and Vframes to 8. Hframes and Vframes are the number of horizontal and vertical frames in your spritesheet.\nTry changing the Frame property to see the image change. This is the property we’ll be animating.\nAdding animations Select the AnimationPlayer and click the “Animation” button followed by “New\u0026rdquo; . Name the new animation “idle”. Set the animation length to 2 and click the “Loop” button so that our animation will repeat (see below).\nWith the scrubber at time 0, select the Sprite node. Set its Animation/Frame to 0, then click the key icon next to the value.\nIf you try playing the animation, you\u0026rsquo;ll see it doesn\u0026rsquo;t appear to do anything. That\u0026rsquo;s because the last frame (12) looks the same as the first (0), but we\u0026rsquo;re not seeing any of the frames in-between (1-11). To fix this, change the \u0026ldquo;Update Mode\u0026rdquo; of the track from its default value of \u0026ldquo;Discrete\u0026rdquo; to \u0026ldquo;Continuous\u0026rdquo;. You can find this button at the end of the track on the right side.\nNote that this will only work for spritesheets where the frames are already in order. If they are not, you\u0026rsquo;ll have to keyframe each Frame seperately along the timeline.\nFeel free to add the other animations yourself. For example, the \u0026ldquo;jump\u0026rdquo; animation is on frames 65 through 70.\nRelated recipes  Top-down character Platform character Controlling animation states  "},{"uri":"http://kidscancode.org/godot_recipes/2d/tilemap_collision/","title":"TileMap: detecting tiles","tags":[],"description":"","content":"Problem You have a KinematicBody2D character colliding with a TileMap, and you want to know which tile it collided with.\nSolution When a KinematicBody2D collides, the collision data is returned in a KinematicCollision2D object. The TileMap acts as a single collider, so if you reference the collider property, it will be the TileMap node.\nYou then need to find out which tile in the TileMap is at the collision location.\nAssume you\u0026rsquo;ve obtained a KinematicCollision2D object stored in the variable collision:\n# Confirm the colliding body is a TileMap\r if collision.collider is TileMap:\r# Find the character\u0026#39;s position in tile coordinates\r var tile_pos = collision.collider.world_to_map(position)\r# Find the colliding tile position\r tile_pos -= collision.normal\r# Get the tile id\r var tile_id = collision.collider.get_cellv(tile_pos)\rOnce you have the tile_id, you can get the tile properties from the TileSet resource, found in the TileMap's tile_set property. For example, to get the name of the tile:\nvar tile_name = collision.collider.tile_set.tile_get_name(tile_id)\rYou can also change the tile by setting it to a new id:\ncollision.collider.set_cellv(tile_pos, new_id)\rRelated recipes  TileMap: using autotile TileMap: animated tiles  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/2d/topdown_movement/","title":"Top-down movement","tags":[],"description":"","content":"Problem You\u0026rsquo;re making a 2D top-down game, and you want to control a character\u0026rsquo;s movement.\nSolution For this solution, we\u0026rsquo;ll assume you have the following input actions defined:\n   Action Name Key(s)     \u0026quot;up\u0026quot; W,↑   \u0026quot;down\u0026quot; S,↓   \u0026quot;right\u0026quot; D,→   \u0026quot;left\u0026quot; A,←   \u0026quot;click\u0026quot; Mouse button 1    We will also assume you\u0026rsquo;re using a KinematicBody2D character.\nWe can solve this problem in many ways, depending on what type of behavior you\u0026rsquo;re looking for.\nOption 1: 8-way movement In this scenario, the player uses the four directional keys to move (including diagonals).\nextends KinematicBody2D\rvar speed = 200 # speed in pixels/sec\r var velocity = Vector2.ZERO\rfunc get_input():\rvelocity = Vector2.ZERO\rif Input.is_action_pressed(\u0026#39;right\u0026#39;):\rvelocity.x += 1\rif Input.is_action_pressed(\u0026#39;left\u0026#39;):\rvelocity.x -= 1\rif Input.is_action_pressed(\u0026#39;down\u0026#39;):\rvelocity.y += 1\rif Input.is_action_pressed(\u0026#39;up\u0026#39;):\rvelocity.y -= 1\r# Make sure diagonal movement isn\u0026#39;t faster\r velocity = velocity.normalized() * speed\rfunc _physics_process(delta):\rget_input()\rvelocity = move_and_slide(velocity)\rOption 2: Rotate and move In this scenario, the left/right actions rotate the character and up/down move the character forward and back in whatever direction it\u0026rsquo;s facing. This is sometimes referred to as \u0026ldquo;Asteroids-style\u0026rdquo; movement.\nextends KinematicBody2D\rvar speed = 200\rvar rotation_speed = 1.5\rvar velocity = Vector2.ZERO\rvar rotation_dir = 0\rfunc get_input():\rrotation_dir = 0\rvelocity = Vector2.ZERO\rif Input.is_action_pressed(\u0026#39;right\u0026#39;):\rrotation_dir += 1\rif Input.is_action_pressed(\u0026#39;left\u0026#39;):\rrotation_dir -= 1\rif Input.is_action_pressed(\u0026#39;down\u0026#39;):\rvelocity -= transform.x * speed\rif Input.is_action_pressed(\u0026#39;up\u0026#39;):\rvelocity += transform.x * speed\rfunc _physics_process(delta):\rget_input()\rrotation += rotation_dir * rotation_speed * delta\rvelocity = move_and_slide(velocity)\rOption 3: Aim with mouse Similar to option 2, but this time the character rotation is controlled with the mouse (ie the character always points towards the mouse). Forward/back movement is done with the keys as before.\nextends KinematicBody2D\rvar speed = 200\rvar velocity = Vector2.ZERO\rfunc get_input():\rvelocity = Vector2.ZERO\rif Input.is_action_pressed(\u0026#34;forward\u0026#34;):\rvelocity += transform.x * speed\rif Input.is_action_pressed(\u0026#34;back\u0026#34;):\rvelocity -= transform.x * speed\rfunc _physics_process(delta):\rlook_at(get_global_mouse_position())\rget_input()\rvelocity = move_and_slide(velocity)\rOption 4: Click and move In this option, the character moves to the clicked location.\nextends KinematicBody2D\rvar speed = 200\rvar target = null\rvar velocity = Vector2.ZERO\rfunc _input(event):\rif event.is_action_pressed(\u0026#39;click\u0026#39;):\rtarget = event.position\rfunc _physics_process(delta):\rif target:\rlook_at(target)\rvelocity = transform.x * speed\r# stop moving if we get close to the target\r if position.distance_to(target) \u0026gt; 5:\rvelocity = move_and_slide(velocity)\rOption 5: Adding friction All of the movement methods above move and change direction instantly - there\u0026rsquo;s no acceleration or friction. What if we want to ramp our velocity up from or down to zero? Let\u0026rsquo;s add some code to interpolate or \u0026ldquo;lerp\u0026rdquo; the velocity after getting the input.\nWe\u0026rsquo;ll use the code from Option 1: 8-way movement movement.\nextends KinematicBody2D\rexport var speed = 200\rexport var friction = 0.01\rexport var acceleration = 0.1\rvar velocity = Vector2()\rfunc get_input():\rvar input = Vector2()\rif Input.is_action_pressed(\u0026#39;right\u0026#39;):\rinput.x += 1\rif Input.is_action_pressed(\u0026#39;left\u0026#39;):\rinput.x -= 1\rif Input.is_action_pressed(\u0026#39;down\u0026#39;):\rinput.y += 1\rif Input.is_action_pressed(\u0026#39;up\u0026#39;):\rinput.y -= 1\rreturn input\rfunc _physics_process(delta):\rvar direction = get_input()\rif direction.length() \u0026gt; 0:\rvelocity = lerp(velocity, direction.normalized() * speed, acceleration)\relse:\rvelocity = lerp(velocity, Vector2.ZERO, friction)\rvelocity = move_and_slide(velocity)\rNow our input isn\u0026rsquo;t applied directly to the velocity but rather used to \u0026ldquo;push\u0026rdquo; the velocity towards the input direction. If there\u0026rsquo;s no input, we ramp down towards zero.\n"},{"uri":"http://kidscancode.org/godot_recipes/basics/tree_ready_order/","title":"Understanding tree order","tags":[],"description":"","content":"Problem You need to understand in what order Godot handles nodes in the scene tree.\nSolution \u0026ldquo;Tree order\u0026rdquo; is mentioned often in the Godot docs and in tutorials. However, it is not always obvious to a beginner what is meant by this. Generally speaking, the order in which nodes are handled in the tree is in top-down fashion, starting at the root and going down each branch in turn.\nScene tree order is something that can cause a great deal of confusion for Godot beginners. In this example, we\u0026rsquo;ll illustrate in what order things happen.\nHere\u0026rsquo;s our sample node setup:\nOn each node, we have the following script attached:\nextends Node\rfunc _init():\r# Note: a Node doesn\u0026#39;t have a \u0026#34;name\u0026#34; yet here.\r print(\u0026#34;TestRoot init\u0026#34;)\rfunc _enter_tree():\rprint(name + \u0026#34; enter tree\u0026#34;)\rfunc _ready():\rprint(name + \u0026#34; ready\u0026#34;)\r# This ensures we only print *once* in process().\r var test = true\rfunc _process(delta):\rif test:\rprint(name + \u0026#34; process\u0026#34;)\rtest = false\rBefore we talk about the results, let\u0026rsquo;s review what each of these callback functions represents:\n  _init() is called when the object is first created. It now exists in the computer\u0026rsquo;s memory.\n  _enter_tree() is called when the node first enters the tree. This can be when instancing or when add_child() is used, for example.\n  _ready() is called when the node and its children have all been added to the tree and are ready.\n  _process() is called every frame (typically 60 times per second) on every node in the tree.\n  If we ran this on a single node all by itself, the order would be as you might expect:\nTestRoot init\rTestRoot enter tree\rTestRoot ready\rTestRoot process\rOnce we add children to the mix, it becomes a bit more complex, and probably needs some clarification:\nTestRoot init\rTestChild1 init\rTestChild3 init\rTestChild2 init\rTestRoot enter tree\rTestChild1 enter tree\rTestChild3 enter tree\rTestChild2 enter tree\rTestChild3 ready\rTestChild1 ready\rTestChild2 ready\rTestRoot ready\rTestRoot process\rTestChild1 process\rTestChild3 process\rTestChild2 process\rAs you can see, all of these nodes printed their messages in tree order, from top to bottom, following branches first - with the exception of the _ready() code.\nHere\u0026rsquo;s a quote from the Node reference:\n Called when the node is \u0026ldquo;ready\u0026rdquo;, i.e. when both the node and its children have entered the scene tree. If the node has children, their _ready callbacks get triggered first, and the parent node will receive the ready notification afterwards.\n This leads to an important rule-of-thumb to remember when setting up your node structure:\nParent nodes should manage their children, not vice-versa.\n\rThis means any code in the parent must be able to fully access any data in its children. For that reason, _ready() must be processed in reverse tree order.\nRemember this when trying to access other nodes in _ready(). If you need to go up the tree to a parent (or grandparent), you should probably run that code in the parent rather than the child.\nRelated recipes Understanding node paths\n"},{"uri":"http://kidscancode.org/godot_recipes/physics/godot3_kinematic2d/","title":"Using KinematicBody2D","tags":[],"description":"","content":"Godot offers a number of collision objects to provide both collision detection and response. Trying to decide which one to use for your project can be confusing. You can avoid problems and simplify development if you understand how each each works and what their pros and cons are. In this tutorial, we\u0026rsquo;ll look at the KinematicBody2D node and show some examples of how it can be used.\nIntroduction: Physics bodies In game development you often need to know when two objects in the game space intersect or come into contact. This is known as collision detection. When a collision is detected, you typically want something to happen. This is known as collision response.\nGodot offers three kinds of physics bodies, grouped under the PhysicsBody2D type:\n StaticBody2D  A static body is one that is not moved by the physics engine. It participates in collision detection, but does not move in response to the collision. This type of body is most often used for objects that are part of the environment or that do not need to have any dynamic behavior.\n RigidBody2D  This is the node that implements simulated 2D physics. You do not control a RigidBody2D directly, but instead you apply forces to it (gravity, impulses, etc.) and the physics engine calculates the resulting movement. See Godot 3.0: Rigid Bodies for more information.\n KinematicBody2D  A body that provides collision detection, but no physics. All movement must be implemented in code.\nCollision shapes A physics body can hold any number of Shape2D objects as children. These shapes are used to define the object\u0026rsquo;s collision bounds and to detect contact with other objects.\n Note: In order to detect collisions, at least one Shape2D must be assigned to the object.\n The most common way to assign a shape is by adding a CollisionShape2D or CollisionPolygon2D as a child of the object. These nodes allow you to draw the shape directly in the editor workspace.\n Note: Be careful to never scale your collision shapes in the editor. The Scale property in the Inspector should remain at (1, 1). When changing the size of the collision shape, you should always use the shape\u0026rsquo;s handles, not the Node2D scale handles. Changing the scale can result in unexpected collision behavior.\n !player_coll_shape.png\nCollision Layers and Masks One of the most powerful but frequently misunderstood collision features in Godot is the collision layer system. This system allows you to build up very complex interactions between a variety of objects. The key concepts are layers and masks. Each CollisionObject2D has 32 different physics layers it can interact with.\nLet\u0026rsquo;s look at each of the properties in turn:\n  collision_layer describes the layers that the object appears in. By default, all bodies are on layer 1.\n  collision_mask describes what layers the body will scan for collisions. If an object isn\u0026rsquo;t in one of the mask layers, the body will ignore it. By default, all bodies scan layer 1.\n  You can also assign names to layers. In \u0026ldquo;Project Settings\u0026rdquo;, look for the \u0026ldquo;Layer Names -\u0026gt; 2D Physics\u0026rdquo; section:\nA body\u0026rsquo;s layer properties can be configured via code, or directly in the Inspector:\nExample:\nYou have three nodes with the following configuration:\n    Layers Mask     Player 1 2, 3   Enemy 2 1   Coin 3 1    In this scenario, the Player node would detect collisions with both Enemy and Coin nodes (because they are in layers it scans). However, Enemy and Coin nodes would not detect each other, because they only scan layers they are not in.\nKinematic Bodies KinematicBody2D is for implementing bodies that are to be controlled via code. They detect collisions with other bodies when moving, but are not affected by engine physics properties like gravity or friction. While this means that you have to write some code to create their behavior, it also means you have more precise control over how they move and react.\n Note: A KinematicBody2D can be affected by gravity and other forces, but you must calculate the movement in code. The physics engine will not move a KinematicBody2D.\n Movement and collision When moving a KinematicBody2D, you should not set its position directly. Instead, you use the move_and_collide() or move_and_slide() methods. These methods move the body along a given vector and will instantly stop if a collision is detected with another body. After a KinematicBody2D has collided, any collision response must be coded manually.\n Note: Kinematic body movement should only be done in the _physics_process() callback.\n move_and_collide This method takes one parameter: a Vector2 indicating the body\u0026rsquo;s relative movement. Typically, this is your velocity vector multiplied by the frame timestep (delta). If the engine detects a collision anywhere along this vector, the body will immediately stop moving. If this happens, the method will return a KinematicCollision2D object.\nKinematicCollision2D When a KinematicBody2D detects a collision, Godot provides a KinematicCollision2D object. This object contains data about the collision and the colliding object. Using this data you can calculate your collision response.\nmove_and_slide The move_and_slide() method is intended to simplify the collision response in the common case where you want one body to slide along the other. This is especially useful in platformers or top-down games, for example.\n NOTE: move_and_slide() automatically calculates frame-based movement using delta. Do not multiply your velocity vector by delta before passing it to move_and_slide().\n In addition to the velocity vector, move_and_slide takes a number of other parameters allowing you to customize the slide behavior:\nfloor_normal - default value: Vector2( 0, 0 )\nThis parameter allows you to define what surfaces the engine should consider to be the floor. Setting this lets you use the is_on_floor(), is_on_wall(), and is_on_ceiling() methods to detect what type of surface the body is in contact with. The default value means that all surfaces are considered walls.\nslope_stop_min_velocity - default value: 5\nThis is the minimum velocity when standing on a slope. This prevents a body from sliding down a slope when standing still.\nmax_bounces - default value: 4\nThis is the maximum number of collisions before the body stops moving. Setting this too low may prevent movement entirely.\nfloor_max_angle - default value: 0.785398 (in radians, equivalent to 45 degrees)\nThis is the maximum angle before a surface is no longer considered a \u0026ldquo;floor\u0026rdquo;.\nWhich to use? A common question from new Godot users is: \u0026ldquo;How do you decide which movement function to use?\u0026rdquo; Often the response is to use move_and_slide() because it\u0026rsquo;s \u0026ldquo;simpler\u0026rdquo;, but this is not necessarily the case. One way to think of it is that move_and_slide() is a special case, and move_and_collide() is more general. For example, the following two code snippets result in the same collision response:\nvar collision = move_and_collide(velocity * delta)\rif collision:\rvelocity = velocity.slide(collision.normal) velocity = move_and_slide(velocity)\nAnything you do with move_and_slide() can also be done with move_and_collide(), it just might take a little more code. However, as we\u0026rsquo;ll see in the examples below, there are cases where move_and_slide() isn\u0026rsquo;t the response you want.\nExamples Download the Sample Project for the examples below.\nBasic movement If you\u0026rsquo;ve downloaded the sample project, this example is in the \u0026ldquo;BasicMovement.tscn\u0026rdquo; scene.\nFor this example, Add a KinematicBody2D with two children: a Sprite and a CollisionShape2D. As with many demos, we\u0026rsquo;ll use the Godot \u0026ldquo;icon.png\u0026rdquo; as the Sprite\u0026rsquo;s texture (drag it from the Filesystem dock to the \u0026ldquo;Texture\u0026rdquo; property of the Sprite). In the CollisionShape2D's \u0026ldquo;Shape\u0026rdquo; property, select \u0026ldquo;New RectangleShape2D\u0026rdquo; and size the rectangle to fit over the sprite image.\nAttach a script to the KinematicBody2D and add the following code:\nextends KinematicBody2D\rvar speed = 250\rvar velocity = Vector2()\rfunc get_input():\r# Detect up/down/left/right keystate and only move when pressed\r velocity = Vector2()\rif Input.is_action_pressed(\u0026#39;ui_right\u0026#39;):\rvelocity.x += 1\rif Input.is_action_pressed(\u0026#39;ui_left\u0026#39;):\rvelocity.x -= 1\rif Input.is_action_pressed(\u0026#39;ui_down\u0026#39;):\rvelocity.y += 1\rif Input.is_action_pressed(\u0026#39;ui_up\u0026#39;):\rvelocity.y -= 1\rvelocity = velocity.normalized() * speed\rfunc _physics_process(delta):\rget_input()\rmove_and_collide(velocity * delta) Run this scene and you\u0026rsquo;ll see that move_and_collide() works as expected, moving the body along the velocity vector. Now let\u0026rsquo;s see what happens when you add some obstacles. Add a StaticBody2D with a rectangular collision shape. For visibility, you can use a sprite, a Polygon2D, or just turn on \u0026ldquo;Visible Collision Shapes\u0026rdquo; from the \u0026ldquo;Debug\u0026rdquo; menu.\nRun the scene again and try moving into the obstacle. You\u0026rsquo;ll see that the KinematicBody2D can\u0026rsquo;t penetrate the obstacle. However, try moving into the obstacle at an angle and you\u0026rsquo;ll find that the obstacle acts like glue - it feels like the body gets stuck.\nThis happens because there is no collision response. move_and_collide() just stops the body\u0026rsquo;s movement when a collision occurs. We need to code whatever response we want from the collision.\nTry changing the function to move_and_slide(velocity) and running again. Note that we removed delta from the velocity calculation.\nmove_and_slide() provides a default collision response of sliding the body along the collision object. This is useful for a great many game types, and may be all you need to get the behavior you want.\nNext, we\u0026rsquo;ll look at a few other examples.\nBouncing/reflecting and collision detection What if you don\u0026rsquo;t want a sliding collision response? For this example (\u0026ldquo;BounceandCollide.tscn\u0026rdquo; in the sample project), we have a character shooting bullets and we want the bullets to bounce off the walls.\nFor this example, we have three scenes: the main scene containing the Player, a Bullet, and a Wall. The Bullet and Wall are separate scenes so that they can be instanced.\nThe Player is controlled by W/S for forward/back and aims using the mouse. Here is the code for the Player, using move_and_slide():\nextends KinematicBody2D\rexport (PackedScene) var Bullet\rexport (int) var speed\rvar velocity = Vector2()\rfunc get_input():\r# add these actions in Project Settings -\u0026gt; Input Map\r velocity = Vector2()\rif Input.is_action_pressed(\u0026#39;backward\u0026#39;):\rvelocity = Vector2(-speed/3, 0).rotated(rotation)\rif Input.is_action_pressed(\u0026#39;forward\u0026#39;):\rvelocity = Vector2(speed, 0).rotated(rotation)\rif Input.is_action_just_pressed(\u0026#39;mouse_click\u0026#39;):\rshoot()\rfunc shoot():\r# \u0026#34;Muzzle\u0026#34; is a Position2D placed at the barrel of the gun\r var b = Bullet.instance()\rb.start($Muzzle.global_position, rotation)\rget_parent().add_child(b)\rfunc _physics_process(delta):\rget_input()\rvar dir = get_global_mouse_position() - global_position\r# Don\u0026#39;t move if too close to the mouse pointer\r if dir.length() \u0026gt; 5:\rrotation = dir.angle()\rvelocity = move_and_slide(velocity) And the code for the Bullet:\nextends KinematicBody2D\rvar speed = 750\rvar velocity = Vector2()\rfunc start(pos, dir):\rrotation = dir\rposition = pos\rvelocity = Vector2(speed, 0).rotated(rotation)\rfunc _physics_process(delta):\rvar collision = move_and_collide(velocity * delta)\rif collision:\rvelocity = velocity.bounce(collision.normal)\rif collision.collider.has_method(\u0026#34;hit\u0026#34;):\rcollision.collider.hit()\rfunc _on_VisibilityNotifier2D_screen_exited():\rqueue_free() The action happens in _physics_process(). After using move_and_collide() if a collision occurs, a KinematicCollision2D object is returned (otherwise, the return is Nil).\nIf there is a returned collision, we use the normal of the collision to reflect the bullet\u0026rsquo;s velocity. bounce() is a Vector2 method.\nIf the colliding object (collider) has a hit method, we also call it. In the example project, we\u0026rsquo;ve added a flashing color effect to the Wall to demonstrate this.\nPlatforming with move_and_slide Let\u0026rsquo;s try one more example - one that often gets asked about - the 2D platformer. move_and_slide() is ideal for quickly getting a functional character controller up and running. If you\u0026rsquo;ve downloaded the sample project, you can find this in \u0026ldquo;Platformer.tscn\u0026rdquo;.\nFor this example, we\u0026rsquo;ll assume you have a level made of StaticBody2D objects. They can be any shape and size. In the sample project, we\u0026rsquo;re using a TileMap to lay out the level, but for the purposes of this demo, they could just as well be individual static bodies.\nWe\u0026rsquo;re also using the adorable \u0026ldquo;Sunny Land\u0026rdquo; art pack by Ansimuz for the art and character animations.\nHere\u0026rsquo;s the code for the player body:\nextends KinematicBody2D\rexport (int) var run_speed\rexport (int) var jump_speed\rexport (int) var gravity\renum {IDLE, RUN, JUMP}\rvar velocity = Vector2()\rvar state\rvar anim\rvar new_anim\rfunc _ready():\rchange_state(IDLE)\rfunc change_state(new_state):\rstate = new_state\rmatch state:\rIDLE:\rnew_anim = \u0026#39;idle\u0026#39;\rRUN:\rnew_anim = \u0026#39;run\u0026#39;\rJUMP:\rnew_anim = \u0026#39;jump_up\u0026#39;\rfunc get_input():\rvelocity.x = 0\rvar right = Input.is_action_pressed(\u0026#39;ui_right\u0026#39;)\rvar left = Input.is_action_pressed(\u0026#39;ui_left\u0026#39;)\rvar jump = Input.is_action_just_pressed(\u0026#39;ui_select\u0026#39;)\rif jump and is_on_floor():\rchange_state(JUMP)\rvelocity.y = jump_speed\rif right:\rchange_state(RUN)\rvelocity.x += run_speed\rif left:\rchange_state(RUN)\rvelocity.x -= run_speed\r$Sprite.flip_h = velocity.x \u0026lt; 0\rif !right and !left and state == RUN:\rchange_state(IDLE)\rfunc _process(delta):\rget_input()\rif new_anim != anim:\ranim = new_anim\r$AnimationPlayer.play(anim)\rfunc _physics_process(delta):\rvelocity.y += gravity * delta\rif state == JUMP:\rif is_on_floor():\rchange_state(IDLE)\rvelocity = move_and_slide(velocity, Vector2(0, -1))\rif position.y \u0026gt; 600:\rget_tree().reload_current_scene() We\u0026rsquo;re using a very rudimentary state machine to handle the transitions between the character\u0026rsquo;s idle, running, and jumping states.\nWhen using move_and_slide() the function returns a vector representing the movement that remained after the slide collision occurred. Setting that value back to the character\u0026rsquo;s velocity allows us to smoothly move up and down slopes. Try removing velocity = and see what happens if you don\u0026rsquo;t do this.\nAlso note that we\u0026rsquo;ve added Vector2(0, -1) as the floor normal. This is a vector pointing straight upward. This means that if the character collides with an object that has this normal, it will be considered a floor.\nUsing the floor normal allows us to make jumping work, using is_on_floor(). This function will only return true after a move_and_slide() collision where the colliding body\u0026rsquo;s normal is within 45 degrees of the given floor vector (this can be adjusted by setting floor_max_angle).\nThis also allows you to implement other features like wall jumps using is_on_wall(), for example.\nConclusion This introduction only scratches the surface of what\u0026rsquo;s possible with KinematicBody2D. As with all Godot nodes, the API documentation is your friend, so reference it frequently until you\u0026rsquo;re comfortable with the class methods.\nKinematic bodies are so useful, that I\u0026rsquo;ll probably do a followup \u0026ldquo;Know Your Nodes\u0026rdquo; exploring more uses. Please comment below if you have ideas or suggestions for other examples you\u0026rsquo;d like to see.\nDownload the sample project "},{"uri":"http://kidscancode.org/godot_recipes/physics/godot3_kyn_rigidbody1/","title":"Using Rigid Bodies","tags":[],"description":"","content":"\rThis tutorial was written prior to Godot Recipes. Its format will eventually be updated to match the rest of the docs on this site.\n\rIn this tutorial, I\u0026rsquo;ll explain when (and when not) to use rigid bodies, how they work, and demonstrate a few handy tricks to bend them to your will. The examples will use RigidBody2D, but the lessons apply equally to 3D.\nIntroduction  RigidBody2D is the physics body in Godot that provides simulated physics. This means that you don\u0026rsquo;t control a RigidBody2D directly. Instead you apply forces to it (gravity, impulses, etc.) and Godot\u0026rsquo;s built-in physics engine calculates the resulting movement, including collisions, bouncing, rotating, etc.\nYou can modify a RigidBody2D\u0026rsquo;s behavior via properties such as \u0026ldquo;Mass\u0026rdquo;, \u0026ldquo;Friction\u0026rdquo;, or \u0026ldquo;Bounce\u0026rdquo;, which can be set in the Inspector:\nThe body\u0026rsquo;s behavior is also affected by the world, via the Project Settings -\u0026gt; Physics properties, or by entering an  Area2D that is overriding the global physics properties.\nUsing RigidBody2D One of the benefits of using a rigid body is that a lot of behavior can be gotten \u0026ldquo;for free\u0026rdquo; without writing any code. For example, let\u0026rsquo;s look at making a rudimentary \u0026ldquo;Angry Birds\u0026rdquo;-style game with falling blocks. You only need to create RigidBody2Ds for the blocks and projectile, and set their properties. Stacking, falling, and bouncing will automatically be handled by the physics engine.\nStacking blocks Start by making a RigidBody2D for the block and adding Sprite and CollisionShape2D children:\nAdd a texture to the Sprite and a rectangular collision shape. IMPORTANT: Do not change the Scale of the collision shape! In general this is a bad idea, and will result in unexpected collision behavior. Always use the shape\u0026rsquo;s inner size handles and not the outer Node2D-derived scale handles.\n NOTE: For the textures in this example, I\u0026rsquo;m using the Physics Asset pack from Kenney.nl. It contains a wide variety of blocks in different shapes and materials.\n Press \u0026ldquo;Play\u0026rdquo; and you\u0026rsquo;ll see the block fall slowly downward. This is due to the default global gravity. You can find this setting in \u0026ldquo;Project Settings\u0026rdquo; under Physics -\u0026gt; 2d. You can also try changing the Block\u0026rsquo;s Gravity Scale property in the Inspector. I\u0026rsquo;m using a value of 3.\nNow create a Main scene (I usually use a Node) for the root). Add a few StaticBody2D nodes with rectangular collision shapes to serve as your \u0026ldquo;ground\u0026rdquo; and walls.\nInstance a Block, and then duplicate it (Ctrl-D on Windows and Cmd-D on MacOS) so you can make a nice stack. Something like this:\nProjectile Create another scene with the same node setup as your Block, but name this one \u0026ldquo;Ball\u0026rdquo;. Use one of the round textures and a circular collision shape. Instance this in your Main scene and place it somewhere to the side of the stack of blocks.\nTo cause a rigid body to move, it must have some velocity. You can give the body an initial velocity using the Linear -\u0026gt; Velocity property. Try setting this to (500, 0).\nYou can also tinker with the ball\u0026rsquo;s Friction and Bounce properties. Both of these properties can range from zero to one. I like a bounce of around 0.5.\n IMPORTANT: NEVER scale a physics body! If you try, a warning will appear, and when the scene runs, the physics engine will automatically set the scale back to (1, 1).\n Forces Reset the linear velocity to (0, 0). Now what if you want to be able to toss the ball? You should never set a rigid body\u0026rsquo;s velocity or position manually - remember, these are simulating \u0026ldquo;real-world\u0026rdquo; style physics. In the real world, objects can\u0026rsquo;t instantly jump from place to place or from a standstill to a high speed. If you try and do so, the physics engine will resist it, and unexpected movement can occur. Instead, we must apply forces which create an acceleration in a certain direction (also known as Newton\u0026rsquo;s Second Law). Godot physics objects work in the same way.\nTo add force to a rigid body, you have two functions to choose from:\n add_force()  Adds a continuous force to the body. Imagine a rocket\u0026rsquo;s thrust, steadily pushing it faster and faster. Note that this adds to any already existing forces. The force continues to be applied until removed.\n apply_impulse()  Adds an instantaneous \u0026ldquo;kick\u0026rdquo; to the body. Imagine hitting a baseball with a bat.\nWe\u0026rsquo;ll use apply_impulse() to kick the ball when we click, drag, and release the mouse button.\nOpen \u0026ldquo;Project Settings\u0026rdquo; and in the \u0026ldquo;Input Map\u0026rdquo; tab, add a new action called \u0026ldquo;click\u0026rdquo;. Connect it to the left mouse button.\nNext, add a script to the Ball, and add the following code:\nextends RigidBody2D\rvar dragging\rvar drag_start = Vector2()\rfunc _input(event):\rif event.is_action_pressed(\u0026#34;click\u0026#34;) and not dragging:\rdragging = true\rdrag_start = get_global_mouse_position()\rif event.is_action_released(\u0026#34;click\u0026#34;) and dragging:\rdragging = false\rvar drag_end = get_global_mouse_position()\rvar dir = drag_start - drag_end\rapply_impulse(Vector2(), dir * 5) This script toggles dragging on when the mouse button is pressed and records the location of the click. When the button is released, we find the vector from the click point to the release point and use that to apply the impulse (multiplying by 5 to scale it up). apply_impulse() also takes an offset as its first parameter. This lets you \u0026ldquo;hit\u0026rdquo; the body off center, if you wish. For instance, try setting it to Vector2(25, 0) and you\u0026rsquo;ll add some spin to the ball when it\u0026rsquo;s launched.\nControlling Rigid Bodies There are cases where you need more direct control of a rigid body. For example, imagine you\u0026rsquo;re trying to make a version of the classic game \u0026ldquo;Asteroids\u0026rdquo;. The player\u0026rsquo;s spaceship needs to rotate using the left/right arrow keys, and to move forward when the up arrow is pressed.\nHere\u0026rsquo;s the image I\u0026rsquo;m using for my ship:\nI recommend you also go to OpenGameArt and search for a nice space background (but this is totally optional).\nCreate a new scene for the ship as we did above with the following node structure:\n RigidBody2D  Sprite CollisionShape2D     Note: In Godot 3.0, 0 degrees points to the right (along the x axis). This means you need to add a Rotation of 90 to the Sprite so it will match the body\u0026rsquo;s direction.\n By default, the physics settings provide some damping, which reduces a body\u0026rsquo;s velocity and spin. In space, there\u0026rsquo;s no friction, so there shouldn\u0026rsquo;t be any damping at all. However, for the \u0026ldquo;Asteroids\u0026rdquo; feel, we want the ship to stop rotating when we let go of the keys, so set the ship\u0026rsquo;s Angular -\u0026gt; Damp to 5.\nextends RigidBody2D\rexport (int) var engine_thrust\rexport (int) var spin_thrust\rvar thrust = Vector2()\rvar rotation_dir = 0\rvar screensize\rfunc _ready():\rscreensize = get_viewport().get_visible_rect().size\rfunc get_input():\rif Input.is_action_pressed(\u0026#34;ui_up\u0026#34;):\rthrust = Vector2(engine_thrust, 0)\relse:\rthrust = Vector2()\rrotation_dir = 0\rif Input.is_action_pressed(\u0026#34;ui_right\u0026#34;):\rrotation_dir += 1\rif Input.is_action_pressed(\u0026#34;ui_left\u0026#34;):\rrotation_dir -= 1\rfunc _process(delta):\rget_input()\rfunc _physics_process(delta):\rset_applied_force(thrust.rotated(rotation))\rset_applied_torque(rotation_dir * spin_thrust) Let\u0026rsquo;s walk through what this script is doing. The two variables, engine_thrust and spin_thrust control how fast the ship can accelerate and turn. In the Inspector, set them to 500 and 25000 respectively (the units of torque make for large numbers). thrust will represent the ship\u0026rsquo;s engine state: (0, 0) when coasting, or a vector with the length of engine_thrust when powered on. rotation_dir will represent what direction the ship is turning. The screensize variable will capture the size of the screen, which we\u0026rsquo;ll be using later.\nNext, the input() function captures the keystates and sets the ship\u0026rsquo;s thrust on or off, and the rotation direction (rotation_dir) positive or negative. This function is called every frame in _process().\nFinally, physics-related functions should be called in _physics_process(). Here we use set_applied_force() to apply the thrust in whatever direction the ship is facing. Then we use set_applied_torque() to cause the ship to rotate.\nPlay the scene - you should be able to fly around freely.\nThe Position Problem Another feature of \u0026ldquo;Asteroids\u0026rdquo; is that the screen \u0026ldquo;wraps around\u0026rdquo;. If the player goes off one side, it teleports to the other side. But we already talked above about how you can\u0026rsquo;t change a rigid body\u0026rsquo;s position without breaking the physics engine. This presents a huge problem when working with rigid bodies.\nA common mistake is to try adding something like this to _physics_process():\nfunc _physics_process(delta):\rif position.x \u0026gt; screensize.x:\rposition.x = 0\rif position.x \u0026lt; 0:\rposition.x = screensize.x\rif position.y \u0026gt; screensize.y:\rposition.y = 0\rif position.y \u0026lt; 0:\rposition.y = screensize.y\rset_applied_force(thrust.rotated(rotation))\rset_applied_torque(rotation_dir * spin_thrust) This fails spectacularly, trapping the player on the edge of the screen (with occasional glitches). So why doesn\u0026rsquo;t this work? The docs say _physics_process() is for physics-related stuff, right?\nNot exactly. _physics_process() is synced to the physics timestep, but that doesn\u0026rsquo;t make it OK to use for just anything. Hope is not lost, however, the answer is in the docs.\nTo quote the RigidBody2D docs:\n You should not change a RigidBody2D’s position or linear_velocity every frame or even very often. If you need to directly affect the body’s state, use _integrate_forces, which allows you to directly access the physics state.\n And the description for _integrate_forces:\n Allows you to read and safely modify the simulation state for the object. Use this instead of _physics_process if you need to directly change the body’s position or other physics properties.\n So there\u0026rsquo;s our answer. Instead of using _physics_process() we need to use _integrate_forces(), which gives us access to the Physics2DDirectBodyState. I highly recommend you take a look at the linked document, there is a lot of really useful data provided in the physics state object. For our purposes, the key piece of information is the body\u0026rsquo;s Transform2D. (Explaining transforms is beyond the scope of this document - see Matrices and transforms for more information.)\nThe body\u0026rsquo;s position is contained in the transform\u0026rsquo;s origin. Change _physics_process() to _integrate_forces() and add the following code:\nfunc _integrate_forces(state):\rset_applied_force(thrust.rotated(rotation))\rset_applied_torque(rotation_dir * spin_thrust)\rvar xform = state.get_transform()\rif xform.origin.x \u0026gt; screensize.x:\rxform.origin.x = 0\rif xform.origin.x \u0026lt; 0:\rxform.origin.x = screensize.x\rif xform.origin.y \u0026gt; screensize.y:\rxform.origin.y = 0\rif xform.origin.y \u0026lt; 0:\rxform.origin.y = screensize.y\rstate.set_transform(xform) We grab the current transform, change it as necessary, and set it back as the new transform. The physics engine stays happy, and everything works as expected:\nConclusion When used properly, rigid bodies are a powerful tool in your Godot toolkit. Many users get in trouble, however, when they use them for the wrong purposes, or fail to understand exactly how they work.\n"},{"uri":"http://kidscancode.org/godot_recipes/g101/start/101_02/","title":"Godot&#39;s Editor: Finding your way around","tags":[],"description":"","content":"Project Manager The Project Manager is the first thing you\u0026rsquo;ll see when opening Godot.\nIn this window you can see a list of your Godot projects. You can choose an existing project and click \u0026ldquo;Run\u0026rdquo; to play the game or click \u0026ldquo;Edit\u0026rdquo; to work on it in the Godot editor. Since you probably don\u0026rsquo;t have any projects yet, let\u0026rsquo;s start by clicking the \u0026ldquo;New Project\u0026rdquo; button.\nHere you can give the project a name and create a folder to store it in.\nEvery Godot project is contained in its own folder. This has many benefits, including making it easy to move, share, and backup projects. It also means that all the project\u0026rsquo;s files (images, sounds, etc.) must be in the project folder.\n\rWhen you\u0026rsquo;re naming your project, try to choose a name that describes the project. \u0026ldquo;New Game Project #23\u0026rdquo; is not going to help you remember what that project was. You should also think about compatibility: some operating systems are case-sensitive, and some are not. This can lead to problems if you move or share your project from one computer to another. For this reason, many programmers develop a standardized naming scheme. For example: \u0026ldquo;No spaces, use \u0026lsquo;_\u0026rsquo; between words.\u0026rdquo;\nLet\u0026rsquo;s name this new project \u0026ldquo;getting_started\u0026rdquo;. Type this name, click \u0026ldquo;Create Folder\u0026rdquo;, and then click \u0026ldquo;Create \u0026amp; Edit\u0026rdquo;.\nYou\u0026rsquo;re now looking at the Godot editor window. This is where you\u0026rsquo;ll spend most of your time when working in Godot. The editor is divided into sections.\n Viewport: This is where you\u0026rsquo;ll see the parts of your game as you\u0026rsquo;re working on them. Main Menu: Here you can save and load files, edit project settings, and search for help. Workspaces: At the center-top, you can switch between working in the 2D, 3D, or Script workspaces. You start in 3D. Playtest Buttons: These buttons let you launch and control your game when testing. Docks: On both sides are a number of docks where you can view game items and set their properties.  Project Settings Now we\u0026rsquo;ve talked about the main parts of the Godot window and how they work, let\u0026rsquo;s spend a little time talking about our Project settings. Usually one of the first tasks when starting a new project is make sure it\u0026rsquo;s all set up correctly.\nSo let\u0026rsquo;s click on \u0026ldquo;Project\u0026rdquo; in the menu and select \u0026ldquo;Project Settings\u0026rdquo;.\nThis is the Project settings window. On the left is a list of categories. For most projects, the default settings will be fine, and you shouldn\u0026rsquo;t worry about changing them unless you have a very specific need. For now, we\u0026rsquo;re just going to look at two of the sections. First, \u0026ldquo;Application/Config\u0026rdquo;.\nIn here, you can set your game\u0026rsquo;s title, choose which scene is the \u0026ldquo;main scene\u0026rdquo; (more about that in a bit), and change the icon.\nSecond, let\u0026rsquo;s look at the \u0026ldquo;Display\u0026rdquo; section. This is where you set up your game\u0026rsquo;s display. width \u0026amp; height let you set the size of the game window. If, for example, you were making a mobile game, you\u0026rsquo;d want to set this to the resolution and proportions of your target device. There are also settings for scaling, stretching, fullscreen mode, and more. For now, we\u0026rsquo;ll leave the default size - later on we\u0026rsquo;ll talk about how to adjust these to get our game running on different devices.\nThere are also some tabs across the top. We\u0026rsquo;ve been looking at the \u0026ldquo;General\u0026rdquo; tab. I\u0026rsquo;ll also point out briefly, the \u0026ldquo;Input Map\u0026rdquo;. This is where you can define different input actions for keyboard control, gamepad, mouse, and so on. In your game, you\u0026rsquo;ll just worry about the action, not what individual key or button was pressed. This is a very powerful and flexible way of handling player input.\nWe also have localization options, if you plan to support multiple languages. Autoloading, which we\u0026rsquo;ll get to later, and plugins. The Godot community has created a variety of useful plugins that you can download and add to supply more features, different tools, and so on.\nWe\u0026rsquo;ll come back to the project settings window later. Let\u0026rsquo;s close it for now and we\u0026rsquo;re ready to move on to the next step: working with nodes.\n"},{"uri":"http://kidscancode.org/godot_recipes/basics/","title":"Basics","tags":[],"description":"","content":" Basics Basic Godot tips and tricks that apply to any project.\nIn this section: \rUnderstanding tree order\r\r\rNode communication (the right way)\r\r\rUnderstanding node paths\r\r\rUnderstanding \u0026#39;delta\u0026#39;\r\r\rSaving/loading data\r\r\rCircular movement\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/g101/3d/101_3d_02/","title":"Importing 3D Objects","tags":[],"description":"","content":"In the last part, we started a 3D project and looked at how to navigate and create 3D objects. In this part, you\u0026rsquo;ll learn how to import existing 3D objects that you\u0026rsquo;ve made or downloaded and how to use more of Godot\u0026rsquo;s 3D nodes.\nImporting 3D Objects If you\u0026rsquo;re familiar with 3D modeling software such as Blender, you can make your own models to use in your game. If not, there are many sources where you can download objects or even collections of objects for particular game types. One of our favorite makers of free game art is Kenney.nl.\nFor our tutorials, we\u0026rsquo;re going to use Kenney\u0026rsquo;s Platformer Kit, which you can download here: https://kenney.nl/assets/platformer-kit\nThis kit has a wide selection of objects that we can use to practice our Godot 3D skills. Here\u0026rsquo;s a sample showing what the kit looks like:\nOnce you\u0026rsquo;ve downloaded the kit, you\u0026rsquo;ll find that the objects inside are provided in a variety of different formats. Godot is able to use several of these, but since GLTF is available in this pack, it\u0026rsquo;s preferred over the others. Copy the \u0026ldquo;GLTF Format\u0026rdquo; folder into your Godot project\u0026rsquo;s folder and rename it to \u0026ldquo;platformer kit\u0026rdquo;.\nIf you\u0026rsquo;re interested in the differences between the formats, here\u0026rsquo;s a brief summary: OBJ files are the simplest, each representing a mesh which you can load into a MeshInstance node. This is likely the most common file type you\u0026rsquo;ll find online. DAE (Collada) files are more robust - Godot loads them as individual scenes, and they can include additional data along with the mesh such as animations. GLTF files are similar, but represent a more modern format with additional features.\n\rWhen you switch back to your Godot window, you\u0026rsquo;ll see progress bar while Godot scans the folder and imports all of the objects. Let\u0026rsquo;s click on one of them to see what\u0026rsquo;s going on. In the \u0026ldquo;FileSystem\u0026rdquo; tab, select the \u0026ldquo;crate.glb\u0026rdquo; and then click on the \u0026ldquo;Import\u0026rdquo; tab:\nHere you can see the cube object will be imported as a scene, with its root type set to Spatial and named \u0026ldquo;Scene Root\u0026rdquo;. Let\u0026rsquo;s change these: set the root type to RigidBody and the root name to \u0026ldquo;Crate\u0026rdquo;, then click the \u0026ldquo;Reimport\u0026rdquo; button.\nNow double-click on \u0026ldquo;crate.glb\u0026rdquo; and confirm that you want to make a new inherited scene. Here we have a classic game object: the crate. The root node of the scene is a RigidBody named \u0026ldquo;Crate\u0026rdquo; just as we wanted. However, there\u0026rsquo;s one small problem: it seems Kenney exported this model with an offset:\nIt would much better if the crate were centered relative to the parent node, so that when the RigidBody rotates about its center, so will the mesh. To fix this, select the MeshInstance node and set its Translation property to (-0.5, -0.25, 0.5).\nFinally, we need to add a collision shape to the body. Add a CollisionShape node as a child of the Crate. In its Shape property, choose \u0026ldquo;New BoxShape\u0026rdquo;. Use the three handles (they look like orange circles) to size the box to fit the mesh. You can also set the extents directly in the Inspector:\nNote that since the crate is 0.5 units wide, the Extents, which represent the distance from the center, becomes 0.25 units.\nNow we\u0026rsquo;re finished setting up the object. Save your Crate scene and let\u0026rsquo;s see how we can use it.\nBuilding a 3D Scene Create a new scene with a Spatial root. The first child we\u0026rsquo;ll add is one to give us a \u0026ldquo;ground\u0026rdquo; to stack some crates on. Add a StaticBody called \u0026ldquo;Ground\u0026rdquo;, and to that add a MeshInstance. In the Mesh property, select \u0026ldquo;New PlaneMesh\u0026rdquo; and then click it to open its properties. Set Size to (10, 10) so that we have a nice large surface. However, it would look better if it weren\u0026rsquo;t plain white.\nAlso in the mesh properties is a Material property. Materials are how you define the appearance of an object. Select \u0026ldquo;New SpatialMaterial\u0026rdquo; and then click it to open a large list of properties. To set the color of the mesh, we need the Albedo property. Choose a color, such as brown or dark green.\nIf we add a crate, it will fall right through the mesh, so we also need to give it a collision shape. With the crate, we added a CollisionShape node and assigned a shape. That\u0026rsquo;s one way to add collision, let\u0026rsquo;s look at another: select the mesh and in the menu at the of the viewport, choose \u0026ldquo;Create Convex Collision Sibling\u0026rdquo;. This will automatically create a CollisionShape node as a sibling of the mesh and assign it a shape that matches the mesh.\nNow instance a few crates in the scene and arrange them in a rough stack. Add a Camera and place it where it has a good view of the crates. Run the scene and watch your crates go tumbling!\nRotating Camera Let\u0026rsquo;s make the camera a little more dynamic by having it slowly orbit around the scene. Add a Spatial, which will be located at (0, 0, 0) and name it \u0026ldquo;CameraHub\u0026rdquo;. In the scene tree, drag the camera to make it a child of this new Spatial. Now, if the Spatial rotates around the y axis, it will drag the camera along with it.\nAdd a script to the root node and add the following:\nextends Spatial\rfunc _process(delta):\r$CameraHub.rotate_y(0.01) Run the scene to see what happens.\nLighting There\u0026rsquo;s another thing we can add to the scene to improve how it looks: light. There are multiple light nodes available in 3D, but we\u0026rsquo;re going to start with DirectionalLight. Add one to the scene and use the green (Y) arrow to pull it up into the air.\nA DirectionalLight simulates an infinite number of parallel rays of light, as if from a distant source like the sun. It will not cast shadows by default; to add shadows, click Enabled in the \u0026ldquo;Shadow\u0026rdquo; section. There is also a \u0026ldquo;DirectionalShadow\u0026rdquo; section, which contains a number of advanced properties for fine-tuning the shadow appearance. For full details see this document.\nNote that it really doesn\u0026rsquo;t matter where you place the node - only the direction of the light arrow matters.\nWrapping Up In this tutorial you learned how to import 3D objects from outside sources, and how to combine them into a simple scene. We also investigated lights and moving cameras.\nIn the next part, we\u0026rsquo;ll look at how to build a more complex scene and include a player-controlled character.\nYou can also find a video version of this lesson here:\n   --  "},{"uri":"http://kidscancode.org/godot_recipes/3d/kinematic_car/car_traction/","title":"3D Kinematic Car: Traction/Drifting","tags":[],"description":"","content":"Problem You\u0026rsquo;ve got a kinematic car, but you don\u0026rsquo;t like the \u0026ldquo;on rails\u0026rdquo; feeling, especially at high speeds. You\u0026rsquo;d like to have some \u0026ldquo;slip\u0026rdquo; so that you can have drifting and loss of traction.\nSolution When the car is drifting, the heading of the car (the direction it\u0026rsquo;s pointing) may not be the same as its velocity (the direction it\u0026rsquo;s moving). Turning the wheel will make the car turn, but the velocity will not instantly \u0026ldquo;catch up\u0026rdquo; - instead, we\u0026rsquo;ll use lerp() (linear interpolation) to gradually move the velocity to the desired direction.\nAdd the following new variables to car_base.gd:\nexport var slip_speed = 9.0\rexport var traction_slow = 0.75\rexport var traction_fast = 0.02\rvar drifting = false\rslip_speed is how fast the car needs to be going before losing traction. You\u0026rsquo;ll need to adjust this based on the car\u0026rsquo;s other parameters.\ntraction_slow and traction_fast represent the traction when below or above the slip_speed, ranging from 0 - 1. Smaller numbers mean the car will feel more \u0026ldquo;slippery\u0026rdquo;. Setting them to 1 will be \u0026ldquo;on rails\u0026rdquo; with no sliding at all.\ndrifting is a boolean variable to keep track of the drifting state.\nNext, add this code to the calculate_steering() function in car_base.gd, right after calculating the new_heading:\n# traction\r if not drifting and velocity.length() \u0026gt; slip_speed:\rdrifting = true\rif drifting and velocity.length() \u0026lt; slip_speed and steer_angle == 0:\rdrifting = false\rvar traction = traction_fast if drifting else traction_slow\rThis code sets the drifting state as appropriate, and then selects which traction value to use.\nThe last piece of the puzzle is to interpolate the velocity to the new heading. Change this line:\nvelocity = new_heading * velocity.length()\rto this:\nvelocity = lerp(velocity, new_heading * velocity.length(), traction)\rWrapping up At this point, we have a large number of parameters to adjust, giving us a very wide range of behavior for the car. Depending on the style of driving you\u0026rsquo;re going for, your number might be very different from the ones used here.\nIf you\u0026rsquo;re looking to add more, here are some of the topics we\u0026rsquo;ll address in follow-up recipes:\n Chase camera and camera control AI/NPC control (steering, obstacle avoidance, track following) Slopes and ramps  Related recipes  Kinematic Car: Base 2D: Car Steering recipe Input Actions 3D: KinematicBody Movement  Like video? "},{"uri":"http://kidscancode.org/godot_recipes/ui/containers/","title":"Containers","tags":[],"description":"","content":"Problem Your UI has problem(s): it\u0026rsquo;s become overcomplicated, it doesn\u0026rsquo;t resize well, and/or you can\u0026rsquo;t keep track of how everything fits together.\nSolution For many developers, building a UI is their least favorite part. It\u0026rsquo;s very easy for a complex UI to spiral out of control and become impossibly painful to fix or modify. Godot provides some great tools for building UI - and if you take the time to learn to use them, you\u0026rsquo;ll find that they take away a lot of that pain.\nThe solution is the Container. Containers provide a lot of power in building your UI\u0026rsquo;s layout.\nWhen a Control node is added to a Container, the container takes over all the control\u0026rsquo;s positioning information. You can no longer set the size, position, or other layout properties of the container\u0026rsquo;s children.\nThis is the key thing to remember about containers:\nA Container node automatically arranges its children. You cannot directly control the position of a child UI node.\n\rLet\u0026rsquo;s look at some of the most commonly used containers:\n  CenterContainer\nThis container places keeps its children centered.\n  MarginContainer\nThis container maintains a margin, preventing children from getting too close to the edges of the container. Margin values can be set in the \u0026ldquo;Custom Constants\u0026rdquo; section of the properties.\n  VBox/HboxContainer\nThese containers keep their contents aligned vertically or horizontally, respectively. In the \u0026ldquo;Custom Constants\u0026rdquo; section you can also set a Separation property to increase spacing between elements.\n  GridContainer\nThis container arranges its children in a grid pattern.\n  Size flags The way a container handles its children is mainly controlled by their \u0026ldquo;Size Flags\u0026rdquo; properties.\n  Fill\nWhen this option is checked, the control fills its assigned location in the container. This option is enabled by default.\n  Expand\nIf this option is checked, the control tries to use as much space as it can. Nodes without Expand selected are pushed by those that do.\n  Shrink Center\nWhen Fill is disabled and Expand is enabled, the control remains at the center of its area, rather than the beginning.\n  Shrink End\nSame as above, except the control stays to the end rather than the beginning.\n  Stretch Ratio\nThis ratio sets the amount that expanding controls take up relative to each other.\n  A good way to experiment with these settings is to set up a test scene like the following:\nTry adjusting the \u0026ldquo;Size Flags\u0026rdquo; properties of the different buttons and see how it affects their positioning in the HBoxContainer.\nNesting Containers For more complex UI setups, you\u0026rsquo;ll need to use containers holding other containers. Each item in a GridContainer, for example, may itself be a VBoxContainer, with all of it inside a MarginContainer.\nAll these containers inside containers can cause your scene tree to become quite large and hard to manage, especially if you have a lot of repeated elements, such as buttons and labels. It\u0026rsquo;s recommended that you break your UI into pieces and save each part as a separate scene that you can instance in the larger scene.\nDownload the project file here: screen_shake.zip\n\r--\rRelated recipes  Labels    --"},{"uri":"http://kidscancode.org/godot_recipes/2d/grid_movement/","title":"Grid-based movement","tags":[],"description":"","content":"Problem You need a 2D character that moves in a grid pattern.\nSolution Grid- or tile-based movement means the character\u0026rsquo;s position is restricted. They can only stand on a particular tile - never between two tiles.\nCharacter setup Here are the nodes we\u0026rsquo;ll use for the player:\n Area2D (\u0026ldquo;Player\u0026rdquo;): Using an Area2D means we can detect overlap (for picking up objects or colliding with enemies).  Sprite: You can use a sprite sheet here (we\u0026rsquo;ll set up the animation below). CollisionShape2D: Don\u0026rsquo;t make the hitbox too big. Since the player will be standing on the center of a tile, overlaps will be from the center. RayCast2D: For checking if movement is possible in the given direction. Tween: For interpolating movement from tile to tile. AnimationPlayer: For playing the character\u0026rsquo;s walk animation(s).    Add some input actions to the Input Map. We\u0026rsquo;ll use \u0026ldquo;up\u0026rdquo;, \u0026ldquo;down\u0026rdquo;, \u0026ldquo;left\u0026rdquo;, and \u0026ldquo;right\u0026rdquo; for this example.\nBasic movement We\u0026rsquo;ll start by setting up the tile-by-tile movement, without any animations or interpolation.\nextends Area2D\rvar tile_size = 64\rvar inputs = {\u0026#34;right\u0026#34;: Vector2.RIGHT,\r\u0026#34;left\u0026#34;: Vector2.LEFT,\r\u0026#34;up\u0026#34;: Vector2.UP,\r\u0026#34;down\u0026#34;: Vector2.DOWN}\rtile_size should be set to match the size of your tiles. In a larger project, this can be set by your main scene when instancing the player. We\u0026rsquo;re using 64x64 tiles in the example below.\nThe inputs dictionary maps the input action names to direction vectors. Make sure you have the names spelled the same here and in the Input Map (capitalization counts!).\nfunc _ready():\rposition = position.snapped(Vector2.ONE * tile_size)\rposition += Vector2.ONE * tile_size/2\rsnapped() allows us to \u0026ldquo;round\u0026rdquo; the position to the nearest tile increment, and adding a half-tile amount makes sure the player is centered on the tile.\nfunc _unhandled_input(event):\rfor dir in inputs.keys():\rif event.is_action_pressed(dir):\rmove(dir)\rfunc move(dir):\rposition += inputs[dir] * tile_size\rHere\u0026rsquo;s the actual movement code. When an input event occurs, we check the four directions to see which one matched, then pass it to move() to change the position.\nCollision Now we can add some obstacles. You can add StaticBody2Ds to manually add some obstacles (enable snapping to make sure they\u0026rsquo;re aligned with the grid) or use a TileMap (with collisions defined), as in the example below.\nWe\u0026rsquo;ll use the RayCast2D to determine whether a move to the next tile is allowed.\nonready var ray = $RayCast2D\rfunc move(dir):\rray.cast_to = inputs[dir] * tile_size\rray.force_raycast_update()\rif !ray.is_colliding():\rposition += inputs[dir] * tile_size\rWhen changing a raycast\u0026rsquo;s cast_to property, the physics engine won\u0026rsquo;t recalculate its collisions until the next physics frame. force_raycast_update() lets you update the ray\u0026rsquo;s state immediately. If it\u0026rsquo;s not colliding, then we allow the move.\nAnother common method is to use 4 separate raycasts, one for each direction.\n\rAnimating movement Lastly we can interpolate the position between tiles, giving a smooth feel to the movement. We\u0026rsquo;ll use the Tween node to animate the position property.\nonready var tween = $Tween\rexport var speed = 3\rAdd a reference to the Tween node and a variable to set our movement speed.\nfunc _unhandled_input(event):\rif tween.is_active():\rreturn\rfor dir in inputs.keys():\rif event.is_action_pressed(dir):\rmove(dir)\rWe\u0026rsquo;ll ignore any input while the tween is running.\nfunc move(dir):\rray.cast_to = dir * tile_size\rray.force_raycast_update()\rif !ray.is_colliding():\r#\tposition += dir * tile_size\r move_tween(dir)\rRemove the direct position change and call a function to activate the tween:\nfunc move_tween(dir):\rtween.interpolate_property(self, \u0026#34;position\u0026#34;,\rposition, position + dir * tile_size,\r1.0/speed, Tween.TRANS_SINE, Tween.EASE_IN_OUT)\rtween.start()\rExperiment with different tween transitions for different movement effects.\nYou can download a complete project of this example: grid_based_movement.zip\nRelated Recipes  Input Actions Interpolation  "},{"uri":"http://kidscancode.org/godot_recipes/input/input_actions/","title":"Input Actions","tags":[],"description":"","content":"Problem You want to understand Godot\u0026rsquo;s \u0026ldquo;input action\u0026rdquo; system.\nSolution Let\u0026rsquo;s say you\u0026rsquo;re making a top-down character and you write code using InputActionKey that uses the arrow keys for movement. You\u0026rsquo;ll quickly find that many players prefer to use \u0026ldquo;WASD\u0026rdquo; style controls. You can go back into your code and add the additional key checks, but this would result in duplicated/redundant code.\nInput actions can help to make your code more configurable. Rather than hard-coding specific keys, you\u0026rsquo;ll be able to modify and customize them without changing the code.\nCreating inputs You define input actions in the \u0026ldquo;Project Settings\u0026rdquo; under the \u0026ldquo;Input Map\u0026rdquo; tab. Here, you can create new actions and/or assign inputs to them.\nYou\u0026rsquo;ll see when you click on the tab there are already some default actions configured. They are all named \u0026ldquo;ui_*\u0026rdquo; to indicate that they are the default interface actions. \u0026ldquo;Tab\u0026rdquo; for next UI element, for example.\nGenerally speaking, you should create your own actions for your game, rather than use the existing ones.\nFor this example, let\u0026rsquo;s say you want to allow the player to control the game with the keyboard or the mouse. They need to be able to shoot by pressing either the left mouse button or the spacebar.\nCreate the new action \u0026ldquo;shoot\u0026rdquo; by typing the name in the \u0026ldquo;Action\u0026rdquo; field at the top and clicking \u0026ldquo;Add\u0026rdquo; (or pressing enter). Scroll to the bottom and you\u0026rsquo;ll see the new action has been added to the list.\nNow you can assign inputs to this action by clicking the \u0026ldquo;+\u0026rdquo; sign to the right. Inputs can be keys, mouse buttons, or joy/gamepad inputs. Choose \u0026ldquo;Key\u0026rdquo; and you can press the key on the keyboard you want to assign - let\u0026rsquo;s press the spacebar - and click \u0026ldquo;OK\u0026rdquo;.\nClick \u0026ldquo;+\u0026rdquo; to add another input, and this time choose \u0026ldquo;Mouse Button\u0026rdquo;. The default of \u0026ldquo;Device 0\u0026rdquo; and \u0026ldquo;Left Button\u0026rdquo; is fine, but you can select others if you like.\nUsing input actions You can check for the action either by polling the Input singleton every frame:\nfunc _process(delta):\rif Input.is_action_pressed(\u0026#34;shoot\u0026#34;):\r# This will execute every frame as long as the input is held.\r This is best for continuous actions - i.e. those you want to check constantly, such as movement.\nIf instead you want to detect the action at the moment it occurs, you can use the _input() or _unhandled_input() callbacks:\nfunc _unhandled_input(event):\rif event.is_action_pressed(\u0026#34;shoot\u0026#34;):\r# This will run once on the frame when the action is first pressed\r There are several functions you can use for checking input state:\n  is_action_pressed(): This function returns true if the action is currently in the pressed state.\n  is_action_released(): This function returns true if the action is not In the pressed state.\n  is_action_just_pressed() / is_action_just_released(): These methods work like the above, but only return true on the single frame after the event occurs. This is useful for non-recurring actions like shooting or jumping where the user needs to let go and then press the key again to repeat the action.\n  Related Recipes  Inputs: Introduction  "},{"uri":"http://kidscancode.org/godot_recipes/shaders/interacting/","title":"Interacting with Shaders","tags":[],"description":"","content":"Problem You want to interact with a Godot shader from GDScript.\nSolution To access the uniform\u0026rsquo;s value from GDScript, you can use set_shader_param() on the object\u0026rsquo;s material property. If the attached material is a ShaderMaterial, then you can access it like so:\nnode.material.set_shader_param(\u0026#34;param_name\u0026#34;, value)\rYou can also get the value with get_shader_param().\nFor an example of this, see the Blur Shader recipe.\nRelated Recipes  Shaders: Intro  "},{"uri":"http://kidscancode.org/godot_recipes/input/mouse_input/","title":"Mouse Input","tags":[],"description":"","content":"Problem You want to detect mouse input.\nSolution InputEventMouse is the base class for mouse events. It contains position and global_position properties. Inheriting from it are two classes: InputEventMouseButton and InputEventMouseMotion.\nYou can assign mouse button events in the InputMap, so you can use them with is_action_pressed().\n\rInputEventMouseButton @GlobalScope.ButtonList contains a list of BUTTON_* constants for each possible button, which will be reported in the event’s button_index property. Note that the scrollwheel also counts as a button - two buttons, to be precise, with both BUTTON_WHEEL_UP and BUTTON_WHEEL_DOWN being separate events.\nUnlike regular buttons, mouse wheel clicks only produce pressed events. There is no concept of a mouse wheel click being \u0026ldquo;released\u0026rdquo;.\n\rfunc _unhandled_input(event):\rif event is InputEventMouseButton:\rif event.button_index == BUTTON_LEFT:\rif event.pressed:\rprint(\u0026#34;Left button was clicked at \u0026#34;, event.position)\relse:\rprint(\u0026#34;Left button was released\u0026#34;)\rif event.button_index == BUTTON_WHEEL_DOWN:\rprint(\u0026#34;Wheel down\u0026#34;)\rInputEventMouseMotion These events occur whenever the mouse moves. You can find the distance moved (in screen coordinates) with the relative property.\nHere’s an example using mouse movement to rotate a 3D character:\n# Converts mouse movement (pixels) to rotation (radians).\r var mouse_sensitivity = 0.002\rfunc _unhandled_input(event):\rif event is InputEventMouseMotion:\rrotate_y(-event.relative.x * mouse_sensitivity)\r"},{"uri":"http://kidscancode.org/godot_recipes/basics/node_communication/","title":"Node communication (the right way)","tags":[],"description":"","content":"\rMany thanks to @TheDuriel on the Godot Discord for the original diagram that inspired this article. Save this and keep it handy.\n\rProblem Your project has started getting complex. You have multiple scenes, instances, and a lot of nodes. You\u0026rsquo;ve probably found yourself writing code like the following:\nget_node(\u0026#34;../../SomeNode/SomeOtherNode\u0026#34;)\rget_parent().get_parent().get_node(\u0026#34;SomeNode\u0026#34;)\rget_tree().get_root().get_node(\u0026#34;SomeNode/SomeOtherNode\u0026#34;)\rIf you do this, you\u0026rsquo;ll soon find that node references like this break easily. As soon as you change one thing about your scene tree, none of those references may be valid anymore.\nCommunication between nodes and scenes doesn\u0026rsquo;t have to be complicated. There is a better way.\nSolution As a general rule, nodes should manage their children, not the other way around. If you\u0026rsquo;re using get_parent() or get_node(\u0026quot;..\u0026quot;), then you\u0026rsquo;re probably headed for trouble. Node paths like this are brittle, meaning they can break easily. The three main problems with this arrangement:\n  You can\u0026rsquo;t test a scene independently. If you run the scene by itself or in a test scene that doesn\u0026rsquo;t have the exact same node setup, get_node() will cause a crash.\n  You can\u0026rsquo;t change things easily. If you decide to rearrange or redesign your tree, paths will no longer be valid.\n  Ready order is children-first, parent-last. This means that trying to access a parent\u0026rsquo;s property in a node\u0026rsquo;s _ready() can fail because the parent isn\u0026rsquo;t ready yet.\n  See Understanding tree order for an explanation of how nodes enter the tree and become ready.\n\rGenerally speaking, a node or scene should be able to be instanced anywhere in your game, and it should make no assumptions about what its parent is going to be.\nWe\u0026rsquo;ll go into detailed examples later in this tutorial, but for now, here\u0026rsquo;s the \u0026ldquo;golden rule\u0026rdquo; of node communication:\n Call down, signal up.\n If a node is calling a child (i.e. going \u0026ldquo;down\u0026rdquo; the tree), then get_node() is appropriate.\nIf a node needs to communicate \u0026ldquo;up\u0026rdquo; the tree, it should probably use a signal.\nIf you keep this rule in mind when designing your scene setup, you\u0026rsquo;ll be well on your way to a maintainable, well-organized project. And you\u0026rsquo;ll avoid using the cumbersome node paths that lead to problems.\nNow, let\u0026rsquo;s look at each of these strategies along with some examples.\n1. Using get_node() get_node() traverses the scene tree using a given path to find the named node.\nSee Understanding node paths for a more detailed explanation of node paths.\n\rget_node() example Let\u0026rsquo;s consider the following common configuration:\nThe script in the Player node needs to notify the AnimatedSprite which animation to play, based on the player\u0026rsquo;s movement. In this situation, get_node() works well:\nextends KinematicBody2D\rfunc _process(delta):\rif speed \u0026gt; 0:\rget_node(\u0026#34;AnimatedSprite\u0026#34;).play(\u0026#34;run\u0026#34;)\relse:\rget_node(\u0026#34;AnimatedSprite\u0026#34;).play(\u0026#34;idle\u0026#34;)\r\rIn GDScript you can use $ as a shorthand for get_node(), writing $AnimatedSprite instead.\n\r2. Using signals Signals should be used to call functions on nodes that are higher in the tree or at the same level (i.e. \u0026ldquo;siblings\u0026rdquo;).\nYou can connect a signal in the editor (most often for nodes that exist before the game starts) or in code (for nodes that you\u0026rsquo;re instancing at runtime). The syntax for connecting a signal is:\n source_node.connect(\u0026quot;\u0026lt;signal_name\u0026gt;\u0026quot;, target_node, \u0026quot;\u0026lt;target_function\u0026quot;\u0026gt;)\n Looking at this, you may be thinking \u0026ldquo;Wait, if I\u0026rsquo;m connecting to a sibling, won\u0026rsquo;t I need a node paths like ../Sibling?\u0026quot;. While you could do this, it breaks our rule above. The answer to this puzzle is to make sure that connections are made by the common parent.\nFollowing the rule of calling down the tree, a node that\u0026rsquo;s a common parent to the signaling and receiving nodes will by definition know where they are and be ready after both of them.\nSignal example A very common use case for signals is updating your UI. Whenever the player\u0026rsquo;s health variable changes, you want to update a Label or ProgressBar display. However, your UI nodes are completely separated from your player (as they should be). The player knows nothing about where those nodes are and how to find them.\nHere\u0026rsquo;s our example setup:\nNote that the UI is an instanced scene, we\u0026rsquo;re just showing the contained nodes. This is where you often see things like get_node(\u0026quot;../UI/VBoxContainer/HBoxContainer/Label).text = str(health), which is what we want to avoid.\nInstead the player emits a health_changed signal whenever it adds/loses health. We need to send that signal to the UI\u0026rsquo;s update_health() function, which handles setting the Label value. In the Player script we use this code whenever the player\u0026rsquo;s health is changed:\nemit_signal(\u0026#34;health_changed\u0026#34;, health)\rIn the UI script we have:\nonready var label = $VBoxContainer/HBoxContainer/Label\rfunc update_health(value):\rlabel.text = str(value)\rNow we just need to connect the signal to the function. The perfect place to do that is in World, which is the common parent, and knows where both nodes are:\nfunc _ready():\r$Player.connect(\u0026#34;health_changed\u0026#34;, $UI, \u0026#34;update_health\u0026#34;)\r3. Using groups Groups are another way to decouple, especially when you have a lot of similar objects that need to do the same thing. A node can be added to any number of groups and membership can be changed dynamically at any time with add_to_group() and remove_from_group().\nA common misconception about groups is that they are some kind of object or array that \u0026ldquo;contains\u0026rdquo; node references. Groups are a tagging system. A node is \u0026ldquo;in\u0026rdquo; a group if it has that tag assigned from it. The SceneTree keeps track of the tags and has functions like get_nodes_in_group() to help you find all nodes with a particular tag.\nGroup example Let\u0026rsquo;s consider a Galaga-style space shooter where you have a lots of enemies flying around. These enemies may have different types and behaviors. You\u0026rsquo;d like to add a \u0026ldquo;smart bomb\u0026rdquo; upgrade that, when activated, destroys all enemies on the screen. Using groups, you can implement this with a minimal amount of code.\nFirst, add all enemies to an \u0026ldquo;enemies\u0026rdquo; group. You can do this in the editor using the \u0026ldquo;Node\u0026rdquo; tab:\nYou can also add nodes to the group in your script:\nfunc _ready():\radd_to_group(\u0026#34;enemies\u0026#34;)\rLet\u0026rsquo;s assume every enemy has an explode() function that handles what happens when it dies (playing an animation, spawning dropped items, etc). Now that every enemy is in the group, we can implement our smart bomb function like this:\nfunc activate_smart_bomb():\rget_tree().call_group(\u0026#34;enemies\u0026#34;, \u0026#34;explode\u0026#34;)\r4. Using owner owner is a Node property that\u0026rsquo;s set automatically when you save a scene. Every node in that scene will have its owner set to the scene\u0026rsquo;s root node. This makes for a convenient way to connect child signals up to the main node.\nowner example In a complex UI, you often find yourself with a very deep, nested hierarchy of containers and controls. Nodes that the user interacts with, such as Button, emit signals, and you may want to connect those signals to the script on the UI\u0026rsquo;s root node.\nHere\u0026rsquo;s an example setup:\nThe script on the root CenterContainer has the following function, which we want to call whenever any button is pressed:\nextends CenterContainer\rfunc _on_button_pressed(button_name):\rprint(button_name, \u0026#34; was pressed\u0026#34;)\rThe buttons here are instances of a Button scene, representing an object which may contain dynamic code that sets the button\u0026rsquo;s text or other properties. Or perhaps you have buttons that are dynamically added/removed from the container depending on the game state. Regardless, all we need to connect the button\u0026rsquo;s signal is the following:\nextends Button\rfunc _ready():\rconnect(\u0026#34;pressed\u0026#34;, owner, \u0026#34;_on_button_pressed\u0026#34;, [name])\rNo matter where you place the buttons in the tree - if you add more containers, for example - the CenterContainer remains the owner.\nRelated recipes Understanding tree order Understanding node paths\n"},{"uri":"http://kidscancode.org/godot_recipes/ai/path_follow/","title":"Path following","tags":[],"description":"","content":"Problem You want a character to follow a pre-defined path, such as a guard patrolling or a car following the road.\nSolution There are many ways to approach this problem. In this solution, we\u0026rsquo;ll use Godot\u0026rsquo;s Path2D node (or Path for 3D) as a convenient way to draw paths in the editor.\nYou can add the Path2D as a child of your main scene, your map, or another location that makes sense. Don\u0026rsquo;t make it a child of the patrolling entity, though - or the path will move along with the player!\nDrawing the path After adding the Path2D node, you\u0026rsquo;ll see some new buttons appear above the viewport:\nSelect the \u0026ldquo;Add points\u0026rdquo; button and click to start adding. If you want a closed curve, the \u0026ldquo;Close curve\u0026rdquo; button will connect the last point to the first one.\nUse the \u0026ldquo;Control points\u0026rdquo; mode to adjust the \u0026ldquo;curviness\u0026rdquo; of the line.\nMoving along the path You can use PathFollow2D to automatically move along a path. However, if you\u0026rsquo;re using a kinematic body, this will cause problems with collisions, because you\u0026rsquo;re not using the body\u0026rsquo;s movement methods. For this reason, we\u0026rsquo;ll instead use the path\u0026rsquo;s points as \u0026ldquo;targets\u0026rdquo; for the body to move towards.\nextends KinematicBody2D\rvar move_speed = 100\rexport (NodePath) var patrol_path\rvar patrol_points\rvar patrol_index = 0\rfunc _ready():\rif patrol_path:\rpatrol_points = get_node(patrol_path).curve.get_baked_points()\rExporting the patrol_path lets us assign the path node directly in the Inspector. Then, if it\u0026rsquo;s assigned, we can get the points that make up the line in _ready().\nNext, we can use the currently selected point in the path as our target for movement. If we get close enough to it, we advance to the next point in the curve, using wrapi() to loop around to the first point when we reach the end.\nfunc _physics_process():\rif !patrol_path:\rreturn\rvar target = patrol_points[patrol_index]\rif position.distance_to(target) \u0026lt; 1:\rpatrol_index = wrapi(patrol_index + 1, 0, patrol_points.size())\rtarget = patrol_points[patrol_index]\rvelocity = (target - position).normalized() * move_speed\rvelocity = move_and_slide(velocity)\rRelated recipes "},{"uri":"http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_02/","title":"Spawning Circles","tags":[],"description":"","content":"In the previous part, we created the Jumper and Circle object that make up the bulk of the game. Now we need to add the progression: a continuous series of spawned circles as long as the player doesn\u0026rsquo;t miss.\nExpanding the Main scene Let\u0026rsquo;s add some more nodes to Main:\n  Position2D (\u0026ldquo;StartPosition\u0026rdquo;)\nThis will mark the starting position for the game. Place it near the bottom-center of the screen.\n  Camera2D\nThe camera will follow the player as it moves.\nLet\u0026rsquo;s also configure the camera. Set its Offset to (0, -200) - this will ensure we can see more of the world ahead of us. Also set Current to \u0026ldquo;On\u0026rdquo;.\n  Scripting the Main scene Remove the jumper and circle instances we manually created. We\u0026rsquo;ll add them in code moving forward.\nAdd the following to Jumper.gd:\nsignal captured\rWe\u0026rsquo;ll emit this signal when the jumper hits a circle:\nfunc _on_Jumper_area_entered(area):\rtarget = area\rvelocity = Vector2.ZERO\remit_signal(\u0026#34;captured\u0026#34;, area)\rAnd let\u0026rsquo;s change the init() function on the circle to also accept a position:\nfunc init(_position, _radius=radius):\rposition = _position\rNow let\u0026rsquo;s add a script to the Main scene:\nextends Node\rvar Circle = preload(\u0026#34;res://objects/Circle.tscn\u0026#34;)\rvar Jumper = preload(\u0026#34;res://objects/Jumper.tscn\u0026#34;)\rvar player\rWe need references to both objects so that we can instance them when needed.\nfunc _ready():\rrandomize()\rnew_game()\rThis is temporary - later we\u0026rsquo;ll have a UI with a start button to call the new game function.\nfunc new_game():\r$Camera2D.position = $StartPosition.position\rplayer = Jumper.instance()\rplayer.position = $StartPosition.position\radd_child(player)\rplayer.connect(\u0026#34;captured\u0026#34;, self, \u0026#34;_on_Jumper_captured\u0026#34;)\rspawn_circle($StartPosition.position)\rThe new_game() function initializes the game - spawning a player and a circle at the start position, and setting the camera.\nfunc spawn_circle(_position=null):\rvar c = Circle.instance()\rif !_position:\rvar x = rand_range(-150, 150)\rvar y = rand_range(-500, -400)\rc.position = player.target.position + Vector2(x, y)\radd_child(c)\rc.init(_position)\rHere\u0026rsquo;s our spawn_circle() function. If it\u0026rsquo;s passed a position, it\u0026rsquo;ll use it, otherwise we pick a random one some distance away from the current target. These are temporary numbers - once we\u0026rsquo;ve got more of the gameplay up and running, we\u0026rsquo;ll see how much they need to be adjusted.\nfunc _on_Jumper_captured(object):\r$Camera2D.position = object.position\rcall_deferred(\u0026#34;spawn_circle\u0026#34;)\rFinally, we need the function that processes the jumper\u0026rsquo;s captured signal. We\u0026rsquo;re going to move the camera to the new circle and spawn another. Note that because this function is called during physics processing, we\u0026rsquo;ll get an error if we try and add to the scene tree. Using call_deferred() tells the engine to execute that function as soon as it\u0026rsquo;s safe to do so.\nTry it out. You should be able to jump from circle to circle - how many did you get?\nOne jarring thing is that the camera \u0026ldquo;teleports\u0026rdquo; when it moves to the next circle. We can improve this by enabling Smoothing on the camera. The Smoothing/Speed controls how quickly the camera interpolates to the new position. Try something between 5 and 10.\nAdjustments It\u0026rsquo;s also jarring that when we hit a circle we don\u0026rsquo;t start rotating at the place we hit. Add this to the jumper\u0026rsquo;s _on_Jumper_area_entered() function:\ntarget.get_node(\u0026#34;Pivot\u0026#34;).rotation = (position - target.position).angle()\rLet\u0026rsquo;s also add this to the circle\u0026rsquo;s init():\nrotation_speed *= pow(-1, randi() % 2)\rThis randomly flips the rotation speed to positive or negative, so we won\u0026rsquo;t always orbit in the same direction.\nTrail Add these nodes to the jumper:\n Node (\u0026ldquo;Trail\u0026rdquo;)  Line2D (\u0026ldquo;Points\u0026rdquo;)    We\u0026rsquo;re going to use this to make a trail that streams out behind the player. Later we\u0026rsquo;ll make it more visually appealing, but for now, let\u0026rsquo;s stick with a simple gradient. In the Fill add a new Gradient, and go from transparent to a color of your choosing:\nNow in the jumper\u0026rsquo;s script, let\u0026rsquo;s add the following:\nonready var trail = $Trail/Points\rvar trail_length = 25\rAnd then in the _physics_process():\nif trail.points.size() \u0026gt; trail_length:\rtrail.remove_point(0)\rtrail.add_point(position)\rIMAGE/GIF\nCircle animations Finally, we\u0026rsquo;ll add some visuals to the circles. First, we\u0026rsquo;ll add an effect when the player jumps off and the circle disappears. Then, we\u0026rsquo;ll add a capture effect for when we hit a circle.\nAdd an AnimationPlayer node to the Circle.\n\u0026ldquo;Implode\u0026rdquo; animation Add a new animation called \u0026ldquo;implode\u0026rdquo;. Set the length to 0.4 and keyframe two properties of the root Area2D node: Scale at (1, 1) and Modulate at its default ((1, 1, 1, 1)). Then move the scrubber all the way to the end and key the values (0.1, 0.1) and (1, 1, 1, 0) (that\u0026rsquo;s the \u0026ldquo;alpha\u0026rdquo; value of the color).\nCapture animation The capture animation is a little more complex. Duplicate the Sprite and call it SpriteEffect. Set its Visible property off. We\u0026rsquo;re going to animate this second ring zooming in on the main circle.\nHere are the functions to add to the circle script:\nfunc capture():\r$AnimationPlayer.play(\u0026#34;capture\u0026#34;)\rfunc implode():\rif !$AnimationPlayer.is_playing():\r$AnimationPlayer.play(\u0026#34;implode\u0026#34;)\ryield($AnimationPlayer, \u0026#34;animation_finished\u0026#34;)\rqueue_free()\rAnd then in Jumper.gd, our jump function becomes:\nfunc jump():\rtarget.implode()\rtarget = null\rvelocity = transform.x * jump_speed\rAnd in Main, our capture method calls the capture:\nfunc _on_Jumper_captured(object):\r$Camera2D.position = object.position\robject.capture()\rcall_deferred(\u0026#34;spawn_circle\u0026#34;)\rGIF\n Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "},{"uri":"http://kidscancode.org/godot_recipes/basics/getting_nodes/","title":"Understanding node paths","tags":[],"description":"","content":"Problem It\u0026rsquo;s probably the most common error seen in the Godot help channels: an invalid node reference. Most often, it results in the following error:\n Invalid get index \u0026lsquo;position\u0026rsquo; (on base: \u0026lsquo;null instance\u0026rsquo;).\n Solution It\u0026rsquo;s that last part, the \u0026ldquo;null instance\u0026rdquo;, that\u0026rsquo;s the source of this problem, and the main source of confusion for Godot beginners.\nThe way to avoid this problem is to understand the concept of node paths.\nUnderstanding node paths The scene tree is made of nodes, which are connected together in parent-child relationships. A node path is the path it takes to get from one node to another by moving through this tree.\nAs an example, let\u0026rsquo;s take a simple \u0026ldquo;Player\u0026rdquo; scene:\nThe script for this scene is on the Player node. If the script needs to call play() on the AnimatedSprite node, it needs a reference to that node:\nget_node(\u0026#34;AnimatedSprite\u0026#34;).play()\rThe argument of the get_node() function is a string representing the path to the desired node. In this case, it\u0026rsquo;s a child of the node the script is on. If the path you give it is invalid, you\u0026rsquo;ll get the dreaded null instance error (as well as \u0026ldquo;Node not found\u0026rdquo;).\nGetting a node reference with get_node() is such a common situation that GDScript has a shortcut for it:\n$AnimatedSprite.play()\r\rget_node() returns a reference to the desired node.\n\rLet\u0026rsquo;s look at a more complex scene tree:\nIf the script on Main needs to access ScoreLabel it can do so with this path:\nget_node(\u0026#34;HUD/ScoreLabel\u0026#34;).text = \u0026#34;0\u0026#34;\r# or using the shortcut:\r $HUD/ScoreLabel.text = \u0026#34;0\u0026#34;\r\rWhen using $ notation, the Godot editor will autocomplete paths for you. You can also right-click on a node in the Scene tab and choose \u0026ldquo;Copy Node Path\u0026rdquo;.\n\rWhat if the node you want to access is higher in the tree? You can use get_parent() or \u0026quot;..\u0026quot; to reference the parent node. In the above example tree, to get the Player node from the ScoreLabel:\nget_node(\u0026#34;../../Player\u0026#34;)\rLet\u0026rsquo;s break that down. The path \u0026quot;../../Player\u0026quot; means \u0026ldquo;get the node that\u0026rsquo;s up one level (HUD), then one more level (Main), then its child Player\u0026rdquo;.\nDoes this seem familiar? Node paths work exactly like directory paths in your operating system. The / character indicates the parent-child relationship, and .. means \u0026ldquo;up one level\u0026rdquo;.\n\rRelative vs absolute paths The above examples all use relative paths - meaning they start at the current node and follow the path to the destination. Node paths can also be absolute, starting from the root node of the scene.\nFor example, the absolute path to the player node is:\nget_node(\u0026#34;/root/Main/Player\u0026#34;)\r/root, which can also be accessed with get_tree().root is not the root node of your scene. It\u0026rsquo;s the Viewport node that is always present by default in the SceneTree.\nA warning While the above examples work just fine, there are some things you should be aware of that may cause problems later. Imagine the following situation: the Player node has a health property, which you want to display in a HealthBar node somewhere in your UI. You might write something like this in the player\u0026rsquo;s script:\nfunc take_damage(amount):\rhealth -= amount\rget_node(\u0026#34;../Main/UI/HealthBar\u0026#34;).text = str(health)\rWhile this may work fine at first, it is brittle, meaning it can break easily. There are two main problems with this kind of arrangement:\n You can\u0026rsquo;t test the player scene independently. If you run the player scene by itself or in a test scene that doesn\u0026rsquo;t have a UI, the get_node() line will cause a crash. You can\u0026rsquo;t change your UI. If you decide to rearrange or redesign your UI, the path will no longer be valid and you have to change it.  For this reason, you should try to avoid using node paths that go up the scene tree. In the above situation, if the player instead emitted a signal when the health changed, the UI could listen for that signal to update itself. You could then rearrange and separate nodes without fear of breaking your game.\nWrapping up Once you understand how to use node paths, you\u0026rsquo;ll see how easy it is to reference any node you need. And put a stop to seeing those null instance error messages.\n  "},{"uri":"http://kidscancode.org/godot_recipes/g101/start/101_03/","title":"Nodes: Godot&#39;s building blocks","tags":[],"description":"","content":"Nodes are the basic building blocks for creating games in Godot. A node is an object that can represent some kind of specialized game function. A given type of node might display graphics, play an animation, or represent a 3D model of an object. The node also contains a collection of properties, allowing you to customize its behavior. Which nodes you add to your project will depend on what functionality you need. It\u0026rsquo;s a modular system designed to give you flexibility in building your game objects.\nWorking with Nodes Nodes are objects, in the programming sense. They encapsulate data and behavior, and they can inherit properties from other nodes. Rather than use one of the default suggestions, let\u0026rsquo;s click the \u0026ldquo;Add/Create a New Node\u0026rdquo; button in the scene dock.\nHere you\u0026rsquo;ll see the whole hierarchy of node types available in the engine. For example, the nodes with the bluish-purple icons all fall under the \u0026ldquo;Node2D\u0026rdquo; category, meaning they will all have the properties of a Node2D. More about that in a moment.\nThe list is long, and it would be frustrating to have to drill down every time to find the node you need. Instead, you can use the search function to find it using a small number of characters. We\u0026rsquo;re looking for the \u0026ldquo;Sprite\u0026rdquo; node, so I\u0026rsquo;ll just type \u0026ldquo;sp\u0026rdquo; and we\u0026rsquo;ll jump right to it. Click \u0026ldquo;Create\u0026rdquo; to add the node.\nNow we have this Sprite node in our \u0026ldquo;Scene\u0026rdquo; dock. Make sure it\u0026rsquo;s selected, and then look at the Inspector dock on the right side. Over here, you\u0026rsquo;ll see all the properties of whatever node you have selected. Notice that the properties are organized by where they come from. The Sprite node inherits from Node2D, which inherits from CanvasItem, which inherits from the plain old Node.\nOver in the viewport, the sprite doesn\u0026rsquo;t look like much. A sprite\u0026rsquo;s purpose is to display an image, or texture. As you can see in the Inspector, the texture property is currently empty. Fortunately, every new Godot project comes with an image we can use: the Godot icon. Drag the icon from the Filesystem dock and drop it in the texture property.\nIn the Inspector, click to expand the \u0026ldquo;Transform\u0026rdquo; section, and type (50, 50) in the Position property.\nYou can also click and drag the sprite around in the viewport, and you\u0026rsquo;ll see the Position values changing as you move.\nOne important property of nodes is that they can be arranged in a parent-child hierarchy. Make sure you have the Sprite selected and press the add button again. Add another Sprite and also drag the icon into its texture.\nThis new sprite is a child of the first. This means that it\u0026rsquo;s \u0026ldquo;attached\u0026rdquo; to its parent. If the parent sprite moves, so will the child. Click on the child sprite and set its Position to (50, 50). Now click and drag the parent sprite to move it around the screen.\nNotice that the Position of the parent is changing as you move it around. Now check the child: it\u0026rsquo;s still (50, 50). That\u0026rsquo;s because its \u0026ldquo;Transform\u0026rdquo; properties are relative to its parent.\nScenes Grouping nodes together like this is a powerful tool, enabling you to construct complex objects out of node \u0026ldquo;building blocks\u0026rdquo;. For example, a \u0026ldquo;Player\u0026rdquo; node in your game might have many child nodes attached to it: a Sprite for display, an AnimationPlayer to animate it, a Camera to follow it around, and so on.\nA group of nodes arranged in a \u0026ldquo;tree\u0026rdquo; structure like this is called a Scene. In the next part, we\u0026rsquo;ll look at how you can use scenes to organize your game\u0026rsquo;s objects into independent parts that all work together. You\u0026rsquo;ll see this in practice was you work through the examples in later lessons.\n"},{"uri":"http://kidscancode.org/godot_recipes/2d/","title":"2D","tags":[],"description":"","content":" 2D Tips, tricks, and tutorials on the 2D side of game development.\nIn this section: \rEntering/Exiting the screen\r\r\rPlatform character\r\r\rScreen wrap\r\r\rSplitscreen multiplayer\r\r\rTileMap: detecting tiles\r\r\rTop-down movement\r\r\rGrid-based movement\r\r\rCar steering\r\r\rTileMap: using autotile\r\r\rKinematicBody2D: align with surface\r\r\rMoving Platforms\r\r\rShooting projectiles\r\r\rTileMap: animated tiles\r\r\rScreen Shake\r\r\rMultitarget Camera\r\r\rBallistic bullet\r\r\rTouchscreen Camera\r\r\rDraw trajectory\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/math/transforms/","title":"Transforms","tags":[],"description":"","content":"Before reading this, make sure you have an understanding of vectors and how they\u0026rsquo;re used in game development. If you don\u0026rsquo;t, I recommend you read this introduction I wrote for the Godot documentation: Vector Math.\n2D Transforms In 2D space, we use the familiar X-Y coordinate plane. Remember that in Godot, as in most computer graphics applications, the Y axis points downward:\nTo begin, let\u0026rsquo;s consider this spaceship floating in space:\nThe ship is pointing in the same direction as the X axis. If we wanted it to move forward, we could add to its X coordinate and it would move to the left: position += Vector2(10, 0).\nBut what happens when the ship rotates?\nHow do we move the ship forward now? If you remember Trigonometry from school, you might be starting to think about angles, sin and cos and doing something like position += Vector2(10 * cos(angle), 10 * sin(angle)). While this would work, there\u0026rsquo;s a much more convenient way: the Transform.\nLet\u0026rsquo;s look at the rotated ship again, but this time, let\u0026rsquo;s also imagine that the ship has its own X and Y axes that it carries with it, independent of the global axes:\nThese \u0026ldquo;local\u0026rdquo; axes are a part of the transform called the basis.\nKnowing this, we can move the ship forward by moving it along its own X axis and we won\u0026rsquo;t have to worry about angles and trig functions. To do this in Godot, we can use the transform property, which is available to all Node2D derived nodes.\nposition += transform.x * 10\rThis code says \u0026ldquo;Add the transform\u0026rsquo;s x vector multiplied by 10.\u0026rdquo; Let\u0026rsquo;s break down what that means. The transform contains x and y properties that represent those local axes. They are unit vectors, which means their length is 1. Another term for unit vector is direction vector. They tell us the direction the ship\u0026rsquo;s x axis is pointing. We then multiply by 10 to scale it to a longer distance.\nThe transform property of a node is relative to its parent node. If you need to get the global value, it\u0026rsquo;s available in global_transform.\n\rIn addition to the basis, the transform also contains a component called the origin. The basis represents the body\u0026rsquo;s rotation, while the origin represents the translation, or change in position.\nIn this picture, the blue vector is the transform.origin. It is equal to the object\u0026rsquo;s position vector.\nConverting Between Local and Global Space You can convert coordinates from local to global by applying the transform. To apply a transform, use xform():\nvar global_position = transform.xform(local_position)\rFor convenience, Node2D and Spatial include helper functions for this. Instead of using transform.xform(), you can call to_global():\nvar global_position = to_global(local_position)\rTo convert from global to local coordinates, you can use the opposite (inverse) of the transform with xform_inv().\nLet\u0026rsquo;s use the example of an object in the 2D plane and convert mouse clicks (global space) into coordinates relative to the object:\nextends Sprite\rfunc _unhandled_input(event):\rif event is InputEventMouseButton and event.pressed:\rif event.button_index == BUTTON_LEFT:\rprintt(event.position, transform.xform_inv(event.position))\rAs with the previous operation, there are helper functions for this. Instead of using transform.xform_inv(), you can call to_local():\nprintt(event.position, to_local(event.position))\rSee the Transform2D docs for a list of the available properties and methods.\n3D Transforms In 3D space, the concept of transforms applies in the same way as in 2D. In fact, it becomes even more necessary, as using angles in 3D can lead to a variety of problems, as we\u0026rsquo;ll see in a bit.\n3D nodes inherit from the base node Spatial, which contains the transform information. The 3D transform requires more information than the 2D version. Position is still held in the origin property, but rotation is in a property called basis, which contains three unit vectors representing the body\u0026rsquo;s local X, Y, and Z axes.\nIn the editor, you can see and manipulate the body\u0026rsquo;s local orientation by clicking the \u0026ldquo;Local Space Mode\u0026rdquo; button. \rAs in 2D, we can use the local axes to move an object forward. In Godot\u0026rsquo;s 3D orientation (Y-up), this means that by default the body\u0026rsquo;s -Z axis is the forward direction:\ntranslation += -transform.basis.z\r\rGodot has default vector values defined, for example: Vector3.FORWARD == Vector3(0, 0, -1). See Vector2 and Vector3 for details.\n\r"},{"uri":"http://kidscancode.org/godot_recipes/g101/3d/101_3d_03/","title":"Creating a 3D Character","tags":[],"description":"","content":"In the last part, we covered how to import 3D objects and how to arrange them in a scene. In this installment, we\u0026rsquo;ll add more objects to the scene, including a user-controlled character.\nBuilding the Scene We\u0026rsquo;re going to continue using the Kenney Platformer Kit we downloaded last time. Select all the \u0026ldquo;block*.glb\u0026rdquo; files and in the \u0026ldquo;Import\u0026rdquo; tab set their \u0026ldquo;Root Type\u0026rdquo; to StaticBody and click \u0026ldquo;Reimport\u0026rdquo;. Select \u0026ldquo;blockLarge.glb\u0026rdquo; and make a new inherited scene. Add a \u0026ldquo;Convex Collision Sibling\u0026rdquo; to the mesh using the menu as you did in the last tutorial. Rename the root node to \u0026ldquo;BlockLarge\u0026rdquo; and save the scene - I recommend making a separate folder for this, as soon you\u0026rsquo;re going to have a bunch of scenes representing the differently shaped platform parts.\nYou can download a starter project with all the block objects already configured and ready to use here: LINK\nOpen the scene from the last tutorial with the \u0026ldquo;Ground\u0026rdquo; plane and the crates. Delete the crates and add an instance of the large block. We want to be able to place these blocks so that they line up. To do this, select \u0026ldquo;Configure Snap\u0026rdquo; from the \u0026ldquo;Transform\u0026rdquo; menu at the top of the Viewport and set Translate Snap to 0.5. Then click on the \u0026ldquo;Snap Mode\u0026rdquo; button (or press the Y key). Now duplicate the block a few times and drag them to arrange.\nIf you like, go ahead and add scenes for some of the other platform blocks and arrange them into a pleasing level. Be creative!\nAdding a Character Now we\u0026rsquo;re going to make a character so we can walk around on the platforms. Open a new scene and start with a KinematicBody named \u0026ldquo;Character\u0026rdquo;. This PhysicsBody node behaves very much like its 2D equivalent (you\u0026rsquo;ve already done the 2D tutorials, right?). It has a move_and_slide() method that we\u0026rsquo;ll use to perform the movement and collision detection. Gravity will be added manually each frame, accelerating in the -Y direction.\nAdd a sphere-shaped MeshInstance and a matching CollisionShape. Remember, you can add a SpatialMaterial to the mesh and set its Albedo property to change the color.\nThe sphere is nice, but it\u0026rsquo;s going to be hard to tell what direction it\u0026rsquo;s facing. Let\u0026rsquo;s add another MeshInstance, this time with a PrismMesh shape. Set its Size to (0.5, 0.5, 0.1) and then its x rotation to -90 degrees. Arrange it so it\u0026rsquo;s pointing along the negative z axis. (You can tell which way is negative because the gizmo arrows point in the positive direction).\nLet\u0026rsquo;s also add a Camera to the scene, so it will follow the player around. Position the camera behind and above the character, angling it down a bit. Click the \u0026ldquo;Preview\u0026rdquo; button to check the camera\u0026rsquo;s view.\nBefore we add a script, open the \u0026ldquo;Project Settings\u0026rdquo; and add the following inputs on the \u0026ldquo;Input Map\u0026rdquo; tab:\n   Input Action Key     move_forward W   move_back S   strafe_right D   strafe_left A   jump Space    Now let\u0026rsquo;s add a script to the body.\nextends KinematicBody\rvar gravity = Vector3.DOWN * 12 # strength of gravity\r var speed = 4 # movement speed\r var jump_speed = 6 # jump strength\r var spin = 0.1 # rotation speed\r var velocity = Vector3()\rvar jump = false\rfunc get_input():\rvelocity.x = 0\rvelocity.z = 0\rif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;):\rvelocity.z -= speed\rif Input.is_action_pressed(\u0026#34;move_back\u0026#34;):\rvelocity.z += speed\rif Input.is_action_pressed(\u0026#34;strafe_right\u0026#34;):\rvelocity.x += speed\rif Input.is_action_pressed(\u0026#34;strafe_left\u0026#34;):\rvelocity.x -= speed\rfunc _physics_process(delta):\rvelocity += gravity * delta\rget_input()\rvelocity = move_and_slide(velocity, Vector3.UP) The code in _physics_process() is pretty straightforward: add gravity to accelerate in the positive Y direction (downward), call get_input() to check for input, and then use move_and_slide() to move in the direction of the velocity vector.\nIn get_input() we check to see which key is pressed and then move in that direction. Run the program and test:\nThis is all good, but we need to be able to rotate. Let\u0026rsquo;s add a camera to the body and we\u0026rsquo;ll use the mouse to rotate. Place the camera above and behind the character so you have a good view, then add the following code to the character\u0026rsquo;s script:\nfunc _unhandled_input(event):\rif event is InputEventMouseMotion:\rif event.relative.x \u0026gt; 0:\rrotate_y(-lerp(0, spin, event.relative.x/10))\relif event.relative.x \u0026lt; 0:\rrotate_y(-lerp(0, spin, event.relative.x/10) This will convert any mouse motion in the x direction into a rotation around the y axis. We use lerp() to smooth it out based on how fast you move the mouse.\nRun the scene and confirm that moving the mouse rotates the character:\nHowever, there\u0026rsquo;s a problem. No matter which way we\u0026rsquo;re facing, pressing W moves us along the Z axis. Our movement is using global coordinates, but we need to move in the object\u0026rsquo;s forward direction.\nThe Power of Transforms This is where transforms come in. A transform is a mathematical matrix that contains the object\u0026rsquo;s translation, rotation, and scale information all in one. In Godot it\u0026rsquo;s stored in the Transform data type. The position information is called the transform.origin and the orientation information is in the transform.basis.\nRemember how the 3D gizmo can be set to \u0026ldquo;Local Space Mode\u0026rdquo;? When in this mode, the gizmo\u0026rsquo;s X/Y/Z axes point along the object\u0026rsquo;s axes. This is the basis of the transform. The basis contains three Vector3 objects callsd x, y, and z that represent these directions. We can use this to ensure that pressing the W key will always move us in the object\u0026rsquo;s forward direction.\nChange the get_input() function like so:\nfunc get_input():\rvar vy = velocity.y\rvelocity = Vector3()\rif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;):\rvelocity += -transform.basis.z * speed\rif Input.is_action_pressed(\u0026#34;move_back\u0026#34;):\rvelocity += transform.basis.z * speed\rif Input.is_action_pressed(\u0026#34;strafe_right\u0026#34;):\rvelocity += transform.basis.x * speed\rif Input.is_action_pressed(\u0026#34;strafe_left\u0026#34;):\rvelocity += -transform.basis.x * speed\rvelocity.y = vy Now forward and back will always move along the objects\u0026rsquo; Z axis, and the strafe keys along its X.\nJumping Let\u0026rsquo;s add one more movement to the player: jumping.\nAdd these lines to the end of get_input(): jump = false\rif Input.is_action_just_pressed(\u0026#34;jump\u0026#34;):\rjump = true\nAnd add these to the end of _physics_process(): if jump and is_on_floor():\rvelocity.y = jump_speed\nWrapping Up In this tutorial you learned how to build a more complex scene, and how to write movement code for a user-controlled character. You also learned about transforms, which are a very important concept in 3D - you\u0026rsquo;re going to be using a lot in the future.\nIn the next part, we\u0026rsquo;ll add some more objects to our 3D world.\nYou can also find a video version of this lesson here:\n   --  "},{"uri":"http://kidscancode.org/godot_recipes/3d/kinematic_car/car_camera/","title":"3D Kinematic Car: Chase Camera","tags":[],"description":"","content":"Problem You want a \u0026ldquo;chase camera\u0026rdquo; that can follow your car (or any other object).\nSolution Godot has a built-in InterpolatedCamera node that does most of what\u0026rsquo;s described here. However, we\u0026rsquo;re not going to use it for two reasons: first, it has a tendency to stutter when following kinematic bodies, and second, it\u0026rsquo;s getting removed in Godot 4.0. Setting up our own is really easy though, so don\u0026rsquo;t worry. \n\rSetting up the camera Add a new scene with a Camera. Name it ChaseCamera, save it, and add a script.\nThe ChaseCamera will have a target - the thing it\u0026rsquo;s following. We\u0026rsquo;re also going to include the ability to change that target.\nextends Camera\rexport var lerp_speed = 10.0\rvar target = null\rfunc _physics_process(delta):\rif !target:\rreturn\rglobal_transform = global_transform.interpolate_with(target.global_transform, lerp_speed * delta)\rfunc _on_change_camera(t):\rtarget = t\rThe only parameter to set here is the lerp_speed, which controls how quickly the camera updates its position. Set it low, and the camera will \u0026ldquo;lag\u0026rdquo; behind the car. Set it high, and it will remain locked on.\nSetting up the target(s) We want to be able to have a few different chase camera positions. One close and one far, for example, or perhaps one looking straight down. Add a Spatial to the car and name it CameraPositions. Add a few Position3Ds to this - as many as you would like.\nMove and orient each Position3D in a different location of your choosing. The position\u0026rsquo;s -Z axis should point at the car.\nYou may find it helpful to temporarily attach a Camera to the position and use its \u0026ldquo;Preview\u0026rdquo; mode to help aim the Position3D so that it\u0026rsquo;s pointing directly where you want (you can remove the camera once you\u0026rsquo;re done). \rTo communicate to the camera, we\u0026rsquo;ll emit a signal whenever we want it to change position. Add the following code to the car\u0026rsquo;s script:\nextends \u0026#34;res://cars/car_base.gd\u0026#34;\rsignal change_camera\rvar current_camera = 0\ronready var num_cameras = $CameraPositions.get_child_count()\rfunc _ready():\remit_signal(\u0026#34;change_camera\u0026#34;, $CameraPositions.get_child(current_camera))\rfunc _input(event):\rif event.is_action_pressed(\u0026#34;change_camera\u0026#34;):\rcurrent_camera = wrapi(current_camera + 1, 0, num_cameras)\remit_signal(\u0026#34;change_camera\u0026#34;, $CameraPositions.get_child(current_camera))\rAdd an action in the InputMap for changing the camera. Here, we\u0026rsquo;re using Tab and the right shoulder button:\nConnecting it together Add a ChaseCamera instance to your main scene and set it Current. Then connect the car\u0026rsquo;s change_camera signal to the camera\u0026rsquo;s _on_change_camera() function.\nRun the game and press the camera change button to try it out:\nRelated recipes  Kinematic Car: Base 2D: Car Steering recipe Input Actions 3D: KinematicBody Movement  Like video? "},{"uri":"http://kidscancode.org/godot_recipes/input/custom_actions/","title":"Adding Input Actions in code","tags":[],"description":"","content":"Problem You need to add actions to the InputMap at runtime.\nSolution Typically, you\u0026rsquo;ll add actions to the InputMap via Project Settings, as shown in Recipe: Input Actions. However, you may find yourself needing to add one or more actions directly in a script. TheInputMap singleton has methods to help you do this.\nHere\u0026rsquo;s an example that would add a new action called \u0026ldquo;attack\u0026rdquo; using the space key:\nfunc _ready():\rInputMap.add_action(\u0026#34;attack\u0026#34;)\rvar ev = InputEventKey.new()\rev.scancode = KEY_SPACE\rInputMap.action_add_event(\u0026#34;attack\u0026#34;, ev)\rIf you also wanted to add the left mouse button to the same action:\nev = InputEventMouseButton.new()\rev.button_index = BUTTON_LEFT\rInputMap.action_add_event(\u0026#34;jump\u0026#34;, ev)\r\rInputMap.add_action() will produce an error if the action already exists. You should check first with InputMap.has_action() before attempting to add a new action.\n\rPractical Example Let\u0026rsquo;s say you\u0026rsquo;ve made the platform character from Recipe: Platform character and you want to re-use it in another project. If you saved the scene, script, and assets in a single folder, you need only copy that folder to your new project. But you\u0026rsquo;d still need to edit the Input Map in order for the inputs to work.\nInstead, you could add the following code to the player script and be sure that the necessary input actions will be added automatically:\nvar controls = {\u0026#34;walk_right\u0026#34;: [KEY_RIGHT, KEY_D],\r\u0026#34;walk_left\u0026#34;: [KEY_LEFT, KEY_A],\r\u0026#34;jump\u0026#34;: [KEY_UP, KEY_W, KEY_SPACE]}\rfunc _ready():\radd_inputs()\rfunc add_inputs():\rvar ev\rfor action in controls:\rif not InputMap.has_action(action):\rInputMap.add_action(action)\rfor key in controls[action]:\rev = InputEventKey.new()\rev.scancode = key\rInputMap.action_add_event(action, ev)\rRelated recipes  Input Actions Platform Character  "},{"uri":"http://kidscancode.org/godot_recipes/input/mouse_capture/","title":"Capturing the Mouse","tags":[],"description":"","content":"Problem You want to hide the mouse cursor and keep the mouse from leaving the game window. This is common in many 3D games (and some 2D ones).\nSolution You can set the mouse state using Input.set_mouse_mode(). There are four possible mouse modes:\n  MOUSE_MODE_VISIBLE: The mouse is visible and can move freely into and out of the window. This is the default state.\n  MOUSE_MODE_HIDDEN: The mouse cursor is invisible, but the mouse can still move outside the window.\n  MOUSE_MODE_CAPTURED: The mouse cursor is hidden and the mouse is unable to leave the game window.\n  MOUSE_MODE_CONFINED: The mouse is visible, but cannot leave the game window.\n  \u0026ldquo;Captured\u0026rdquo; is the most commonly used option. You can set the mouse mode at runtime using:\nfunc _ready():\rInput.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)\rWhen the mouse is captured, mouse input events will still be passed as normal. However, you will find there is a problem. If you want to close the game or switch to another window, you can\u0026rsquo;t. For this reason, you will want to also include a way to \u0026ldquo;release\u0026rdquo; the mouse. For example, to release when the player pressed the Escape key:\nfunc _input(event):\rif event.is_action_pressed(\u0026#34;ui_cancel\u0026#34;):\rInput.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)\rSo that the game doesn\u0026rsquo;t respond to mouse movement when you\u0026rsquo;re in another window, you can test for the capture state in your character controller using:\nif Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:\rOnce the mouse is released, that leaves the need to re-capture it to continue playing. Assuming you have an event in the Input Map for a mouse click, you can do the following:\nif event.is_action_pressed(\u0026#34;click\u0026#34;):\rif Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:\rInput.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)\rSince you may also be using a mouse click to shoot or perform some other action, it\u0026rsquo;s probably a good idea to stop the event from propagating. Add this after setting the mouse mode:\nget_tree().set_input_as_handled()\r"},{"uri":"http://kidscancode.org/godot_recipes/2d/car_steering/","title":"Car steering","tags":[],"description":"","content":"Problem You need to create a 2D top-down car controller.\nSolution When approaching this problem, beginners often wind up creating something that handles nothing like a real car. Some common mistakes you\u0026rsquo;ll find in amateur car games:\n A car doesn\u0026rsquo;t rotate around its center. Put another way, a car\u0026rsquo;s rear wheels don\u0026rsquo;t slide side-to-side. (Unless it\u0026rsquo;s drifting, but we\u0026rsquo;ll talk about that later.) A car can only turn when it\u0026rsquo;s moving - it can\u0026rsquo;t spin in place. A car isn\u0026rsquo;t a train; it\u0026rsquo;s not on rails. Turning at high speeds should involve some sliding (drifting).  There are many approaches to 2D car physics, mainly depending on how \u0026ldquo;realistic\u0026rdquo; you want to be. For this solution, we\u0026rsquo;re going for an \u0026ldquo;arcade\u0026rdquo; level of realism, meaning we\u0026rsquo;ll prioritize action over realism.\nThe method below is based on the algorithm found here: http://engineeringdotnet.blogspot.com/2010/04/simple-2d-car-physics-in-games.html\n\rThe recipe below is broken into 5 parts, each adding a different feature to the car\u0026rsquo;s movement. Feel free to mix-and-match for your needs.\nScene setup Here\u0026rsquo;s the car scene setup:\n- KinematicBody2D\r- Sprite\r- CollisionShape2D\r- Camera2D\rAdd whatever sprite texture you like. For this demo, we\u0026rsquo;ll use art from Kenney\u0026rsquo;s Racing Pack. CapsuleShape2D is a good choice for the collision, so that the car won\u0026rsquo;t have sharp corners to get caught on obstacles.\nWe\u0026rsquo;ll also use four input actions: \u0026ldquo;steer_right\u0026rdquo;, \u0026ldquo;steer_left\u0026rdquo;, \u0026ldquo;accelerate\u0026rdquo;, and \u0026ldquo;brake\u0026rdquo;.\nPart 1: Movement The first step is to code the movement based on the algorithm described above.\nStart with a few variables:\nextends KinematicBody2D\rvar wheel_base = 70 # Distance from front to rear wheel\r var steering_angle = 15 # Amount that front wheel turns, in degrees\r var velocity = Vector2.ZERO\rvar steer_angle\rSet wheelbase to a value that works with your sprite.\nSince we\u0026rsquo;re using keyboard controls, turning is all-or-nothing. If you\u0026rsquo;re using an analog joystick, you can instead vary this value based on the distance the stick moves.\n\rfunc _physics_process(delta):\rget_input()\rcalculate_steering(delta)\rvelocity = move_and_slide(velocity)\rEach frame, we need to check for input and calculate steering. Then we pass the resulting velocity to move_and_slide(). We\u0026rsquo;ll define those two function next:\nfunc get_input():\rvar turn = 0\rif Input.is_action_pressed(\u0026#34;steer_right\u0026#34;):\rturn += 1\rif Input.is_action_pressed(\u0026#34;steer_left\u0026#34;):\rturn -= 1\rsteer_angle = turn * deg2rad(steering_angle)\rvelocity = Vector2.ZERO\rif Input.is_action_pressed(\u0026#34;accelerate\u0026#34;):\rvelocity = transform.x * 500\rHere we check for user input and set the velocity. Note: the speed of 500 is temporary so that we can test movement. We\u0026rsquo;ll address it in the next part.\nfunc calculate_steering(delta):\rvar rear_wheel = position - transform.x * wheel_base / 2.0\rvar front_wheel = position + transform.x * wheel_base / 2.0\rrear_wheel += velocity * delta\rfront_wheel += velocity.rotated(steer_angle) * delta\rvar new_heading = (front_wheel - rear_wheel).normalized()\rvelocity = new_heading * velocity.length()\rrotation = new_heading.angle()\rHere is where we implement the algorithm from the link:\n Find the wheel positions. Move the wheels forward. Find the new direction vector. Set the velocity and rotation to the new direction.  Run the project and the car should move and turn. It\u0026rsquo;s still very unnatural though - the car starts and stops instantly. To fix that, we\u0026rsquo;ll add acceleration into the calculation.\nPart 2: Acceleration We\u0026rsquo;ll need another setting variable and one to track the car\u0026rsquo;s overall acceleration:\nvar engine_power = 800 # Forward acceleration force.\r var acceleration = Vector2.ZERO\rChange the input code to apply acceleration instead of directly changing the car\u0026rsquo;s velocity.\nfunc get_input():\rvar turn = 0\rif Input.is_action_pressed(\u0026#34;steer_right\u0026#34;):\rturn += 1\rif Input.is_action_pressed(\u0026#34;steer_left\u0026#34;):\rturn -= 1\rsteer_angle = turn * steering_angle\rif Input.is_action_pressed(\u0026#34;accelerate\u0026#34;):\racceleration = transform.x * engine_power\rOnce we\u0026rsquo;ve got our acceleration, we can apply it to the velocity like so:\nfunc _physics_process(delta):\racceleration = Vector2.ZERO\rget_input()\rcalculate_steering(delta)\rvelocity += acceleration * delta\rvelocity = move_and_slide(velocity)\rNow when you run, the car should gradually increase its speed. Careful: we don\u0026rsquo;t have any way to slow down yet!\nPart 3: Friction/drag A car experiences two different deceleration forces: friction and drag.\n  Friction is the force applied by the ground. It\u0026rsquo;s high if driving on sand, but low if driving on ice. Friction is proportional to velocity - the faster you\u0026rsquo;re going the stronger the force.\n  Drag is the force resulting from wind resistance. It\u0026rsquo;s based on the car\u0026rsquo;s cross-section - a large truck or van experiences more drag than a sleek race car. Drag is proportional to the velocity squared.\n  This means that friction is more significant when moving slowly, but drag becomes dominant at high speeds. We\u0026rsquo;ll add both of these forces to our calculation. As a bonus, the values of these quantities will also give our car a maximum speed - the point where the force from the engine can\u0026rsquo;t overcome the drag force any longer.\nHere are our starting values for these quantities:\nvar friction = -0.9\rvar drag = -0.0015\rAs you can see in this graph, these values mean that at a speed of 600 the drag force overcomes the friction force.\nYou can play with the values here to see how they change: https://www.desmos.com/calculator/e4ayu3xkip\nIn _physics_process() we\u0026rsquo;ll call a function to calculate the current friction and apply it to the acceleration force.\nfunc _physics_process(delta):\racceleration = Vector2.ZERO\rget_input()\rapply_friction()\rcalculate_steering(delta)\rvelocity += acceleration * delta\rvelocity = move_and_slide(velocity)\rfunc apply_friction():\rif velocity.length() \u0026lt; 5:\rvelocity = Vector2.ZERO\rvar friction_force = velocity * friction\rvar drag_force = velocity * velocity.length() * drag\rif velocity.length() \u0026lt; 100:\rfriction_force *= 3\racceleration += drag_force + friction_force\rFirst, we\u0026rsquo;ll set a minimum speed. This will ensure that the car doesn\u0026rsquo;t keep creeping forward at very low speeds as friction never quite reaches zero.\nThen we calculate the two forces and add them to the total acceleration.\n\nPart 4: Reverse/Brake We\u0026rsquo;ll need two more settings variables:\nvar braking = -450\rvar max_speed_reverse = 250\rAdd the input to get_input():\nif Input.is_action_pressed(\u0026#34;brake\u0026#34;):\racceleration = transform.x * braking\rThis is fine for coming to a stop, but we also want to be able to put the car in reverse. Currently, that won\u0026rsquo;t work, because the acceleration is always being applied in the \u0026ldquo;heading\u0026rdquo; direction, which is forward. When we\u0026rsquo;re reversing, we need to accelerate backward.\nfunc calculate_steering(delta):\rvar rear_wheel = position - transform.x * wheel_base / 2.0\rvar front_wheel = position + transform.x * wheel_base / 2.0\rrear_wheel += velocity * delta\rfront_wheel += velocity.rotated(steer_angle) * delta\rvar new_heading = (front_wheel - rear_wheel).normalized()\rvar d = new_heading.dot(velocity.normalized())\rif d \u0026gt; 0:\rvelocity = new_heading * velocity.length()\rif d \u0026lt; 0:\rvelocity = -new_heading * min(velocity.length(), max_speed_reverse)\rrotation = new_heading.angle()\rWe can find whether we\u0026rsquo;re accelerating forward or backward using the dot product. If the two vectors are aligned, the result will be greater than 0. If the movement is in the opposite direction the car\u0026rsquo;s facing, then the dot product will be less than 0 and we must be moving backward.\n\nPart 5: Drift/slide We could stop here and you\u0026rsquo;d have a satisfactory driving experience. However, the car still feels like it\u0026rsquo;s \u0026ldquo;on rails\u0026rdquo;. Even at top speed, the turns are perfect, as if the tires have perfect \u0026ldquo;grip\u0026rdquo;.\nAt high speeds (or even low ones, if desired), the turning force should cause the tires to slip and result in a fishtailing/sliding motion.\nvar slip_speed = 400 # Speed where traction is reduced\r var traction_fast = 0.1 # High-speed traction\r var traction_slow = 0.7 # Low-speed traction\r We\u0026rsquo;ll apply these values when calculating the steering. Currently, the velocity is instantly set to the new heading. Instead, we\u0026rsquo;ll use linear_interpolate() to cause it to only \u0026ldquo;turn\u0026rdquo; partway towards the new direction. The \u0026ldquo;traction\u0026rdquo; values will determine how \u0026ldquo;sticky\u0026rdquo; the tires are - a value of 1.0 would represent no sliding.\nfunc calculate_steering(delta):\rvar rear_wheel = position - transform.x * wheel_base / 2.0\rvar front_wheel = position + transform.x * wheel_base / 2.0\rrear_wheel += velocity * delta\rfront_wheel += velocity.rotated(steer_angle) * delta\rvar new_heading = (front_wheel - rear_wheel).normalized()\rvar traction = traction_slow\rif velocity.length() \u0026gt; slip_speed:\rtraction = traction_fast\rvar d = new_heading.dot(velocity.normalized())\rif d \u0026gt; 0:\rvelocity = velocity.linear_interpolate(new_heading * velocity.length(), traction)\rif d \u0026lt; 0:\rvelocity = -new_heading * min(velocity.length(), max_speed_reverse)\rrotation = new_heading.angle()\rHere, we select which traction value to use and apply linear_interpolate() to the velocity.\n\nAdjustments At this point, we have a large number of settings that control the car\u0026rsquo;s behavior. Adjusting them can drastically change how the car drives. To make experimenting with different values easier, download the project for this recipe below. When you run the game, you\u0026rsquo;ll see a set of sliders you can use to change the car\u0026rsquo;s behavior as you drive (press \u0026lt;Tab\u0026gt; to show/hide the slider panel).\nDownload the project file here: car_steering.zip\n\rRelated recipes  Gamedev Math: Interpolation  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/shaders/greyscale/","title":"Greyscale (monochrome) shader","tags":[],"description":"","content":"Problem You want a shader to convert an image to greyscale.\nSolution Let\u0026rsquo;s start with a canvas_item (2D) shader. To convert to greyscale but also preserve pixel contrast, we need to average the pixel\u0026rsquo;s color value. Add the color channels together and divide by 3:\nshader_type canvas_item;\rvoid fragment() {\rCOLOR = texture(TEXTURE, UV);\rfloat avg = (COLOR.r + COLOR.g + COLOR.b) / 3.0;\rCOLOR.rgb = vec3(avg);\r}\rYou can apply this to the whole screen by adding a ColorRect (placed in a CanvasLayer to ignore camera movement) and scaling it to cover the screen.\nChange the texture() function to sample the screen instead of the object\u0026rsquo;s pixels:\nCOLOR = texture(SCREEN_TEXTURE, SCREEN_UV);\rRelated Recipes  Shaders: Intro  "},{"uri":"http://kidscancode.org/godot_recipes/physics/kinematic_friction/","title":"Kinematic Friction","tags":[],"description":"","content":"Problem You want to add friction and acceleration to your kinematic character, giving it a smoother feel.\nSolution For most games, we\u0026rsquo;re not necessarily interested in a perfect physics simulation. We want action, responsiveness, and arcade feel. This is why you choose a kinematic body over a rigid one: so that you can control its behavior directly. However, some amount of physics is good - it means an object doesn\u0026rsquo;t instantly change direction or come to a stop.\nBelow is the code for a no-frills kinematic platformer character:\nextends KinematicBody2D\rvar speed = 1200\rvar jump_speed = -1800\rvar gravity = 4000\rvar velocity = Vector2.ZERO\rfunc get_input():\rvelocity.x = 0\rif Input.is_action_pressed(\u0026#34;ui_right\u0026#34;):\rvelocity.x += speed\rif Input.is_action_pressed(\u0026#34;ui_left\u0026#34;):\rvelocity.x -= speed\rfunc _physics_process(delta):\rget_input()\rvelocity.y += gravity * delta\rvelocity = move_and_slide(velocity, Vector2.UP)\rif Input.is_action_just_pressed(\u0026#34;ui_select\u0026#34;):\rif is_on_floor():\rvelocity.y = jump_speed\rIf you run this code, you\u0026rsquo;ll see that the character\u0026rsquo;s x velocity changes instantaneously. To fix this, we\u0026rsquo;ll use lerp() to gradually increase/decrease the velocity.\nUsing lerp lerp(start_value, end_value, amount)\rlerp(), aka linear interpolate, finds a \u0026ldquo;blended\u0026rdquo; value between two given numbers. See Interpolation for details.\nIn the code below, friction represents how quickly the character comes to a stop, while acceleration determines how quickly it gets up to full speed. Both are values between 0.0 and 1.0.\nReplace the get_input() code with the following:\nvar friction = 0.1\rvar acceleration = 0.5\rfunc get_input():\rvar input_dir = 0\rif Input.is_action_pressed(\u0026#34;ui_right\u0026#34;):\rinput_dir += 1\rif Input.is_action_pressed(\u0026#34;ui_left\u0026#34;):\rinput_dir -= 1\rif dir != 0:\r# accelerate when there\u0026#39;s input\r velocity.x = lerp(velocity.x, dir * speed, acceleration)\relse:\r# slow down when there\u0026#39;s no input\r velocity.x = lerp(velocity.x, 0, friction)\rExplanation We\u0026rsquo;re using friction and acceleration as the amount to blend. For acceleration, we want to find a value between the current speed and the maximum, speed. When decelerating, we\u0026rsquo;re ramping the current speed down to 0.\nUsing values of 1.0 would recreate the \u0026ldquo;instant\u0026rdquo; movement we started with.\n\rRelated Recipes  Platform Character  "},{"uri":"http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_03/","title":"Limited circles","tags":[],"description":"","content":"In the first two parts, we got the basic gameplay working. Now we\u0026rsquo;re going to start adding some different modes to the circles.\nCircle modes Eventually, we\u0026rsquo;ll have many different modes, but we\u0026rsquo;re going to start with the \u0026ldquo;limited\u0026rdquo; mode: the circle only allows a given number of orbits before disappearing. First, let\u0026rsquo;s add a Label node to show the number of remaining orbits. Type a number (1) in the text field so we can see how it looks.\nIn the Custom Fonts section, add a new DynamicFont, load the Font Data from the assets folder, and set the Size to 64. To align the label, in the \u0026ldquo;Layout\u0026rdquo; menu, choose \u0026ldquo;Center\u0026rdquo;.\nAdd the following new variables at the top of the Circle.gd:\nenum MODES {STATIC, LIMITED}\rvar mode = MODES.STATIC\rvar num_orbits = 3 # Number of orbits until the circle disappears\r var current_orbits = 0 # Number of orbits the jumper has completed\r var orbit_start = null # Where the orbits started\r Next we need a way to set the mode:\nfunc set_mode(_mode):\rmode = _mode\rmatch mode:\rMODES.STATIC:\r$Label.hide()\rMODES.LIMITED:\rcurrent_orbits = num_orbits\r$Label.text = str(orbits_left)\r$Label.show()\rRight now we have these two modes defined, but later we\u0026rsquo;ll be adding more.\nLet\u0026rsquo;s also add to the init() method a way to pass a mode. The default should be STATIC, but we\u0026rsquo;re going to use LIMITED now so we can test:\nfunc init(_position, _radius=radius, _mode=MODES.LIMITED):\rset_mode(_mode)\rThe jumper is setting the rotation position when it\u0026rsquo;s captured. Remove the line from Jumper.gd and put it in the circle\u0026rsquo;s capture() method:\nfunc capture(target):\rjumper = target\r$AnimationPlayer.play(\u0026#34;capture\u0026#34;)\r$Pivot.rotation = (jumper.position - position).angle()\rorbit_start = $Pivot.rotation\rNote that we\u0026rsquo;re now sending a reference to the jumper, so add var jumper = null at the top, and in the Main.gd script update the call to read object.capture(player).\nNow we can check to see if the jumper has gone full circle, and if so, decrement current_orbits:\nfunc _process(delta):\r$Pivot.rotation += rotation_speed * delta\rif mode == MODES.LIMITED and jumper:\rcheck_orbits()\rfunc check_orbits():\r# Check if the jumper completed a full circle\r if abs($Pivot.rotation - orbit_start) \u0026gt; 2 * PI:\rcurrent_orbits -= 1\r$Label.text = str(current_orbits)\rif orbits_left \u0026lt;= 0:\rjumper.die()\rjumper = null\rimplode()\rorbit_start = $Pivot.rotation\rIn order for this to work, we need to add a die() method to the jumper:\nfunc die():\rtarget = null\rqueue_free()\rfunc _on_VisibilityNotifier2D_screen_exited():\rif !target:\rdie()\rWe\u0026rsquo;ve also connected the jumper\u0026rsquo;s VisibilityNotifier2D signal so that we can remove the player when it exits the screen.\nIf we try it out, everything looks good so far:\nCircle effect The last thing we\u0026rsquo;ll do for this part is add a \u0026ldquo;fill\u0026rdquo; effect to the circle to show that the orbits are running out. To begin, we\u0026rsquo;ll use some drawing code from the official docs:\nfunc draw_circle_arc_poly(center, radius, angle_from, angle_to, color):\rvar nb_points = 32\rvar points_arc = PoolVector2Array()\rpoints_arc.push_back(center)\rvar colors = PoolColorArray([color])\rfor i in range(nb_points + 1):\rvar angle_point = angle_from + i * (angle_to - angle_from) / nb_points - PI/2\rpoints_arc.push_back(center + Vector2(cos(angle_point), sin(angle_point)) * radius)\rdraw_polygon(points_arc, colors)\rWe\u0026rsquo;ll call this function in _draw():\nfunc _draw():\rif jumper:\rvar r = ((radius - 50) / num_orbits) * (1 + num_orbits - current_orbits)\rdraw_circle_arc_poly(Vector2.ZERO, r, orbit_start + PI/2,\r$Pivot.rotation + PI/2, Color(1, 0, 0))\rLastly, add update() to the _physics_process so that it will be called after every call to check_orbits().\nIn the next part we\u0026rsquo;ll start adding some UI.\n Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "},{"uri":"http://kidscancode.org/godot_recipes/animation/melee_attacks/","title":"Melee attacks","tags":[],"description":"","content":"Problem You want to implement a melee attack, such as a sword or punch.\nSolution For this example, we\u0026rsquo;ll assume we have already set up a character with one or more attack animations. To illustrate, we\u0026rsquo;ll use these two attacks:\nWe can detect the sword hitting the target using an Area2D, but we only want that area to be active during the swing. In order for this activation to be in sync with the animation, we\u0026rsquo;ll use the AnimationPlayer to control it.\nAdd an Area2D and CollisionShape2D to the scene. We\u0026rsquo;ll use a rectangle shape for the hitbox and size it so that it covers the sword during the swing frame.\nMove the animation to the first frame and check the Disabled property of the area. Click the keyframe icon to add a track to the animation. Then advance the animation to the frame where the sword is extended, and add another keyframe with Disabled unchecked. Finally, advance to the end of the swing and keyframe Disabled on once more.\nNow connect this new area\u0026rsquo;s area_entered signal (or, depending on how your game is set up, body_entered). For the purposes of this demo, let\u0026rsquo;s assume that any body that can take damage has an Area2D defined and placed in a group called \u0026ldquo;hurtbox\u0026rdquo;.\nfunc _on_SwordHit_area_entered(area):\rif area.is_in_group(\u0026#34;hurtbox\u0026#34;):\rarea.take_damage()\rNow you should be able to try it out and see the attack doing damage if the target is inside the sword\u0026rsquo;s hitbox.\nChanging the hitbox size When you have more than one attack animation, the size of the affected area may not be the same. In the above attack animations, the first one is an upward sweeping attack that covers more area. To handle this, we also need to add an animation track for the collision shape\u0026rsquo;s Extents property. Set this and keyframe it at the start of each animation.\nRelated recipes  Top-down character Controlling animation states  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/math/noise/","title":"Noise","tags":[],"description":"","content":"Problem You want to use Godot\u0026rsquo;s OpenSimplexNoise to generate noise, noise textures, and other effects.\nSolution Noise, or more specifically gradient noise is a method for generating more natural-looking \u0026ldquo;random\u0026rdquo; patterns. To do this, Godot provides the OpenSimplexNoise class.\nProbably the most well-known gradient noise algorithm is called Perlin noise. Because it and its successor, simplex noise, are protected by patents, Godot uses an algorithm called OpenSimplex to generate noise.\n\rOpenSimplexNoise works by generating a 3D \u0026ldquo;cloud\u0026rdquo; of points. Each point has a value ranging from -1 to 1. Below are two examples of noise generated by OpenSimplexNoise. In the images, each pixel\u0026rsquo;s white value is mapped to the noise value at that point.\nThe parameters used for configuring OpenSimplexNoise:\n seed - The seed used to generate the random values. Default value: 0. period - Lower values result in higher frequency noise (i.e. more changes in value across the same distance). Default value: 64. octaves - The number of noise layers that contribute to the result. Each successive layer affects the result less (based on the persistence). Default value: 3. lacunarity - The difference in period between octaves. Default value: 2. persistence - The amount that each octave contributes to the noise. Default value: 0.5.  Here\u0026rsquo;s the easiest way to experiment with the effects of the different parameters. Add a Sprite and in its Texture property, choose \u0026ldquo;New NoiseTexture\u0026rdquo;. In that NoiseTexture for Noise choose \u0026ldquo;New OpenSimplexNoise\u0026rdquo;.\nYou\u0026rsquo;ll see a black-and-white texture that\u0026rsquo;s generated based on the noise values. Adjust the values and observe the effect on the image.\nUsing noise values Once you have your noise configured, there are a few ways you can access the values.\n get_noise_2d(x, y) get_noise_3d(x, y, z) get_noise_4d(x, y, z, w)  In each case, the result is a value in the range [-1, 1].\nYou may have noticed there\u0026rsquo;s no get_noise_1d() method. If you need one-dimensional noise, use get_noise_2d() and keep one of the values constant.\n\rFor example, we can use get_noise_3d() to generate a 2d image while varying the third dimension over time to get an animated effect:\nIn this image the color is based on the noise value. Since we don\u0026rsquo;t want negative values for color, we use\nvar value = get_noise_3d(x, y, z) * 0.5 + 0.5\nto modify the results to the range [0, 1]. Then, this value is applied to color using the following formula:\nColor(1.0-value/2.0, 0.5-value/2.0, value/4.0)\nNoise applications Noise can be used for a wide range of applications:\n Procedural terrain generation Visual effects (water, fog, fire, etc)  Download the project file here: kinematic_vs_rigid.zip\n\r--\rRelated recipes  Screen Shake  Like video?   --"},{"uri":"http://kidscancode.org/godot_recipes/basics/understanding_delta/","title":"Understanding &#39;delta&#39;","tags":[],"description":"","content":"Problem The delta or \u0026ldquo;delta time\u0026rdquo; parameter is a frequently-misunderstood concept in game development. In this tutorial, we\u0026rsquo;ll explain how it\u0026rsquo;s used, the importance of frame-rate independent movement, and practical examples of its use in Godot.\nSolution To illustrate the problem, let\u0026rsquo;s consider a Sprite node moving across the screen. If our screen is 600 pixels wide and we want the sprite to take 5 seconds to cross the screen, we can use the following calculation to find the necessary speed:\n600 pixels / 5 seconds = 120 pixels/second\rWe\u0026rsquo;ll move the sprite every frame using the _process() function. If the game is running at 60 frames per second, we can find the per-frame movement like so:\n120 pixels/second * 1/60 second/frame = 2 pixels/frame\r\rNotice the units are consistent in all the calculations above. Always pay attention to the units in your calculations - it\u0026rsquo;ll save you from making mistakes.\n\rHere\u0026rsquo;s the necessary code:\nextends Node2D\r# Desired movement in pixels/frame\r var movement = Vector2(2, 0)\rfunc _process(delta):\r$Sprite.position += movement\rRun this code and you\u0026rsquo;ll see the sprite takes 5 seconds to cross the screen.\nMaybe. The trouble begins if there is something else occupying the computer\u0026rsquo;s time. This is called lag and can come from a variety of sources - the cause could be your code or even other applications running on your computer. If this happens, then the length of a frame might increase. As an extreme example, imagine that the frame rate is halved - each frame took 1/30 instead of 1/60 of a second. Moving at 2 px/frame, it\u0026rsquo;s now going to take twice as long for the sprite to reach the edge.\nEven small frame rate fluctuations will result in inconsistent movement speed. If this were a bullet or other fast-moving object, we wouldn\u0026rsquo;t want it slowing down like this. We need the movement to be frame rate independent.\nFixing the frame rate problem When using the _process() function, it automatically includes a parameter called delta that\u0026rsquo;s passed in from the engine (so does _physics_process(), which is used for physics-related code). This is a floating point value representing the length of time since the previous frame. Typically, this will be approximately 1/60 or 0.0167 seconds.\nWith this information, we can stop thinking about how much to move each frame, and only consider our desired speed in pixels/second (120 from the above calculation).\nMultiplying the engine\u0026rsquo;s delta value by this number will give us how many pixels to move each frame. The number will automatically adjust if the frame time fluctuates.\n# 60 frames/second\r120 pixels/second * 1/60 second/frame = 2 pixels/frame\r# 30 frames/second\r120 pixels/second * 1/30 second/frame = 4 pixels/frame\rNote that if the frame rate decreases by half (meaning the frame time doubles), then our per-frame movement must also double to keep the desired speed.\nLet\u0026rsquo;s change the code to use this calculation:\nextends Node2D\r# Desired movement in pixels/second.\r var movement = Vector2(120, 0)\rfunc _process(delta):\r$Sprite.position += movement * delta\rNow when running at 30 frames per second, the travel time is consistent:\nIf the frame rate gets very low, the movement is no longer smooth, but the time remains the same.\nUsing delta with motion equations What if your movement is more complex? The concept remains the same. Keep your units in seconds, not frames, and multiply by delta each frame.\nWorking in pixels and seconds is much easier to conceptualize too, since it relates to how we measure these quantities in the real world. \u0026ldquo;Gravity is 100 pixels/second/second, so after the ball falls for 2 seconds, it\u0026rsquo;s traveling at 200 pixels/second.\u0026rdquo; If you\u0026rsquo;re working with frames, then you have to think about acceleration in units of pixels/frame/frame. Go ahead and try - it\u0026rsquo;s not very natural.\n\rFor example, if you are applying a gravity, that\u0026rsquo;s an acceleration - each frame it will increase the velocity by some amount. As in the above example, the velocity then changes the node\u0026rsquo;s position.\nTry adjusting delta and target_fps in the following code to see the effect:\nextends Node2D\r# Acceleration in pixels/sec/sec.\r var gravity = Vector2(0, 120)\r# Acceleration in pixels/frame/frame.\r var gravity_frame = Vector2(0, .033)\r# Velocity in pixels/sec or pixels/frame.\r var velocity = Vector2.ZERO\rvar use_delta = false\rvar target_fps = 60\rfunc _ready():\rEngine.target_fps = target_fps\rfunc _process(delta):\rif use_delta:\rvelocity += gravity * delta\r$Sprite.position += velocity * delta\relse:\rvelocity += gravity_frame\r$Sprite.position += velocity\rNote that we\u0026rsquo;re multiplying by our timestep each frame to update both velocity and position. Any quantity that is updated every frame should be multiplied by delta to ensure it changes independent or frame rate.\nUsing kinematic functions In the above examples, we\u0026rsquo;ve used a Sprite to keep things simple, updating the position every frame. If you\u0026rsquo;re using a kinematic body (in 2D or 3D), you\u0026rsquo;ll instead be using one of its movement methods. Specifically in the case of move_and_slide(), there tends to be some confusion, because it automatically applies delta to the movement vector. This means you won\u0026rsquo;t multiply your velocity by delta . But you will still need to apply it on the acceleration. For example:\n# Sprite movement code:\r velocity += gravity * delta\rposition += velocity * delta\r# Kinematic body movement code:\r velocity += gravity * delta\rvelocity = move_and_slide(velocity)\rIf you don\u0026rsquo;t use delta when applying acceleration to your velocity, then your acceleration will be subject to fluctuations in frame rate. This can have a_much more subtle effect on movement - it will be inconsistent, but much more difficult to diagnose.\nWhen using move_and_slide() you still need to apply delta to any other quantities such as gravity, friction, etc.\n\rRelated Recipes  Using KinematicBody2D  "},{"uri":"http://kidscancode.org/godot_recipes/3d/","title":"3D","tags":[],"description":"","content":" 3D Tips, tricks, and tutorials on the 3D side of game development.\nFor a gentle introduction to working in 3D, see: Intro to 3D\nIn this section: \r3D Kinematic Car\r\r\rCamera Gimbal\r\r\rKinematicBody: Movement\r\r\r3D Unit Healthbars\r\r\rShooting projectiles\r\r\rDrawing Vectors in 3D\r\r\rClick to move\r\r\rSmooth rotation\r\r\rKinematicBody: align with surface\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/g101/3d/101_3d_04/","title":"Using Areas","tags":[],"description":"","content":"In the last part, we learned about transforms, a very important concept in 3D that records an object\u0026rsquo;s local orientation in space, and used it to move our KinematicBody character. This time, we\u0026rsquo;re going to look at another type of 3D node: the Area.\nAreas Area nodes are used for detection and influence. They can detect when objects overlap, and when an object enters or exits a region. An Area can also be used to override physics properties, such as gravity or damping, in a region.\nWe\u0026rsquo;re going to use Area to create three types of objects:\n A coin the character can pick up A bullet the character can shoot Spikes that damage the character  To begin, let\u0026rsquo;s set up some collision layers so that we can more easily control what objects the areas can interact with. Open the Project Settings and find the \u0026ldquo;Layer Names/3D Physics\u0026rdquo; section. Name the first three layers \u0026ldquo;environment\u0026rdquo;, \u0026ldquo;player\u0026rdquo;, and \u0026ldquo;pickups\u0026rdquo;.\nCoin Create a new inherited scene from the CoinGold.glb object in the Kenney Platformer Kit (see Part 03). Right-click on the root node, choose \u0026ldquo;Change Type\u0026rdquo;, and pick Area. In the Inspector, set the collision mask and layer so that the coin is in \u0026ldquo;pickups\u0026rdquo; and scans \u0026ldquo;player\u0026rdquo;.\nNow we need a collision shape, so add a CollisionShape node and choose a CylinderShape for it. If you rotate it 90 degrees around z, it will fit the coin shape pretty well.\nAdd a script to the Area and connect its body_entered signal, which we\u0026rsquo;ll use to remove the coin:\nextends Area\rfunc _on_Coin_body_entered(body):\rqueue_free() Add a few coins to your scene and see if you can pick them up:\nBullets Make a new scene with an Area root, and name it \u0026ldquo;Bullet\u0026rdquo;. Add a MeshInstance, a CollisionShape, and a Timer. I\u0026rsquo;m using a sphere shape for the mesh and collision, scaled to a radius of 0.2 so that it won\u0026rsquo;t be too big compared with the character. The Timer is to give the bullet a time limit. Set its One Shot and Autostart properties both on.\nAdd a script and connect the Timer's timeout signal and the Area's body_entered signal. Then add the following:\nextends Area\rvar speed = 15\rvar velocity = Vector3()\rfunc start(xform):\rtransform = xform\rvelocity = -transform.basis.z * speed\rfunc _process(delta):\rtransform.origin += velocity * delta\rfunc _on_Timer_timeout():\rqueue_free()\rfunc _on_Bullet_body_entered(body):\rif body is StaticBody:\rqueue_free() Since we want the bullet to start at a certain location and travel directly ahead of the player, we\u0026rsquo;ll pass the player\u0026rsquo;s transform to start() and use it to orient the bullet and make it move forward (remember in Godot\u0026rsquo;s orientation, \u0026ldquo;forward\u0026rdquo; is along the negative z axis).\nNow we can go to the character scene and add a Position3D node, placing it at the tip of the character\u0026rsquo;s \u0026ldquo;arrow\u0026rdquo; mesh. Name this node \u0026ldquo;Muzzle\u0026rdquo;. Next, add the following code to the character\u0026rsquo;s script:\nvar Bullet = preload(\u0026#34;res://Bullet.tscn\u0026#34;)\rfunc _unhandled_input(event):\rif event.is_action_pressed(\u0026#34;shoot\u0026#34;):\rvar b = Bullet.instance()\rb.start($Muzzle.global_transform)\rget_parent().add_child(b) Spikes Finally, we\u0026rsquo;re going to add some danger to the environment. Make in instance of the spikes.glb object and make it an Area like we did with the coin. Add a script and connect the body_entered signal, but this time, we want the object to do something to the character:\nextends Area\rfunc _on_Spikes_body_entered(body):\rif body.has_method(\u0026#34;take_damage\u0026#34;):\rbody.take_damage() Now we need to define how the character reacts to taking \u0026ldquo;damage\u0026rdquo;. Since we haven\u0026rsquo;t really built a health system, we\u0026rsquo;re just going to \u0026ldquo;bounce\u0026rdquo; the character as if it got hurt. We need to add the following to the character script:\nvar can_move = true\rfunc take_damage():\rvelocity *= -1\rvelocity.y = jump_speed\rcan_move = false\ryield(get_tree().create_timer(1), \u0026#34;timeout\u0026#34;)\rcan_move = true The purpose of this code is to disable input temporarily so the player will fly backwards from the spikes. If we just tried to set the velocity, it would immediately be overridden by the velocity set by the key inputs. So add this at the beginning of get_input():\nif !can_move:\rreturn Add a spike instance to your level and try it out:\nWrapping Up In this tutorial you learned how to use Area nodes to detect and react to 3D bodies.\nIn the next part: a collection of small improvements.\nYou can also find a video version of this lesson here:\n   --"},{"uri":"http://kidscancode.org/godot_recipes/3d/kinematic_car/car_slopes/","title":"3D Kinematic Car: Slopes &amp; Ramps","tags":[],"description":"","content":"Problem Your Kinematic Car climbs slopes, but it doesn\u0026rsquo;t look quite right:\nSolution Kinematic bodies don\u0026rsquo;t automatically rotate on collision. When the wheels aren\u0026rsquo;t both touching the ground, as in the image above, we\u0026rsquo;ll need to align the car manually.\nTo begin, we need to detect when the wheel isn\u0026rsquo;t on the ground. Add two RayCast nodes to the car and align them with the front and rear wheels like so:\nFor both, set the Cast To to (0, -0.25, 0) and don\u0026rsquo;t forget to check the \u0026ldquo;Enabled\u0026rdquo; box.\nAligning a 3D object We\u0026rsquo;re going to reuse the code from the KinematicBody: Align with Surface recipe. Add this to car_base.gd:\nfunc align_with_y(xform, new_y):\rxform.basis.y = new_y\rxform.basis.x = -xform.basis.z.cross(new_y)\rxform.basis = xform.basis.orthonormalized()\rreturn xform\rNow, in the _physics_process() function, right after calling move_and_slide_with_snap(), we\u0026rsquo;ll check to see if we need to align the car:\n# If either wheel is in the air, align to slope.\r if $FrontRay.is_colliding() or $RearRay.is_colliding():\r# If one wheel is in air, move it down\r var nf = $FrontRay.get_collision_normal() if $FrontRay.is_colliding() else Vector3.UP\rvar nr = $RearRay.get_collision_normal() if $RearRay.is_colliding() else Vector3.UP\rvar n = ((nr + nf) / 2.0).normalized()\rvar xform = align_with_y(global_transform, n)\rglobal_transform = global_transform.interpolate_with(xform, 0.1)\rHow it works When neither wheel is on the ground, we don\u0026rsquo;t rotate the car at all.\nOtherwise, we\u0026rsquo;re going to use an average of the front and rear rays\u0026rsquo; results. When the ray is colliding, the collider\u0026rsquo;s surface normal is used. This way, if the two wheels are touching different slopes (like on a curved hill, for example), the result will be to try and get both wheels on the surface, like so:\nIn this image, you can see the car isn\u0026rsquo;t aligned with either surface, but is halfway between.\nIf the ray is not hitting anything, then we\u0026rsquo;ll assume a horizontal surface. That will bring the front or rear down when the other wheel is touching.\nRelated recipes  Kinematic Car: Base KinematicBody: Align with Surface  Like video? "},{"uri":"http://kidscancode.org/godot_recipes/shaders/blur/","title":"Blur shader","tags":[],"description":"","content":"Problem You want a shader to blur an object or the screen.\nSolution shader_type canvas_item;\runiform float blur_amount : hint_range(0, 5);\rvoid fragment() {\rCOLOR = textureLod(SCREEN_TEXTURE, SCREEN_UV, blur_amount);\r}\rFor example, to gradually blur the entire screen, such as for a scene transition effect:\nYou can also animate the blurring:\nextends Node\r# Add a ColorRect or other Control set to fill the screen\r # Place it lower in the tree and/or place in CanvasLayer\r # so it\u0026#39;s on top of the rest of the scene.\r onready var blur = $Blur\rvar blur_amount = 0\rfunc _process(delta):\rblur_amount = wrapf(blur_amount + 0.05, 0.0, 5.0)\rblur.material.set_shader_param(\u0026#34;blur_amount\u0026#34;, blur_amount)\r\nRelated Recipes  Shaders: Intro Interacting with Shaders  "},{"uri":"http://kidscancode.org/godot_recipes/ai/changing_behaviors/","title":"Changing behaviors","tags":[],"description":"","content":"Problem You want your AI-controlled entity to switch between different behaviors.\nSolution For this example, we\u0026rsquo;ll assume an enemy with the following behaviors. See the individual recipes for how to make each behavior work.\n  Patrol\nThe \u0026ldquo;Patrol\u0026rdquo; state moves along a pre-defined path (or stands still if there\u0026rsquo;s no path assigned). See Recipe: Path following for details.\n  Chase\nThe \u0026ldquo;Chase\u0026rdquo; state moves the enemy towards the player. See Recipe: Chasing the player for how to make this behavior.\n  Attack\nIn this state, the player is in range of a melee attack, so the enemy stops moving and executes its attack. See Recipe: Melee attacks for how to make melee attacks.\n  These behaviors are states - the enemy can only be in one of these states at a time, and certain events, such as the player getting near, will cause a transition to another state.\nTo determine the state transitions, we have two Area2D nodes on the enemy: an outer one called \u0026ldquo;DetectRadius\u0026rdquo; and an inner called \u0026ldquo;AttackRadius\u0026rdquo;. The player entering or exiting these areas will trigger the related behavior.\nWe\u0026rsquo;ve chosen a rectangular shape for AttackRadius in this example due to the shape of the enemy\u0026rsquo;s attack. Any shape is fine as long as it\u0026rsquo;s smaller than the DetectRadius.\nConnect the body_entered and body_exited signals of both these areas. If you\u0026rsquo;re using collision layers (and you should be), set them so that they can only detect the player (or any other body you want to be chased/attacked).\nNow let\u0026rsquo;s examine the enemy\u0026rsquo;s script:\nextends KinematicBody2D\renum states {PATROL, CHASE, ATTACK, DEAD}\rvar state = states.PATROL\rWe start with an enum to give us a way to reference our states by name, and a variable to hold the current state.\n# For setting animations.\r var anim_state\rvar run_speed = 25\rvar attacks = [\u0026#34;attack1\u0026#34;, \u0026#34;attack2\u0026#34;]\r# For path following.\r export (NodePath) var patrol_path\rvar patrol_points\rvar patrol_index = 0\r# Target for chase mode.\r var player = null\rvar velocity = Vector2(run_speed, 0)\rThe other variables needed for the individual behaviors and animations. See the referenced behavior links above for details.\nfunc _physics_process(delta):\rchoose_action()\r# Changing the x scale flips the sprite and its attack area.\r if velocity.x \u0026gt; 0:\r$Sprite.scale.x = 1\relif velocity.x \u0026lt; 0:\r$Sprite.scale.x = -1\r# If we\u0026#39;re moving, show the run animation.\r if velocity.length() \u0026gt; 0:\ranim_state.travel(\u0026#34;run\u0026#34;\r)\r# Show the idle animation when coming to a stop (but not attacking).\r if anim_state.get_current_node() == \u0026#34;run\u0026#34; and velocity.length() == 0:\ranim_state.travel(\u0026#34;idle\u0026#34;)\rvelocity = move_and_slide(velocity)\rWe\u0026rsquo;ll handle movement as normal in _physics_process(), calling choose_action() (see below) to decide what the resulting movement will be.\nfunc choose_action():\rvelocity = Vector2.ZERO\rvar current = anim_state.get_current_node()\r# If we\u0026#39;re currently attacking, don\u0026#39;t move or change state.\r if current in attacks:\rreturn\r# Depending on the current state, choose a movement target.\r var target\rmatch state:\rstates.DEAD:\rset_physics_process(false)\r# Move along assigned path.\r states.PATROL:\rif !patrol_path:\rreturn\rtarget = patrol_points[patrol_index]\rif position.distance_to(target) \u0026lt; 1:\rpatrol_index = wrapi(patrol_index + 1, 0, patrol_points.size())\rtarget = patrol_points[patrol_index]\rvelocity = (target - position).normalized() * run_speed\r# Move towards player.\r states.CHASE:\rtarget = player.position\rvelocity = (target - position).normalized() * run_speed\r# Make an attack.\r states.ATTACK:\rtarget = player.position\rif target.x \u0026gt; position.x:\r$Sprite.scale.x = 1\relif target.x \u0026lt; position.x:\r$Sprite.scale.x = -1\ranim_state.travel(\u0026#34;attack\u0026#34;)\rIn choose_action() we determine the target and move toward it.\nfunc _on_DetectRadius_body_entered(body):\rstate = states.CHASE\rplayer = body\rfunc _on_DetectRadius_body_exited(body):\rstate = states.PATROL\rplayer = null\rfunc _on_AttackRadius_body_entered(body):\rstate = states.ATTACK\rfunc _on_AttackRadius_body_exited(body):\rstate = states.CHASE\rFinally, the functions connected to the area signals change the state accordingly.\nExpanding This example is intentionally kept as simplified as possible, while still demonstrating complete behaviors. In a larger project, there would likely be a greater number of behaviors, as well as more complex conditions for deciding which one to apply.\nRelated recipes  Top-down character Spritesheet animation Controlling animation states Path following Chasing the player  "},{"uri":"http://kidscancode.org/godot_recipes/animation/animation_state_machine/","title":"Controlling animation states","tags":[],"description":"","content":"Problem A common situation: you have a large number of animations, and it\u0026rsquo;s becoming difficult to manage transitions between them. Your code has become full of if statements, and every time you change something, it all breaks.\nSolution Use an AnimationTree to create an animation state machine. This will allow us to organize our animations and most importantly, control the transitions between them.\nGetting started For this demo, we\u0026rsquo;ll be using the excellent \u0026ldquo;Adventurer\u0026rdquo; sprite by Elthen. You can get this and lots of other great art at https://elthen.itch.io/.\n![alt](/godot_recipes/img/Adventurer Sprite Sheet v1.1.png)\nWe\u0026rsquo;ll also assume you\u0026rsquo;ve already set up the character\u0026rsquo;s animations using AnimationPlayer. Using the above spritesheet, we have the following animations: \u0026ldquo;idle\u0026rdquo;, \u0026ldquo;run\u0026rdquo;, \u0026ldquo;attack1\u0026rdquo;, \u0026ldquo;attack2\u0026rdquo;, \u0026ldquo;hurt\u0026rdquo;, and \u0026ldquo;die\u0026rdquo;.\nAnimationTree Add an AnimationTree node to the scene. In its Tree Root property, choose \u0026ldquo;New AnimationNodeStateMachine\u0026rdquo;.\nAn AnimationTree is a node that controls animations created in AnimationPlayer. To let it access the existing animations, click \u0026ldquo;Assign\u0026rdquo; in the Anim Player property and select your animation node.\nNow we can begin to set up our state machine in the AnimationTree panel:\nNote the warning. Set the Active property to \u0026ldquo;On\u0026rdquo; in the Inspector.\nRight-click and choose \u0026ldquo;Add Animation\u0026rdquo;. Choose \u0026ldquo;idle\u0026rdquo;, and you\u0026rsquo;ll see a small box representing that animation. Press its \u0026ldquo;Play\u0026rdquo; button and you should see the animation play. Do the same to add boxes for the other animations.\nNow we can add connections. Click the \u0026ldquo;Connect nodes\u0026rdquo; button and drag between nodes to connect them.\nWhen you select an animation, the tree will follow the connected path from the current node to the destination. However, in the configuration above, if you play \u0026ldquo;attack2\u0026rdquo; you won\u0026rsquo;t see \u0026ldquo;attack1\u0026rdquo; along the way. That\u0026rsquo;s because the default \u0026ldquo;switch mode\u0026rdquo; for a connection is \u0026ldquo;Immediate\u0026rdquo;. Click the \u0026ldquo;Move/select\u0026rdquo; button and then click on the connection from \u0026ldquo;attack1\u0026rdquo; to \u0026ldquo;attack2\u0026rdquo;. In the Inspector, change Switch Mode to \u0026ldquo;AtEnd\u0026rdquo;. Do the same with \u0026ldquo;attack2\u0026rdquo; to \u0026ldquo;idle\u0026rdquo;. The connection icon changes from  to .\nNow, with \u0026ldquo;idle\u0026rdquo; playing, if you click \u0026ldquo;attack2\u0026rdquo;, you\u0026rsquo;ll see the two attacks play in sequence.\nBut now the animation stops on \u0026ldquo;attack2\u0026rdquo;. On its connection, set the Auto Advance property to \u0026ldquo;On\u0026rdquo;. This will make the tree go back to \u0026ldquo;idle\u0026rdquo; after playing both animations. Note that the connection icon turns green to show this.\nCalling states in code Here is the full tree for all of the animations:\nWe\u0026rsquo;ve set the \u0026ldquo;die\u0026rdquo; node as the end, so when that one is reached, there will be no further animation. In the bottom-left, we have a double-attack sequence.\nNow let\u0026rsquo;s set up the character to use these animations in a script.\nextends KinematicBody2D\rvar state_machine\rvar run_speed = 80\rvar attacks = [\u0026#34;attack1\u0026#34;, \u0026#34;attack2\u0026#34;]\rvar velocity = Vector2.ZERO\rfunc _ready():\rstate_machine = $AnimationTree.get(\u0026#34;parameters/playback\u0026#34;)\rstate_machine holds a reference to the state machine, which is an AnimationNodeStateMachinePlayback. To call a specific animation, you use travel(), which will follow the connections to the given animation.\nfunc _physics_process(delta):\rget_input()\rvelocity = move_and_slide(velocity)\rfunc hurt():\rstate_machine.travel(\u0026#34;hurt\u0026#34;)\rfunc die():\rstate_machine.travel(\u0026#34;die\u0026#34;)\rset_physics_process(false)\rHere we have examples of functions we would call if the player is hurt or killed. For the other animations (running, attacking, etc.), we\u0026rsquo;ll need to combine them with our input and movement code. velocity determines whether we should be showing \u0026ldquo;run\u0026rdquo; or \u0026ldquo;idle\u0026rdquo;.\nfunc get_input():\rvar current = state_machine.get_current_node()\rvelocity = Vector2.ZERO\rif Input.is_action_just_pressed(\u0026#34;big_attack\u0026#34;):\rstate_machine.travel(\u0026#34;attack1 2\u0026#34;)\rreturn\rif Input.is_action_just_pressed(\u0026#34;attack\u0026#34;):\rstate_machine.travel(attacks[randi() % 2])\rreturn\rif Input.is_action_pressed(\u0026#34;move_right\u0026#34;):\rvelocity.x += 1\r$Sprite.scale.x = 1\rif Input.is_action_pressed(\u0026#34;move_left\u0026#34;):\rvelocity.x -= 1\r$Sprite.scale.x = -1\rif Input.is_action_pressed(\u0026#34;move_up\u0026#34;):\rvelocity.y -= 1\rif Input.is_action_pressed(\u0026#34;move_down\u0026#34;):\rvelocity.y += 1\rvelocity = velocity.normalized() * run_speed\rif velocity.length() != 0:\rstate_machine.travel(\u0026#34;run\u0026#34;)\rif velocity.length() == 0:\rstate_machine.travel(\u0026#34;idle\u0026#34;)\rNote that we\u0026rsquo;re using return after traveling to the attack animations. This is so that we won\u0026rsquo;t instead travel to the \u0026ldquo;run\u0026rdquo; or \u0026ldquo;idle\u0026rdquo; animations further down in the function.\nRelated recipes  Spritesheet animation Top-down character  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/ai/homing_missile/","title":"Homing missile","tags":[],"description":"","content":"Problem You need a \u0026ldquo;homing missile\u0026rdquo; - a projectile that will seek a moving target.\nSolution For this example, we\u0026rsquo;ll use an Area2D node for the projectile. Areas are typically good choices for bullets because we need to detect when they contact something. If you also need a bullet that bounces/ricochets, a PhysicsBody type node might be a better choice.\nThe node setup and behavior of the missile is the same you would use for a \u0026ldquo;dumb\u0026rdquo; bullet. If you\u0026rsquo;re creating many bullet types, you can use inheritance to base all your projectiles on the same core setup.\nThe nodes we\u0026rsquo;ll use:\n- Area2D (\u0026#34;Missile\u0026#34;)\r- Sprite\r- CollisionShape2D\r- Timer (\u0026#34;Lifetime\u0026#34;)\rFor the texture, you can use any image you like. Here\u0026rsquo;s an example one:\nSet up the nodes and configure the sprite\u0026rsquo;s texture and the collision shape. Make sure to rotate the Sprite node by 90° so that it\u0026rsquo;s pointing to the right, ensuring it matches the parent\u0026rsquo;s \u0026ldquo;forward\u0026rdquo; direction.\nAdd a script and connect the Area2D's body_entered signal and the Timer's timeout signal.\nHere\u0026rsquo;s the starting script:\nextends Area2D\rexport var speed = 350\rvar velocity = Vector2.ZERO\rvar acceleration = Vector2.ZERO\rfunc start(_transform):\rglobal_transform = _transform\rvelocity = transform.x * speed\rfunc _physics_process(delta):\rvelocity += acceleration * delta\rvelocity = velocity.clamped(speed)\rrotation = velocity.angle()\rposition += velocity * delta\rfunc _on_Missile_body_entered(body):\rqueue_free()\rfunc _on_Lifetime_timeout():\rqueue_free()\rThis creates a \u0026ldquo;dumb\u0026rdquo; bullet that travels in a straight line when fired. To use this projectile, instance it and call its start() method with the desired Transform2D to set its position and direction.\nSee the related recipes section below for more information.\nTo change the behavior to seek a target, we\u0026rsquo;ll use the acceleration. However, we don\u0026rsquo;t want the missile to \u0026ldquo;turn on a dime\u0026rdquo;, so we\u0026rsquo;ll add a variable to control its \u0026ldquo;steering\u0026rdquo; force. This will give the missile a turning radius that can be adjusted for different behavior. We also need a target variable so that the missile knows what to chase. We\u0026rsquo;ll set that in start() as well:\nexport var steer_force = 50.0\rvar target = null\rfunc start(_transform, _target):\r# add this line:\r target = _target\rTo change the missile\u0026rsquo;s direction to move toward the target, it needs to accelerate in that direction (acceleration is change in velocity). The missile \u0026ldquo;wants\u0026rdquo; to move straight towards the target, but its current velocity is pointing in a different direction. Using a little vector math, we can find that difference:\nThe green arrow represents the needed change in velocity (i.e. acceleration). However, if we turn instantly, that will look unnatural, so the \u0026ldquo;steering\u0026rdquo; vector\u0026rsquo;s length needs to be limited. This is the purpose of the steer_force variable.\nThis is the function to calculate that acceleration. Note that if there\u0026rsquo;s no target, there will be no steering, so the missile remains traveling in a straight line.\nfunc seek():\rvar steer = Vector2.ZERO\rif target:\rvar desired = (target.position - position).normalized() * speed\rsteer = (desired - velocity).normalized() * steer_force\rreturn steer\rFinally, the resulting steer force must be applied in _physics_process():\nfunc _physics_process(delta):\racceleration += seek()\rvelocity += acceleration * delta\rvelocity = velocity.clamped(speed)\rrotation = velocity.angle()\rposition += velocity * delta\rHere\u0026rsquo;s an example of the results, with a little extra visual flair such as particle smoke and explosions:\n\nHere\u0026rsquo;s the full script, including the above effects. See related recipes for details.\nextends Area2D\rexport var speed = 350\rexport var steer_force = 50.0\rvar velocity = Vector2.ZERO\rvar acceleration = Vector2.ZERO\rvar target = null\rfunc start(_transform, _target):\rglobal_transform = _transform\rrotation += rand_range(-0.09, 0.09)\rvelocity = transform.x * speed\rtarget = _target\rfunc seek():\rvar steer = Vector2.ZERO\rif target:\rvar desired = (target.position - position).normalized() * speed\rsteer = (desired - velocity).normalized() * steer_force\rreturn steer\rfunc _physics_process(delta):\racceleration += seek()\rvelocity += acceleration * delta\rvelocity = velocity.clamped(speed)\rrotation = velocity.angle()\rposition += velocity * delta\rfunc _on_Missile_body_entered(body):\rexplode()\rfunc _on_Lifetime_timeout():\rexplode()\rfunc explode():\r$Particles2D.emitting = false\rset_physics_process(false)\r$AnimationPlayer.play(\u0026#34;explode\u0026#34;)\ryield($AnimationPlayer, \u0026#34;animation_finished\u0026#34;)\rqueue_free()\r\rDownload the project file here: homing_missiles.zip\n\rRelated recipes  Spritesheet animation Top-down character  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/3d/kinematic_body/","title":"KinematicBody: Movement","tags":[],"description":"","content":"Problem You need a player-controlled 3D kinematic body.\nSolution For this recipe, we\u0026rsquo;ll be using this adorable tank model:\nYou can grab this model on Itch.io: https://gtibo.itch.io/mini-tank or use any other model you\u0026rsquo;d like. We won\u0026rsquo;t be doing anything that\u0026rsquo;s tank-specific here.\nWe can add the model to the scene, but we\u0026rsquo;ll need a couple of additional nodes:\nFor the collision shape, we\u0026rsquo;re just going to use a BoxShape aligned and sized with the tank\u0026rsquo;s treads. CamPos is a Position3D we\u0026rsquo;ll use to place our following camera. It\u0026rsquo;s placed behind and above the tank, angled down.\nWe\u0026rsquo;ve also rotated the individual MeshInstance nodes 180 degrees around the Y axis. This is because they were modeled facing towards +Z, but -Z is the forward direction in Godot, and we don\u0026rsquo;t want our tank to look like it\u0026rsquo;s backwards.\nBefore we add a script, open the \u0026ldquo;Project Settings\u0026rdquo; and add the following inputs on the \u0026ldquo;Input Map\u0026rdquo; tab:\n   Input Action Key     forward W   back S   right D   left A    Now let\u0026rsquo;s add a script, starting with the required variables:\nextends KinematicBody\rexport var gravity = Vector3.DOWN * 10\rexport var speed = 4\rexport var rot_speed = 0.85\rvar velocity = Vector3.ZERO\rspeed is the tank\u0026rsquo;s movement speed (forward and back), while rot_speed defines how fast it can turn.\nDeclaring properties with export makes it easy to adjust them in the Inspector.\n\rUsing the KinematicBody.move_and_slide() method makes our movement code quite simple:\nfunc _physics_process(delta):\rvelocity += gravity * delta\rget_input(delta)\rvelocity = move_and_slide(velocity, Vector3.UP)\rWith this code, we add the downward acceleration of gravity to the current velocity, get the user\u0026rsquo;s input (more about that below), and call move_and_slide(). We pass the velocity and a direction vector of (0, 1) for the up_direction parameter.\nDon\u0026rsquo;t forget to capture the returned velocity vector from move_and_slide(). If you don\u0026rsquo;t do this, you won\u0026rsquo;t get the benefits of the movement being slid along the surface.\n\rNext we need to define get_input(), where we\u0026rsquo;ll process and apply the input actions:\nfunc get_input(delta):\rvar vy = velocity.y\rvelocity = Vector3.ZERO\rif Input.is_action_pressed(\u0026#34;forward\u0026#34;):\rvelocity += -transform.basis.z * speed\rif Input.is_action_pressed(\u0026#34;back\u0026#34;):\rvelocity += transform.basis.z * speed\rif Input.is_action_pressed(\u0026#34;right\u0026#34;):\rrotate_y(-rot_speed * delta)\rif Input.is_action_pressed(\u0026#34;left\u0026#34;):\rrotate_y(rot_speed * delta)\rvelocity.y = vy\rLet\u0026rsquo;s examine this more closely. Player input should affect horizontal movement: forward/back along the ground, and rotation around the tank\u0026rsquo;s center. Movement in the Y direction should only be affected by gravity, which means we don\u0026rsquo;t want to set it to 0 every frame. This is why we\u0026rsquo;re using the vy variable to temporarily hold that value while we assign a new velocity vector for the horizontal movement, then add it back in at the end.\nFor the forward and back movement, we\u0026rsquo;re using transform.basis.z so that we\u0026rsquo;ll move in our body\u0026rsquo;s local forward direction.\nHere\u0026rsquo;s the tank in action. We\u0026rsquo;ve made a test scene with a StaticBody plane for the ground and an InterpolatedCamera with its Target set to the tank\u0026rsquo;s CamPos.\n\nWrapping up This is the basis of movement for any kind of kinematic character. From here you can add jumping, shooting, AI behavior, etc. See the related recipes for examples that build on this recipe.\nDownload the project file here: floating_text.zip\n\r--\rRelated recipes  Intro to 3D Input Actions  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_04/","title":"Menus","tags":[],"description":"","content":"Now that we\u0026rsquo;ve got the basic gameplay, it\u0026rsquo;s time to start working on the UI. We\u0026rsquo;re going to need menu screens for the title, settings, and game over.\nMenu screens The three screens will share a common layout and some functionality, so we\u0026rsquo;ll start with a base scene they can all inherit from. In the new scene, start with a CanvasLayer and name it BaseScreen. Save this scene in the \u0026ldquo;UI\u0026rdquo; folder.\n CanvasLayer (\u0026ldquo;BaseScreen\u0026rdquo;)  MarginContainer  VBoxContainer  Label HBoxContainer (\u0026ldquo;Buttons\u0026rdquo;)     Tween    The MarginContainer will ensure that none of our UI elements get too close to the edge of the screen. Set all four of its Custom Constants properties to 20.\nNext is a VBoxContainer to organize the main elements. Set its Custom Constants/Separation to 150.\nThe Label node displays the screen\u0026rsquo;s title. Put \u0026ldquo;Title\u0026rdquo; in its Text field and load the same font resource we used for the circles.\nFinally, add an HBoxContainer named \u0026ldquo;Buttons\u0026rdquo; which will hold the buttons we add to the screens. Set its Separation to 75. Then duplicate the node so that we have another row of buttons.\nThe screen should start offscreen, so set the Offset on the root node to (500, 0). Then add a script to the scene:\nextends CanvasLayer\ronready var tween = $Tween\rfunc appear():\rtween.interpolate_property(self, \u0026#34;offset:x\u0026#34;, 500, 0,\r0.5, Tween.TRANS_BACK, Tween.EASE_IN_OUT)\rtween.start()\rfunc disappear():\rtween.interpolate_property(self, \u0026#34;offset:x\u0026#34;, 0, 500,\r0.4, Tween.TRANS_BACK, Tween.EASE_IN_OUT)\rtween.start()\rThis script sets up the animations we can call to make the screen appear and disappear.\nNow we can make our three inherited scenes. For each, name the root node, change the Label text, and add TextureButtons to the \u0026ldquo;Buttons\u0026rdquo; containers. Use the images from the assets folder for each button\u0026rsquo;s Normal texture. Name each button for its function (\u0026ldquo;Play\u0026rdquo;, \u0026ldquo;Settings\u0026rdquo;, etc.) and add it to the group \u0026ldquo;buttons\u0026rdquo;.\nHere is what the three scenes should look like, using the indicated button names:\nMake one more scene with a Node root named \u0026ldquo;Screens\u0026rdquo; and instance the three screens in it. Add the following script, which will handle scene transitions and state.\nextends Node\rsignal start_game\rvar current_screen = null\rfunc _ready():\rregister_buttons()\rchange_screen($TitleScreen)\rfunc register_buttons():\rvar buttons = get_tree().get_nodes_in_group(\u0026#34;buttons\u0026#34;)\rfor button in buttons:\rbutton.connect(\u0026#34;pressed\u0026#34;, self, \u0026#34;_on_button_pressed\u0026#34;, [button.name])\rfunc _on_button_pressed(name):\rmatch name:\r\u0026#34;Home\u0026#34;:\rchange_screen($TitleScreen)\r\u0026#34;Play\u0026#34;:\rchange_screen(null)\ryield(get_tree().create_timer(0.5), \u0026#34;timeout\u0026#34;)\remit_signal(\u0026#34;start_game\u0026#34;)\r\u0026#34;Settings\u0026#34;:\rchange_screen($SettingsScreen)\rfunc change_screen(new_screen):\rif current_screen:\rcurrent_screen.disappear()\ryield(current_screen.tween, \u0026#34;tween_completed\u0026#34;)\rcurrent_screen = new_screen\rif new_screen:\rcurrent_screen.appear()\ryield(current_screen.tween, \u0026#34;tween_completed\u0026#34;)\rfunc game_over():\rchange_screen($GameOverScreen)\rThis script connects up all our buttons by linking the pressed signal and passing along the button\u0026rsquo;s name as a parameter. This lets our _on_button_pressed() method decide what each button should do.\nThe change_screen() method handles transition to the selected screen, including the null option for when we don\u0026rsquo;t want to display a screen at all.\nRun it to test out the screen transitions:\nInstance this scene in Main, then connect its start_game signal to the new_game() function in main. Don\u0026rsquo;t forget to remove new_game() from the _ready(). Try running the game and you should be able to start. The last part will be to connect up the game over condition.\nIn the Jumper, add a signal called died and emit that signal in the visibility notifier\u0026rsquo;s method.\nAdd this to the new_game() function:\nplayer.connect(\u0026#34;died\u0026#34;, self, \u0026#34;_on_Jumper_died\u0026#34;)\rThen add this new function, which will ensure all the circles are removed when the player dies.\nfunc _on_Jumper_died():\rget_tree().call_group(\u0026#34;circles\u0026#34;, \u0026#34;implode\u0026#34;)\r$Screens.game_over()\rOur menu screens are basic and no-frills, but they\u0026rsquo;re functional. In the next part, we\u0026rsquo;ll continue the UI work with our score counter and other in-game displays.\n Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "},{"uri":"http://kidscancode.org/godot_recipes/physics/rigidbody_drag_drop/","title":"RigidBody2D: Drag and Drop","tags":[],"description":"","content":"Problem You want to pick up and move rigid bodies with the mouse.\nSolution Working with rigid bodies can be tricky. Godot\u0026rsquo;s physics engine controls their movements, and interfering with that can often lead to unexpected results. The key is to make use of the body\u0026rsquo;s mode property. This applies equally well in 2D or 3D.\nBody setup We\u0026rsquo;ll start with our rigid body object, adding a Sprite and CollisionShape2D. You can also add a PhysicsMaterial if you want to set Bounce and Friction properties.\nPlace the body in a group called \u0026ldquo;pickable\u0026rdquo;. We\u0026rsquo;ll use this to allow for multiple instances of the pickable object in the main scene. Attach a script and connect the body\u0026rsquo;s _input_event signal.\nextends RigidBody2D\rsignal clicked\rvar held = false\rfunc _input_event(viewport, event, shape_idx):\rif event is InputEventMouseButton:\rif event.button_index == BUTTON_LEFT and event.pressed:\remit_signal(\u0026#34;clicked\u0026#34;, self)\rWe\u0026rsquo;ll emit a signal when a mouse click is detected. Since there can be many bodies, we\u0026rsquo;ll let the main scene manage whether a body can be dragged or if there\u0026rsquo;s already one in the held state.\nfunc _physics_process(delta):\rif held:\rglobal_transform.origin = get_global_mouse_position()\rIf the body is being dragged, we update its position to follow the mouse.\nfunc pickup():\rif held:\rreturn\rmode = RigidBody2D.MODE_STATIC\rheld = true\rfunc drop(impulse=Vector2.ZERO):\rif held:\rmode = RigidBody2D.MODE_RIGID\rapply_central_impulse(impulse)\rheld = false\rFinally, these are the two functions to call when the body is picked up and dropped. Changing the mode to MODE_STATIC removes the body from physics engine processing. Note that other objects can still collide with it. If you don\u0026rsquo;t want that, you can disable the collision_layer and/or collision_mask here as well. Just remember to re-enable them when dropping.\nIn the drop function, when we change back to MODE_RIGID, the body will be asleep. A sleeping body can be awoken by applying an impulse to it (even a zero magnitude impulse is fine). However, by passing in an optional impulse value, we can \u0026ldquo;throw\u0026rdquo; the object on release.\nMain scene Create a main scene with some static body obstacles or a TileMap and instance a few copies of the pickable body.\nHere\u0026rsquo;s the script for the main scene:\nextends Node2D\rvar held_object = null\rfunc _ready():\rfor node in get_tree().get_nodes_in_group(\u0026#34;pickable\u0026#34;):\rnode.connect(\u0026#34;clicked\u0026#34;, self, \u0026#34;_on_pickable_clicked\u0026#34;)\rfunc _on_pickable_clicked(object):\rif !held_object:\rheld_object = object\rheld_object.pickup()\rHere\u0026rsquo;s where we connect up the signal from the rigid body instances. The connected function sets held_object so that we know something is currently being dragged, and calls the body\u0026rsquo;s pickup() method.\nfunc _unhandled_input(event):\rif event is InputEventMouseButton and event.button_index == BUTTON_LEFT:\rif held_object and !event.pressed:\rheld_object.drop(Input.get_last_mouse_speed())\rheld_object = null\rLastly, when the mouse is released during dragging, we can perform the reverse actions. Note the use of get_last_mouse_speed() - be careful with this! You may find yourself launching the rigid bodies at high speeds, especially if the bodies have low mass values. It\u0026rsquo;s probably a good idea to clamp() this to a reasonable value. Experiment to find out what works for you.\n\nDownload the project file here: rigidbody_drag_and_drop.zip\n\rRelated recipes  Using Rigid Bodies Kinematic to Rigid Body Interaction  "},{"uri":"http://kidscancode.org/godot_recipes/basics/file_io/","title":"Saving/loading data","tags":[],"description":"","content":"Problem You need to save and load local data between game sessions.\nSolution Godot\u0026rsquo;s file I/O (input/output) system is based around the File object. You open a file by creating a new File object and calling open().\nvar file = File.new()\rfile.open(\u0026#34;user://myfile.name\u0026#34;, File.READ)\r\rUser data should only be stored in the user:// path. While res:// can be used when running from the editor, when your project is exported, the res:// path becomes read-only.\n\rThe second argument after the file path is the \u0026ldquo;Mode Flag\u0026rdquo;, which can be one of the following:\n File.READ - Open for reading. File.WRITE - Open for writing. Creates the file if it doesn\u0026rsquo;t exist and truncates if it does. File.READ_WRITE - Open for reading and writing. Doesn\u0026rsquo;t truncate the file. File.WRITE_READ - Open for reading/writing. Creates the file if it doesn\u0026rsquo;t exist and truncates if it does.  Storing data You can save data using its specific data type (store_float(), store_string(), etc.), or using the generic store_var(), which will use Godot\u0026rsquo;s built-in serialization to encode your data, including complex data like objects (more on this later).\nLet\u0026rsquo;s start with a small example: saving the player\u0026rsquo;s high score. We can write a function that we can call whenever the score needs to be saved:\nvar score_file = \u0026#34;user://score.save\u0026#34;\rfunc save_score():\rvar file = File.new()\rfile.open(score_file, File.WRITE)\rfile.store_var(highscore)\rfile.close()\r\rDon\u0026rsquo;t forget to close() the file when you\u0026rsquo;re finished accessing it.\n\rWe\u0026rsquo;re saving our score, but we need to be able to load it when the game starts:\nfunc load_score():\rvar file = File.new()\rif file.file_exists(score_file):\rfile.open(score_file, File.READ)\rhighscore = file.get_var()\rfile.close()\relse:\rhighscore = 0\rDon\u0026rsquo;t forget to check for the file\u0026rsquo;s existence before attempting to read from it - it may not be there! If that\u0026rsquo;s the case, you can use a default value.\nSaving objects You can save more than just basic data types. Using store_var()'s full_objects parameter you can save any object, including custom ones. For example, let\u0026rsquo;s say you have a custom object defined:\nextends Node\rclass_name CustomObject\rvar a = 10\rfunc say_hello():\rprint(\u0026#34;hello\u0026#34;)\rAnd then your save/load code would look like this:\nvar score_file = \u0026#34;user://score.save\u0026#34;\rvar c = CustomObject.new()\rfunc save_to_file():\rvar file = File.new()\rfile.open(score_file, File.WRITE)\rfile.store_var(c, true)\rfile.close()\rfunc load_from_file():\rvar file = File.new()\rif file.file_exists(score_file):\rfile.open(score_file, File.READ)\rc = file.get_var(true)\rfile.close()\rvar c\rfunc _ready():\rload_from_file()\rc.say_hello()\rWhat about JSON? I see it very often (and some readers may be asking it already): \u0026ldquo;What if I want to use JSON to save my data?\u0026rdquo; This is my response:\n Don\u0026rsquo;t use JSON for your save files!\n While Godot has JSON support, saving game data is not what JSON is for. JSON is a data interchange format - its purpose is to allow systems using different data formats and/or languages to exchange data between each other.\nThis means JSON has limitations that are negatives for you when it comes to saving your game data. JSON doesn\u0026rsquo;t support many data types (no int vs. float, for example) so you have to do a lot of converting and validating to try and save/load your data. It\u0026rsquo;s cumbersome and time consuming.\nDon\u0026rsquo;t waste your time. Using Godot\u0026rsquo;s built-in serialization, you can store native Godot objects - Nodes, Resources, even Scenes - without any effort, which means less code and fewer errors.\nWrapping up This article just scratches the surface of what you can do with the File object. For the full list of available File methods, see the File documentation.\n"},{"uri":"http://kidscancode.org/godot_recipes/2d/autotile_intro/","title":"TileMap: using autotile","tags":[],"description":"","content":"Problem You are using a TileMap, and want to use autotiling to more quickly draw your levels.\nSolution For this demo, we\u0026rsquo;ll be using the following tileset:\nThese tiles are from Kenney\u0026rsquo;s \u0026ldquo;Topdown Shooter\u0026rdquo; art pack, which you can find here:https://kenney.nl/assets/topdown-shooter\n\rCreating a map from these tiles, if you were adding them one-by-one, would be a tedious process. You would be constantly changing between tiles to line up corners, intersections, and endpoints.\nUsing autotiling, you to draw the walls freely, and the autotiling algorithm selects the correct tiles to make everything line up.\nHere\u0026rsquo;s an example:\nHow autotiling works The tiles we\u0026rsquo;re using are designed for a 3x3 (minimal) tiling. Consider a single tile divided into a 3x3 grid:\nWe can mark the \u0026ldquo;active\u0026rdquo; portions of the tile (i.e. the parts that are not the wall):\nIf we were to do this with each tile, the computer can then make sure that whatever tile is placed adjacent to this one will match up.\nIn a 3x3 grid there are 512 possible combinations (2^9). We can discard most of these, as they don\u0026rsquo;t make sense for making continuous walls. It turns out, to properly cover the wall combinations, you need 48 tiles, which we have in our tileset. We\u0026rsquo;ll be ignoring the 7 tiles in the bottom-right (the ones with the white background).\nMaking the TileSet In your TileMap\u0026rsquo;s Tile Set property, select \u0026ldquo;New TileSet\u0026rdquo; and click on it to open. You\u0026rsquo;ll see the TileSet editor panel open:\nClick the ⊞ button to add a texture, choosing the tile set from above. Then click \u0026ldquo;New Autotile\u0026rdquo; and drag to select the whole image. You will probably need to enable snap and adjust the options. The tiles in this tilest are 64x64 and have a 10 pixel separation. If you\u0026rsquo;re using your own art, you\u0026rsquo;ll need to enter your own values.\nNow that you have selected the set of tiles to make up the autotile group, it\u0026rsquo;s time to set the bitmasks. Click the \u0026ldquo;Bitmask\u0026rdquo; button at the top and start clicking in the tiles. The masked area will appear red. When you\u0026rsquo;re done it should look like this:\nRemember, we\u0026rsquo;re not using the tiles in the lower-right corner.\nLastly, click the \u0026ldquo;Icon\u0026rdquo; button and select a tile you\u0026rsquo;d like to use as the icon for the autotile group. This is the tile that will show under the cursor as you\u0026rsquo;re drawing.\nSwitch back to the TileMap, and you should be able to start drawing. If something is wrong, check your bitmasks and make sure you didn\u0026rsquo;t miss a square on any of the tiles. Compare with the picture above.\nFull TileSet You can also add collision, navigation, or occlusion to your autotile set. If you download the example project below, you\u0026rsquo;ll find a complete tileset with polygons defined on all the tiles.\nDownload the project file here: autotile_intro.zip\n\r"},{"uri":"http://kidscancode.org/godot_recipes/input/","title":"Input","tags":[],"description":"","content":" Input Handling input - from keyboard and mouse to game controllers and touchscreens.\nIn this section: \rInput Actions\r\r\rMouse Input\r\r\rAdding Input Actions in code\r\r\rCapturing the Mouse\r\r\rCustomizing the Mouse Cursor\r\r\rMouse: Drag-select multiple units\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/animation/","title":"Animation","tags":[],"description":"","content":" Animation Using Godot\u0026rsquo;s animation system.\nIn this section: \rSpritesheet animation\r\r\rMelee attacks\r\r\rControlling animation states\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/g101/gdscript/","title":"GDScript","tags":[],"description":"","content":" GDScript GDScript is Godot\u0026rsquo;s built-in scripting language. Its syntax is based on Python, so if you\u0026rsquo;re familiar with that language, you\u0026rsquo;ll feel right at home. In this chapter, we\u0026rsquo;ll introduce the language and get you up to speed with how it works.\nIn this section: \r"},{"uri":"http://kidscancode.org/godot_recipes/g101/3d/","title":"Intro to 3D","tags":[],"description":"","content":" Intro to 3D A gentle introduction to the 3D side of Godot development.\nIn this section: \rThe 3D Editor\r\r\rImporting 3D Objects\r\r\rCreating a 3D Character\r\r\rUsing Areas\r\r\rEdge Detection \u0026amp; Mouse Capture\r\r\rUsing CSG\r\r\rFirst-person Character\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/ui/","title":"UI","tags":[],"description":"","content":" UI Building user interfaces.\nIn this section: \rLabels\r\r\rContainers\r\r\rCooldown Button\r\r\rHeart Containers: 3 Ways\r\r\rDisplaying debug data\r\r\rObject Healthbars\r\r\rFloating combat text\r\r\rMinimap/radar\r\r\rRadial Popup Menu\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/g101/3d/101_3d_05/","title":"Edge Detection &amp; Mouse Capture","tags":[],"description":"","content":"In the last part, we learned how to use Area nodes to detect contact between objects, making coin, bullet, and spike objects for our character to interact with. In this part, we\u0026rsquo;ll look at a few small improvements: capturing the mouse, animating the coins, and detecting edges so our character doesn\u0026rsquo;t fall.\nCapturing the Mouse One issue with our mouse-based controls is that as you move the mouse from side to side, it eventually moves out of the game window and hits the edge of your screen. To solve this, we need to \u0026ldquo;capture\u0026rdquo; the mouse. However, if we do that, we won\u0026rsquo;t be able to close the window or anything else - our mouse will be gone! We\u0026rsquo;ll need a way to release the mouse again.\nFirst, to capture the mouse, add the following to the main scene:\nfunc _ready():\rInput.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)\rThis takes care of the first part: the mouse will now be captured by our game window. Now we need it to be released when we press the \u0026ldquo;Escape\u0026rdquo; key. Let\u0026rsquo;s put this in the main script as well:\nfunc _input(event):\rif event.is_action_pressed(\u0026#34;ui_cancel\u0026#34;):\rInput.set_mouse_mode(Input.MOUSE_MODE_VISIBLE) Run the game and try it out.\nLet\u0026rsquo;s also ignore mouse motion when it\u0026rsquo;s not captured. In the character script, change this line in _unhandled_input():\nif event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED: Now we have another issue: once you\u0026rsquo;ve pressed \u0026ldquo;Escape\u0026rdquo;, we don\u0026rsquo;t have a way to go back to being captured. Let\u0026rsquo;s do that if we click on the window:\nfunc _input(event):\rif event.is_action_pressed(\u0026#34;ui_cancel\u0026#34;):\rInput.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)\rif event.is_action_pressed(\u0026#34;shoot\u0026#34;):\rif Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:\rInput.set_mouse_mode(Input.MOUSE_MODE_CAPTURED) This works OK, but when we click to recapture the mouse, we also fire a bullet, since the mouse click does that as well. We can solve this by marking the input as \u0026ldquo;handled\u0026rdquo;, so that Godot won\u0026rsquo;t send it on to any other nodes:\nif event.is_action_pressed(\u0026#34;shoot\u0026#34;):\rif Input.get_mouse_mode() == Input.MOUSE_MODE_VISIBLE:\rInput.set_mouse_mode(Input.MOUSE_MODE_CAPTURED)\rget_tree().set_input_as_handled() Now that first click capturing the mouse won\u0026rsquo;t also fire a bullet.\nAnimated Coins Now we\u0026rsquo;re going to make the coins from the last part a bit more dynamic and appealing. Open Coin.tscn and add an AnimationPlayer to the scene.\nClick the \u0026ldquo;Animation\u0026rdquo; button and select \u0026ldquo;New\u0026rdquo; to create a new animation called \u0026ldquo;bounce\u0026rdquo;. A duration of 1 second is fine, but make sure to enable looping.\nWe\u0026rsquo;re going to animate two properties of the coin: position (on the Y axis, up and down) and rotation. Ensure the scrubber is at time 0 and add a keyframe for both Translation and Rotation Degrees.\nMove the scrubber to the 0.5 second mark, change the Y component of the translation to 0.3, and click the keyframe button. Then move the scrubber all the way to 1.0 and keyframe the rotation at 180 degrees in Y.\nPress \u0026ldquo;Play\u0026rdquo; to see how your animation looks. Try clicking on the individual translation keyframes and adjusting the Easing value.\nFinally, click the \u0026ldquo;Autoplay\u0026rdquo; button to ensure the animation will automatically start when the game is run.\nEdge Detection Finally, let\u0026rsquo;s see if we can keep our character from running off a cliff and falling to its death.\nStart by adding a RayCast node to the player. It appears as a thin blue line. By default, its Cast To property is set to (0, -1, 0), which is pointing down. This is good, but we also need to move it forward so that it\u0026rsquo;s pointing down at the front of the character:\nAlso, make sure to check the Enabled property, or the RayCast won\u0026rsquo;t work.\nNow, in our character script, we need to check that when moving forward, if the RayCast is colliding, it\u0026rsquo;s safe to move.\nRight now, we have the following:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;):\rvelocity += -transform.basis.z * speed Let\u0026rsquo;s try only adding to the velocity if the ray is colliding:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;) and $RayCast.is_colliding():\rvelocity += -transform.basis.z * speed Try it out. When you run up to an edge, you\u0026rsquo;ll stop. But wait - have you tried jumping forward? Our forward movement is now canceled when we\u0026rsquo;re in the air! Back to the drawing board.\nNow we need to also check if we\u0026rsquo;re on the ground, so that if we walk forward and the ray stops colliding, we do nothing. Otherwise, we move as normal:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;):\rif is_on_floor() and !$RayCast.is_colliding():\rpass\relse:\rvelocity += -transform.basis.z * speed You may be wondering why I wrote it this way. Keep reading, there\u0026rsquo;s a reason!\n\rThis works, but something feels off about the code. We have a conditional statement that does nothing. Surely we can simplify this. We can, with a little bit of Boolean Algebra.\nOur conditional statement is essentially this:\nif A:\rdo_nothing\relse:\rdo_something Which is equivalent to:\nif not A:\rdo_something So what we really need to do is convert our conditional statement to:\nif !(is_on_floor() and !$RayCast.is_colliding()) This works, but it\u0026rsquo;s hard to read. Can it be simplified? It can, using a Boolean Algebra method called \u0026ldquo;De Morgan\u0026rsquo;s Law\u0026rdquo;. De Morgan\u0026rsquo;s Law states that\nnot (A and B) = not A or not B So we can apply that here and we get the following:\nif Input.is_action_pressed(\u0026#34;move_forward\u0026#34;):\rif !is_on_floor() or $RayCast.is_colliding():\rvelocity += -transform.basis.z * speed In English:\n\u0026ldquo;If we\u0026rsquo;re not on the floor or there is floor in front of us, move forward.\u0026rdquo;\nThis is a very simplistic implementation - you can still walk sideways or backwards off the edge, for example. Feel free to take this idea and run with it to make improvements. Some games let you fall if you move off the edge slowly, but stop you if you\u0026rsquo;re moving fast.\nWrapping Up In this tutorial, we added a few small improvements to the game. Capturing the mouse is useful in many types of 3D games (first-person, for example), and RayCasts have a wide range of uses - we only touched on one here. The animation we added was very small, but a good start - we\u0026rsquo;ll be using them for many things as we move forward.\nIn the next part: Using Constructed Solid Geometry (CSG).\nYou can also find a video version of this lesson here:    --"},{"uri":"http://kidscancode.org/godot_recipes/3d/healthbars/","title":"3D Unit Healthbars","tags":[],"description":"","content":"Problem You want a floating \u0026ldquo;healthbar\u0026rdquo; for your 3D game objects (mobs, characters, etc.).\nSolution For this solution, we\u0026rsquo;re going to re-use a 2D healthbar based on a TextureProgress node. It\u0026rsquo;s already set up with textures and code for updating the value and color. If you already have something similar, feel free to use it here. In the example, we\u0026rsquo;ll name this scene \u0026ldquo;Healthbar2D\u0026rdquo;.\nIf you need some assets, here are the three images used in the bar:\nRe-using existing objects can save you a lot of time. Don\u0026rsquo;t re-invent the wheel everytime you need a healthbar, camera, or other common object.\n\rProject setup We\u0026rsquo;ll start with a KinematicBody mob. It\u0026rsquo;s programmed to spawn and travel in a straight line. It also has the following code to handle damage:\nfunc _on_Mob_input_event(camera, event, click_position, click_normal, shape_idx):\rif event is InputEventMouseButton:\rif event.button_index == BUTTON_LEFT and event.pressed:\rhealth -= 1\rif health \u0026lt;= 0:\rqueue_free()\rClicking on a unit deals one damage. Do ten damage, and the unit is destroyed. Now we need a visual representation of that using our 2D bar.\n2D in 3D You can display a 2D image in 3D using a Sprite3D. Add one to a new scene and name it \u0026ldquo;Healthbar3D\u0026rdquo;. First, we\u0026rsquo;ll get it configured and sized, so set the Texture to the green bar image.\nThe Sprite3D acts like any other 3D object - as we pan the camera around, our perspective on it changes. However, we want the healthbar to always \u0026ldquo;face\u0026rdquo; toward the camera so that we can see it.\nIn the Inspector, under Flags, set Billboard to \u0026ldquo;Enabled\u0026rdquo;.\nNow try moving the camera to confirm that the texture is always facing you.\nAdd an instance of this scene to the Mob scene and position the bar above the mob\u0026rsquo;s body.\nViewport texture We don\u0026rsquo;t want the Sprite3D to show a static texture - we want it to display the 2D TextureProgress. We can do that using a Viewport node, which can export a texture.\nAdd a Viewport as a child of the Sprite3D. In the Inspector set these properties:\n Transparent Bg: On Rendering/Usage: 2D Render Target/V Flip: On  We also need to set the size of the Viewport to match the size of the healthbar texture, which is (200, 26).\nInstance the HealthBar2D as a child of the Viewport. Your scene should look like this:\nIf the Viewport were not a child of the Sprite3D, we could set it as the sprite\u0026rsquo;s texture directly in the Inspector. Since it\u0026rsquo;s a child, it won\u0026rsquo;t be ready at the right time, so we\u0026rsquo;ll need to set it in a script attached to the Sprite3D:\nextends Sprite3D\rfunc _ready():\rtexture = $Viewport.get_texture()\rConnecting it all together In the mob\u0026rsquo;s _on_Mob_input_event() method, add the following after reducing the health:\n$HealthBar3D.update(health, max_health)\rAdd the following to HealthBar3D.gd:\nonready var bar = $Viewport/HealthBar2D\rfunc update(value, full):\rbar.update_bar(value, full)\rThis calls the update method that already exists on the 2D bar, setting the progress bar\u0026rsquo;s value and selecting the bar color:\nfunc update_bar(amount, full):\rtexture_progress = bar_green\rif amount \u0026lt; 0.75 * full:\rtexture_progress = bar_yellow\rif value \u0026lt; 0.45 * full:\rtexture_progress = bar_red\rvalue = amount\rClick on the mobs to see the health bars change.\nDownload the project file here: 3d_labels.zip\n\rWrapping up You can use this technique to display any other Control nodes, such as Label, VideoPlayer, etc. You can even use the Viewport to \u0026ldquo;project\u0026rdquo; an entire 2D game in 3D space.\nRelated Recipes  Object Healthbars (2D)  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/ui/cooldown_button/","title":"Cooldown Button","tags":[],"description":"","content":"Problem You want to make RPG-style ability buttons, including a cooldown effect.\nSolution If you need art for your buttons, you can find a wide variety of well-designed buttons at Game-icons.net. We\u0026rsquo;ll be using a few from there for this recipe.\nNode setup The scene for our ability button will need the following nodes:\n┖╴TextureButton (\u0026#34;AbilityButton\u0026#34;)\r┠╴TextureProgress (\u0026#34;Sweep\u0026#34;)\r┠╴Timer\r┖╴MarginContainer (\u0026#34;Counter\u0026#34;)\r┖╴Label (\u0026#34;Value\u0026#34;)\rDrop your chosen icon into the Texture property of the AbilityButton.\nOn the Sweep node, choose \u0026ldquo;Full Rect\u0026rdquo; from the Layout menu. Set the Fill Mode to \u0026ldquo;Counter Clockwise\u0026rdquo;.\nWe also want our cooldown \u0026ldquo;radial wipe\u0026rdquo; to darken the button, so set the Modulate property to a dark gray with some transparency:\nThe Timer node should be set to \u0026ldquo;One Shot\u0026rdquo;.\nCounter is a container to hold and align the text. Set its Layout to \u0026ldquo;Bottom Wide\u0026rdquo;, and in its Custom Constants, both Margin Right and Margin Left to 5.\nFinally, on the Value label, set Align to \u0026ldquo;Right\u0026rdquo; and Clip Text to \u0026ldquo;On\u0026rdquo;. Choose a font by adding a DynamicFont and setting an appropriate size. Put a value like 0.0 in the Text field to check how it works. Since our icon is black and white, it also helps to add an Outline Size of 1 in the font\u0026rsquo;s settings.\nScript Add a script to the AbilityButton. Connect the Timer's timeout signal and the AbilityButton's pressed signal.\nextends TextureButton\ronready var time_label = $Counter/Value\rexport var cooldown = 1.0\rfunc _ready():\r$Timer.wait_time = cooldown\rtime_label.hide()\r$Sweep.texture_progress = texture_normal\r$Sweep.value = 0\rset_process(false)\rWe start by exporting a cooldown variable for the length of our ability\u0026rsquo;s cooldown. Then, in the _ready() method, we can set the Timer to use that value. Then we hide the label, because we only want to display it during the countdown.\nNext, we need a texture to assign to the TextureProgress display. In this case, we\u0026rsquo;ll copy the texture from the button - you could also use a different texture if you like.\nFinally, we make sure the sweep\u0026rsquo;s value is at 0, and set the node\u0026rsquo;s processing to false. We\u0026rsquo;ll do the animation in _process() so we don\u0026rsquo;t need it running when we\u0026rsquo;re not in cooldown mode.\nfunc _process(delta):\rtime_label.text = \u0026#34;%3.1f\u0026#34; % $Timer.time_left\r$Sweep.value = int(($Timer.time_left / cooldown) * 100)\rIn _process() we use the time_left on the timer to set the label\u0026rsquo;s text and the sweep\u0026rsquo;s value.\nfunc _on_AbilityButton_pressed():\rdisabled = true\rset_process(true)\r$Timer.start()\rtime_label.show()\rWhen the button is clicked, everything gets started.\nfunc _on_Timer_timeout():\rprint(\u0026#34;ability ready\u0026#34;)\r$Sweep.value = 0\rdisabled = false\rtime_label.hide()\rset_process(false)\rAnd everything is reset when the timer runs out. Put several buttons in an HBoxContainer and you\u0026rsquo;ve got an action bar:\nDownload the project file here: cooldown_button.zip\n\rRelated recipes  UI: Labels UI: Containers    --  "},{"uri":"http://kidscancode.org/godot_recipes/input/custom_mouse_cursor/","title":"Customizing the Mouse Cursor","tags":[],"description":"","content":"Problem You want to use a custom mouse cursor.\nSolution Setting the mouse cursor is done with Input.set_custom_mouse_cursor(). All you need is a texture to use. The texture must be no larger than 256x256 pixels in size.\nFor example, to use the following image:\nAnd set its hotspot to the center:\nextends Node2D\rfunc _ready():\rInput.set_custom_mouse_cursor(cursor_image,\rInput.CURSOR_ARROW,\rVector2(64, 64))\rThe second parameter sets which system cursor to replace. See the Input docs for the full list.\n"},{"uri":"http://kidscancode.org/godot_recipes/ui/heart_containers_3/","title":"Heart Containers: 3 Ways","tags":[],"description":"","content":"Problem You need to display a heart container bar (or other icon-based bar).\nSolution A common way of displaying the player\u0026rsquo;s health is via a series of icons (typically hearts) that disappear as the player takes damage.\nIn this recipe, we\u0026rsquo;re going to explore three ways of displaying this information, which I\u0026rsquo;m labeling \u0026ldquo;simple\u0026rdquo;, \u0026ldquo;empty\u0026rdquo;, and \u0026ldquo;partial\u0026rdquo;:\nThis image shows what the bar displays when the player has 3 health.\n simple: Only the hearts are displayed. empty: Empty heart containers are displayed. partial: The player can have partially filled containers.  Setting up the bar The heart images I\u0026rsquo;m using are 53x45. You can get them here:\nKenney.nl: Platformer Art Deluxe\nIdeally, your heart bar will be easy to drop into your overall HUD/UI. It therefore makes sense to make it a separate scene. We\u0026rsquo;ll start with an HBoxContainer which will keep things aligned. Set the Custom Constants/Separation to 5.\nAdd a TextureRect child. Drag your heart texture into the Texture property and set the Stretch Mode to \u0026ldquo;Keep\u0026rdquo;. Name the node \u0026ldquo;1\u0026rdquo; and then press \u0026ldquo;Ctrl-D\u0026rdquo; to duplicate the node for as many hearts as you need (5 in this example). Your node setup should look like this:\nAdding a script The script below will cover all three bar configurations for flexibility. If you only need one in your game, you can remove the code relating to the other modes.\nTo begin, we\u0026rsquo;re going to load the textures we need and define our three bar modes:\nextends HBoxContainer\renum MODES {simple, empty, partial}\rvar heart_full = preload(\u0026#34;res://assets/hud_heartFull.png\u0026#34;)\rvar heart_empty = preload(\u0026#34;res://assets/hud_heartEmpty.png\u0026#34;)\rvar heart_half = preload(\u0026#34;res://assets/hud_heartHalf.png\u0026#34;)\rexport (MODES) var mode = MODES.simple\rfunc update_health(value):\rmatch mode:\rMODES.simple:\rupdate_simple(value)\rMODES.empty:\rupdate_empty(value)\rMODES.partial:\rupdate_partial(value)\rCalling update_health() on the bar will cause it to display the passed value, based on the selected mode.\nWe\u0026rsquo;re not going to do any bounds checking on the value input. There are many ways you may have health implemented in your game, and so that\u0026rsquo;s left to you.\n\rFirst, the update_simple() method. Here, we loop through the heart containers and set the visibility of each TextureRect:\nfunc update_simple(value):\rfor i in get_child_count():\rget_child(i).visible = value \u0026gt; i\rupdate_empty() is very similar, except instead of hiding the icon, we change its texture to the empty container:\nfunc update_empty(value):\rfor i in get_child_count():\rif value \u0026gt; i:\rget_child(i).texture = heart_full\relse:\rget_child(i).texture = heart_empty\rFinally, for the partially filled containers, we have a third texture and twice the number of possible values:\nfunc update_partial(value):\rfor i in get_child_count():\rif value \u0026gt; i * 2 + 1:\rget_child(i).texture = heart_full\relif value \u0026gt; i * 2:\rget_child(i).texture = heart_half\relse:\rget_child(i).texture = heart_empty\rHere\u0026rsquo;s an example using each of the bar modes:\nWrapping up Use this heart bar setup as a basis for your own HUD. This technique can be expanded to support a wide variety of information displays.\nDownload the project file here: heart_bars.zip\n\rRelated recipes  UI: Containers  "},{"uri":"http://kidscancode.org/godot_recipes/physics/kinematic_to_rigidbody/","title":"Kinematic to Rigid Body Interaction","tags":[],"description":"","content":"Problem You want your kinematic character to interact with rigid bodies.\nSolution This recipe applies equally well in both 2D and 3D nodes.\n\rBy default, a kinematic body moved with move_and_slide() or move_and_collide() will push any rigid bodies it collides with. This interaction ignores the rigid body\u0026rsquo;s physics properties due to the kinematic move function\u0026rsquo;s infinite_inertia parameter.\nIn some cases, this might be all you need. However, if you want to avoid \u0026ldquo;glitches\u0026rdquo; such as body overlap, tunneling, and other unrealistic behavior, you\u0026rsquo;ll need to add some code for the interactions.\nFor this example, we\u0026rsquo;ll use the 2D character described in the Platform character recipe.\nThe most commonly used movement method for kinematic bodies is move_and_slide(). In the example code, the movement happens on this line:\nvelocity = move_and_slide(velocity, Vector2.UP)\rThis causes the body to move in the given direction and slide along obstacles when colliding, as well as using the floor_normal parameter to determine what surfaces should count as a \u0026ldquo;floor\u0026rdquo;. move_and_slide() also contains additional parameters:\nmove_and_slide ( Vector2 linear_velocity,\rVector2 floor_normal=Vector2( 0, 0 ),\rbool stop_on_slope=false, int max_slides=4,\rfloat floor_max_angle=0.785398,\rbool infinite_inertia=true )\rIt\u0026rsquo;s that last one that needs to be changed. Since GDScript doesn\u0026rsquo;t have named parameters, this means we have to pass all of them, but we can keep them at their default values:\nvelocity = move_and_slide(velocity, Vector2.UP,\rfalse, 4, PI/4, false)\rNow if you try to move, you\u0026rsquo;ll see that the kinematic body just stops on collision. It can\u0026rsquo;t push the rigid body at all.\nTo give the colliding body a \u0026ldquo;push\u0026rdquo; we\u0026rsquo;ll need to apply an impulse. An impulse is an instantaneous \u0026ldquo;kick\u0026rdquo; - think of a bat hitting a ball. This is as opposed to a force, which is a continuous \u0026ldquo;push\u0026rdquo; on an object.\n# This represents the player\u0026#39;s inertia.\r export (int, 0, 200) var push = 100\rfunc _physics_process(delta):\r# after calling move_and_slide()\r for index in get_slide_count():\rvar collision = get_slide_collision(index)\rif collision.collider.is_in_group(\u0026#34;bodies\u0026#34;):\rcollision.collider.apply_central_impulse(-collision.normal * push)\rThe collision normal points out of the rigid body, so we reverse it to point away from the character and apply the push factor. Now pushing works again, but it won\u0026rsquo;t force the rigid bodies through walls:\nYou can also scale the force of the impulse based on the character\u0026rsquo;s speed:\ncollision.collider.apply_central_impulse(-collision.normal * velocity.length() * push_factor)\r# Depending on your character\u0026#39;s movement speed, adjust push_factor to\r # something between 0 and 1.\r Experiment to find the settings that work for your particular game.\nDownload the project file here: kinematic_vs_rigid.zip\n\rRelated recipes  Platform character  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/2d/2d_align_surface/","title":"KinematicBody2D: align with surface","tags":[],"description":"","content":"Problem You need your kinematic body to align with the surface it\u0026rsquo;s standing on.\nSolution As of Godot 3.2, there is a bug preventing KinematicBody2D\u0026rsquo;s stop_on_slope parameter from working correctly. The technique in this recipe can be used as a workaround for this problem. See GitHub for details and other suggestions regarding this issue.\n\rWe\u0026rsquo;ll start with a basic kinematic platform character. See the Platform character recipe for details.\nWe have the following code for movement:\nfunc _physics_process(delta):\rget_input()\rvelocity.y += gravity * delta\rvelocity = move_and_slide(velocity, Vector2.UP, true)\rif is_on_floor():\ris_jumping = false\rif Input.is_action_just_pressed(\u0026#34;ui_up\u0026#34;):\ris_jumping = true\rvelocity.y = jump_speed\r\nAs you can see, there are a couple of problems. First, the character flies off the slope when running. It\u0026rsquo;s also sliding down the slope when there\u0026rsquo;s no input.\nWe can partially solve this by switching from move_and_slide() to move_and_slide_with_snap():\nsnap = Vector2.DOWN * 128 if !is_jumping else Vector2.ZERO\rvelocity = move_and_slide_with_snap(velocity, snap, Vector2.UP, true)\r\nNow we have an upward \u0026ldquo;hop\u0026rdquo; when we stop on the way up the slope. This is because our x velocity is set to 0 by the lack of input, but the y is not.\nOrienting the velocity We can fix this by orienting our velocity relative to the slope. To illustrate, let\u0026rsquo;s first rotate the character to align with the slope. We can do this by checking the floor normal when we\u0026rsquo;re on the floor:\nif is_on_floor():\rrotation = get_floor_normal().angle() + PI/2\r\nThis hasn\u0026rsquo;t changed anything about the movement yet, but it does help us visualize what we need to do. When we\u0026rsquo;re on the slope, our local transform looks like this:\nNow when we move, we want our x velocity to align with our local x axis (the red arrow), and gravity/jump to align with local y (the green arrow). We can keep our input code the same, and just assume that velocity is always calculated in the local coordinate system. The only problem will be that move_and_slide() expects the velocity vector to be in global coordinates. Let\u0026rsquo;s adjust move_and_slide_with_snap() to account for this:\nsnap = transform.y * 128 if !is_jumping else Vector2.ZERO\rvelocity = move_and_slide_with_snap(velocity.rotated(rotation),\rsnap, -transform.y, true)\r# Convert velocity back to local space.\r velocity = velocity.rotated(-rotation)\rWe\u0026rsquo;ve changed a few things here, so let\u0026rsquo;s look at them carefully.\n The snap vector is now our local down vector, so it will always point directly into the slope. The floor_normal parameter is also changed to the local up direction (-transform.y). We convert velocity to global by rotating it to match the player\u0026rsquo;s rotation, then revert the resulting velocity back to local by doing the reverse.  The result:\n\nWrapping up This technique allows for a wide range of possible platformer-style movement schemes. For example, you can do fun things like this:\n\nHere\u0026rsquo;s the full script:\nfunc _physics_process(delta):\rget_input()\rvelocity.y += gravity * delta\rsnap = transform.y * 128 if !is_jumping else Vector2.ZERO\rvelocity = move_and_slide_with_snap(velocity.rotated(rotation),\rsnap, -transform.y, true, 4, PI/3)\rvelocity = velocity.rotated(-rotation)\rif is_on_floor():\rrotation = get_floor_normal().angle() + PI/2\ris_jumping = false\rif Input.is_action_just_pressed(\u0026#34;ui_up\u0026#34;):\ris_jumping = true\rvelocity.y = jump_speed\rRelated recipes  Platform character Using KinematicBody2D  "},{"uri":"http://kidscancode.org/godot_recipes/games/circle_jump/","title":"Mobile Game: Circle Jump","tags":[],"description":"","content":" Circle Jump An end-to-end game development series. In this series, we build a one-touch mobile game called \u0026ldquo;Circle Jump\u0026rdquo;. Here\u0026rsquo;s what the game looks like:\nIn each part of the series, we\u0026rsquo;ll add features and fix bugs, explaining the process along the way.\nThe game is be available on the following platforms:\n Android: Google Play Store iOS: coming soon Web: Game of the Month  You can also download it for desktop platforms from Itch.io:\nCircle Jump by kidscancode\rAll source code for the game is available on GitHub.\n"},{"uri":"http://kidscancode.org/godot_recipes/2d/moving_platforms/","title":"Moving Platforms","tags":[],"description":"","content":"Problem You need moving platforms in your 2D platformer.\nSolution There are several ways to approach this problem. In this recipe, we\u0026rsquo;ll use KinematicBody2Ds for our platforms and move them with AnimationPlayer. This allows for a variety of movement styles while minimizing the amount of code we need to write.\nSetting up We\u0026rsquo;ll start with a basic platformer setup using the Platform character recipe. We will need to make one small modification from that recipe: using move_and_slide_with_snap() for the movement.\nHere is the updated code:\nfunc _physics_process(delta):\rget_input()\rvelocity.y += gravity * delta\rvar snap = Vector2.DOWN * 16 if is_on_floor() else Vector2.ZERO\rvelocity = move_and_slide_with_snap(velocity, snap, Vector2.UP)\rif Input.is_action_just_pressed(\u0026#34;jump\u0026#34;):\rif is_on_floor():\rvelocity.y = jump_speed\rWith this code, we\u0026rsquo;ll still get the same behavior with jumping and sliding, but the snap value will ensure that the character \u0026ldquo;sticks\u0026rdquo; to the platform even if it moves. See the KinematicBody2D docs for more information on how the snap parameter works.\nCreating the platform The platform scene contains the following nodes:\nThe Node2D parent is there to act as the \u0026ldquo;anchor\u0026rdquo; or start point for the platform. We\u0026rsquo;ll animate the platform\u0026rsquo;s position relative to this parent node.\nSet up the Sprite\u0026rsquo;s Texture and the collision shape appropriately. In the KinematicBody2D, set the Sync to Physics property \u0026ldquo;On\u0026rdquo;. Since we\u0026rsquo;re not moving the body in code, this ensures that it\u0026rsquo;s moved during the physics step. You\u0026rsquo;ll also need to set the Process Mode property of the AnimationPlayer to \u0026ldquo;Physics\u0026rdquo;.\nTo move the platform, create an animation in the AnimationPlayer that animates the body\u0026rsquo;s position property. For example, here\u0026rsquo;s one animating the platform horizontally in a 4 second loop:\nYou\u0026rsquo;re done! Instance some platforms in your level/world and try them out:\n\nDownload the project file here: moving_platforms.zip\n\rRelated recipes  Platform character  Like video? Coming soon\n  --"},{"uri":"http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_05/","title":"Score and HUD","tags":[],"description":"","content":"In the last part, we added UI in the form of menus to start and configure the game. We also need a UI to display in-game information such as score.\nHUD scene Add a new scene with a CanvasLayer root to be our HUD. Give it two children: a MarginContainer named \u0026ldquo;ScoreBox\u0026rdquo; and a `Label\u0026rdquo; named \u0026ldquo;Message\u0026rdquo;.\nYour scene tree should look like this:\nSet the layout of the ScoreBox to \u0026ldquo;Bottom Wide\u0026rdquo; and the Custom Constants all to 20. Add an HBoxContainer child and under that two Label nodes. Name the second label \u0026ldquo;Score\u0026rdquo; and put 100 in its Text property. Set the HBoxContainer's Alignment to \u0026ldquo;End\u0026rdquo;.\nAdd the same DynamicFont resource to both labels, but choose \u0026ldquo;Make Unique\u0026rdquo; on the first label and set its size to 32. Set its Text property to \u0026ldquo;Score\u0026rdquo;. In its _Size Flags/Vertical, set \u0026ldquo;Fill\u0026rdquo;. Your layout should look like this:\nNow for the Message node load the font and set Text to \u0026ldquo;Message\u0026rdquo; so we\u0026rsquo;ll have something to see. Also choose \u0026ldquo;Make Unique\u0026rdquo; on the font resource (you\u0026rsquo;ll see why in the next section). Set Align and Valign to \u0026ldquo;Center\u0026rdquo; and Clip Text to \u0026ldquo;On\u0026rdquo;. For layout, choose \u0026ldquo;Center Wide\u0026rdquo;. Also, set Grow Direction/Vertical to \u0026ldquo;Both\u0026rdquo;.\nMessage animation This message will show information during gameplay (level up, bonuses, etc). We want it to be animated - to appear and then fade out. Add an AnimationPlayer to the scene.\nWe\u0026rsquo;ll make two animations: one to set the initial values, and one to animate the message display. Add the first animation, \u0026ldquo;init\u0026rdquo; and click the \u0026ldquo;Autoplay on Load\u0026rdquo; button. Set the length to 0.1.\nAdd a keyframe at time 0 for the Font/Size (64), and one for the Visible set to \u0026ldquo;Off\u0026rdquo;.\nAdd the second animation, \u0026ldquo;show_message\u0026rdquo;. Set its length to 0.75 and keyframe Visibility to \u0026ldquo;On\u0026rdquo;.\nNext, we\u0026rsquo;ll keyframe the Font/Size from 64 at time 0 and 200 at the end. Set the track\u0026rsquo;s Update Mode to \u0026ldquo;Continuous\u0026rdquo;.\nWe also want it to fade out as it grows, so keyframe the Modulate alpha value from 255 to 0.\nHeres\u0026rsquo; what the animation settings should look like:\nAnd the animation when it plays:\nHUD Script Now let\u0026rsquo;s add a script to the scene, with methods to update the displays:\nextends CanvasLayer\rfunc show_message(text):\r$Message.text = text\r$AnimationPlayer.play(\u0026#34;show_message\u0026#34;)\rfunc hide():\r$ScoreBox.hide()\rfunc show():\r$ScoreBox.show()\rfunc update_score(value):\r$ScoreBox/HBoxContainer/Score.text = str(value)\rInstance the HUD in the main scene, and add $HUD.hide() to the _ready() and _on_Jumper_died() functions. In new_game() we need to show the hud and display a message:\n$HUD.show()\r$HUD.show_message(\u0026#34;Go!\u0026#34;)\rTo add the score, create a score variable and set it to 0 in new_game(). In _on_Jumper_captured() increment it by one. Make sure to call $HUD.update_score(score) after each of these.\nIn the next part, we\u0026rsquo;ll add sound and color to the game!\n Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "},{"uri":"http://kidscancode.org/godot_recipes/2d/2d_shooting/","title":"Shooting projectiles","tags":[],"description":"","content":"Problem You want to shoot projectiles from your player/mob/etc..\nSolution Setting up the bullet First, we\u0026rsquo;ll set up a \u0026ldquo;bullet\u0026rdquo; object that we can instance. Here are the nodes we\u0026rsquo;ll use:\n- Area2D (\u0026#34;Bullet\u0026#34;)\r- Sprite\r- CollisionShape2D\rFor the Sprite's texture, you can use any image you like. Here\u0026rsquo;s an example one:\nSet up the nodes and configure the sprite and collision shape. If your texture is oriented pointing up, like the one above, make sure to rotate the Sprite node by 90° so that it\u0026rsquo;s pointing to the right, ensuring it matches the parent’s “forward” direction.\nAdd a script and connect the Area2D's body_entered signal.\nextends Area2D\rvar speed = 750\rfunc _physics_process(delta):\rposition += transform.x * speed * delta\rfunc _on_Bullet_body_entered(body):\rif body.is_in_group(\u0026#34;mobs\u0026#34;):\rbody.queue_free()\rqueue_free()\rFor this example, we\u0026rsquo;ll remove the bullet if it hits anything at all. We\u0026rsquo;ll also delete anything tagged in the \u0026ldquo;mobs\u0026rdquo; group that it hits.\nShooting We need to set up a spawn location for the bullets. Add a Position2D and place it where you want the bullets to spawn. Here\u0026rsquo;s an example, placed at the barrel of the gun. I\u0026rsquo;ve named it \u0026ldquo;Muzzle\u0026rdquo;.\nNotice that as the player rotates, the Muzzle\u0026rsquo;s transform remains oriented the same way relative to the gun. This will be very convenient when spawning the bullets, as they can use the transform to get the proper position and direction. We just set the new bullet\u0026rsquo;s transform equal to the muzzle\u0026rsquo;s.\nThis will work for any character type, not just the \u0026ldquo;rotate-and-move\u0026rdquo; style shown here. Just attach the Position2D where you want the bullets to spawn.\n\rIn the character\u0026rsquo;s script we add a variable to hold the bullet scene for instancing:\nexport (PackedScene) var Bullet\rAnd check for our defined input action:\nif Input.is_action_just_pressed(\u0026#34;shoot\u0026#34;):\rshoot()\rNow in our shoot() function we can instance a bullet and add it to the tree. A common mistake is to add the bullet as a child of the player:\nfunc shoot():\rvar b = Bullet.instance()\radd_child(b)\rb.transform = $Muzzle.transform\rThe problem here is that since the bullets are children of the player, they are affected when the player moves or rotates.\nTo fix this, we should make sure the bullets are added to the world instead. In this case, we\u0026rsquo;ll use owner, which refers to the root node of the scene the player is in. Note that we also need to use the muzzle\u0026rsquo;s global transform, or else the bullet would not be where we expected.\nfunc shoot():\rvar b = Bullet.instance()\rowner.add_child(b)\rb.transform = $Muzzle.global_transform\rDownload the project file here: 2d_shooting.zip\n\rRelated recipes  Top-down character Gamedev Math: transforms AI: Homing missiles    --  "},{"uri":"http://kidscancode.org/godot_recipes/3d/3d_shooting/","title":"Shooting projectiles","tags":[],"description":"","content":"Problem You want to shoot projectiles from your player/mob/etc..\nSolution For this example, we\u0026rsquo;ll use the \u0026ldquo;Mini Tank\u0026rdquo; that we set up in KinematicBody: Movement.\nSetting up the bullet First, we\u0026rsquo;ll set up a \u0026ldquo;bullet\u0026rdquo; object that we can instance. Here are the nodes we\u0026rsquo;ll use:\n- Area (\u0026#34;Bullet\u0026#34;)\r- MeshInstance\r- CollisionShape\rFor your mesh, you can use one of Godot\u0026rsquo;s built-in primitive shapes, or something like this:\nIf you\u0026rsquo;d like to use the bullet model pictured here, you can grab it from Kenney\u0026rsquo;s \u0026ldquo;Weapon Pack\u0026rdquo;.\n\rAdd your mesh to the MeshInstance and a scale a collision shape to match.\nRemember to align your MeshInstance with the forward direction (-Z) of the Area node, or your bullet won\u0026rsquo;t look like it\u0026rsquo;s flying the right way!\n\rAdd a script and connect the Area's body_entered signal.\nextends Area\rsignal exploded\rexport var muzzle_velocity = 25\rexport var g = Vector3.DOWN * 20\rvar velocity = Vector3.ZERO\rfunc _physics_process(delta):\rvelocity += g * delta\rlook_at(transform.origin + velocity.normalized(), Vector3.UP)\rtransform.origin += velocity * delta\rfunc _on_Shell_body_entered(body):\remit_signal(\u0026#34;exploded\u0026#34;, transform.origin)\rqueue_free()\rWe\u0026rsquo;re using a custom gravity vector, g so that we can control how the shell flies from the tank\u0026rsquo;s cannon, giving it a nice arc effect. If you\u0026rsquo;d rather your projectiles move in a straight line, you can remove the line that applies it in _physics_process().\nUsing look_at() each frame turns the bullet to point in its direction of travel.\nWe\u0026rsquo;ll also emit an exploded signal, which you can connect up to implement explosion and/or damage effects (but that\u0026rsquo;s for another recipe).\nShooting Now in the tank (or whatever object you have doing the shooting), add a Position3D child at the point where you want the bullets to appear. In the case of our tank, we\u0026rsquo;re placing it at the end of the cannon barrel:\nNow we can add the code to the tank\u0026rsquo;s script. First a way to add the bullet scene we\u0026rsquo;re going to instance:\nexport (PackedScene) var Bullet\rAnd in _process() or _unhandled_input() (wherever you\u0026rsquo;re capturing input), add the code to instance the bullet:\nif Input.is_action_just_pressed(\u0026#34;shoot\u0026#34;):\rvar b = Bullet.instance()\rowner.add_child(b)\rb.transform = $Cannon/Muzzle.global_transform\rb.velocity = -b.transform.basis.z * b.muzzle_velocity\rThat\u0026rsquo;s it - run your scene and try it out:\n\nDownload the project file here: 3d_shooting.zip\n\rRelated recipes  KinematicBody: Movement Godot 101: Intro to 3D    --  "},{"uri":"http://kidscancode.org/godot_recipes/2d/tilemap_animation/","title":"TileMap: animated tiles","tags":[],"description":"","content":"Problem You\u0026rsquo;d like to use animated tiles in your TileMap.\nSolution The most straightforward way to approach this problem is to use the AnimatedTexture resource.\nCreating an AnimatedTexture For this example, we\u0026rsquo;ll use the following water tiles:\nDownload these images: water.zip\nUnzip the images into your project folder. In the Inspector, click the \u0026ldquo;Create a new resource\u0026rdquo; button:\nChoose AnimatedTexture and set the Frames property to 5. For each frame, drag the corresponding image to its Texture property.\nYou can adjust the overall animation\u0026rsquo;s speed with the Fps property, as well as each individual frame\u0026rsquo;s Delay Sec.\nClick the \u0026ldquo;Save\u0026rdquo; button to save the resource. Give it a name such as water_anim.tres.\nUsing AnimatedTexture in a TileMap Now that the AnimatedTexture is saved, it can be used in a TileSet. Open a new or existing TileMap and select its Tile Set property. Click the button to add a new texture to the TileSet:\nSelect the newly added texture and click \u0026ldquo;New Single Tile\u0026rdquo;. Draw a box around the texture (use \u0026ldquo;Enable Snap\u0026rdquo; to make this easier).\nNow you can select the tile in your TileMap and draw with it just like any other tile.\nYou can download a complete project of this example: animated_tiles.zip\nRelated Recipes  TileMap: using autotile  "},{"uri":"http://kidscancode.org/godot_recipes/math/","title":"Gamedev Math","tags":[],"description":"","content":" Gamedev Math Math is a big part of game development. Some of it you may remember from school, or it may be something you\u0026rsquo;ve never encountered before. Here you\u0026rsquo;ll find guides to help you get up to speed and examples of how these concepts are applied to making games.\nIn this section: \rInterpolation\r\r\rTransforms\r\r\rNoise\r\r\rVectors: Using Dot and Cross Product\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/recipes/","title":"Misc","tags":[],"description":"","content":" Misc Other recipes that just don\u0026rsquo;t fit in anywhere else.\nIn this section: \rInheritance\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/physics/","title":"Physics","tags":[],"description":"","content":" Physics Learn how to use Godot\u0026rsquo;s physics nodes.\nIn this section: \rUsing KinematicBody2D\r\r\rUsing Rigid Bodies\r\r\rKinematic Friction\r\r\rRigidBody2D: Drag and Drop\r\r\rKinematic to Rigid Body Interaction\r\r\rUsing 2D Joints\r\r\rConveyor Belt\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/ai/","title":"AI/Behavior","tags":[],"description":"","content":" AI/Behavior Automated behavior and (sometimes) smarter entities.\nIn this section: \rChasing the player\r\r\rPath following\r\r\rChanging behaviors\r\r\rHoming missile\r\r\rContext-based steering\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/basics/rotation/","title":"Circular movement","tags":[],"description":"","content":"Problem You want an object to \u0026ldquo;orbit\u0026rdquo; (move in a circle) around another object.\nSolution This is a common beginner question, and often comes after a bunch of messy experimenting with trig functions. The answer is much simpler:\nPlace the orbiting sprite in a child node of the main sprite (we\u0026rsquo;re calling it \u0026ldquo;Pivot\u0026rdquo;). Give it an offset and rotate the Pivot.\nextends Node2D\rexport var rotation_speed = PI\rfunc _process(delta):\r$Sprite/Pivot.rotation += rotation_speed * delta\rThis works just as well in 3D, too:\nextends Spatial\rexport var rotation_speed = PI\rfunc _process(delta):\r$MeshInstance/Pivot.rotate_y(rotation_speed * delta)\r"},{"uri":"http://kidscancode.org/godot_recipes/2d/screen_shake/","title":"Screen Shake","tags":[],"description":"","content":"Problem You want to create a \u0026ldquo;screen shake\u0026rdquo; effect.\nSolution The \u0026ldquo;screen shake\u0026rdquo; effect is a popular way to add a dynamic feel to your game. When used well, it adds a lot of appeal. When misused, players hate it. Keep this in mind when adding it to your game and use wisely.\nThe effect is quite simple: when an event occurs - an explosion, a heavy object hitting an obstacle, etc. - we want to rapidly displace the camera in small increments for a brief time.\nThere are many ways to implement this effect. For this recipe, we\u0026rsquo;ll be emulating the technique outlined in the following GDC talk:\n  To summarize, the camera will have a trauma property, measuring how much the camera is shaking. Every time something happens that should shake the camera, we\u0026rsquo;ll add a bit more trauma - a large amount for big events or a little for small ones. Over time, the trauma decreases.\nTrauma We\u0026rsquo;ll start by implementing the camera. Make a new scene with a Camera2D node, name it ShakeCamera2D, and attach a script.\nFirst, define the parameters that control the shake behavior:\nextends Camera2D\rexport var decay = 0.8 # How quickly the shaking stops [0, 1].\r export var max_offset = Vector2(100, 75) # Maximum hor/ver shake in pixels.\r export var max_roll = 0.1 # Maximum rotation in radians (use sparingly).\r export (NodePath) var target # Assign the node this camera will follow.\r var trauma = 0.0 # Current shake strength.\r var trauma_power = 2 # Trauma exponent. Use [2, 3].\r trauma_power is the relationship between trauma and the actual movement of the camera (ie amount = trauma * trauma). A square (2) or cube (3) relationship is typically the best, but feel free to experiment.\nWe\u0026rsquo;ve also added a target variable so that you can place an instance of this camera anywhere you like and set the target node it will follow.\nfunc _ready():\rrandomize()\rfunc add_trauma(amount):\rtrauma = min(trauma + amount, 1.0)\rThe add_trauma() function is what we call to start or increase shaking. Pass it a value from 0 to 1.\nfunc _process(delta):\rif target:\rglobal_position = get_node(target).global_position\rif trauma:\rtrauma = max(trauma - decay * delta, 0)\rshake()\rIn process() we\u0026rsquo;ll move the camera to track its target. If there is any trauma, we\u0026rsquo;ll use decay to reduce it and then call shake() to move the camera.\nRandom displacement The shake() function applies a random movement to the camera based on the current trauma level (raised to the given power). In 2D, we have two translational and one rotational movement to calculate. Picking a random number between -1 and 1 is an easy way to get a movement in either direction.\nfunc shake():\rvar amount = pow(trauma, trauma_power)\rrotation = max_roll * amount * rand_range(-1, 1)\roffset.x = max_offset.x * amount * rand_range(-1, 1)\roffset.y = max_offset.y * amount * rand_range(-1, 1)\rThis looks OK, but we can make it look better.\nUsing noise The drawback with using rand_range() for the movement is that it can change greatly from frame to frame, making for a rather erratic feel. To get a more \u0026ldquo;smooth\u0026rdquo; randomness, we can turn to something called noise.\nNoise, or more specifically gradient noise is a method for generating more natural-looking \u0026ldquo;random\u0026rdquo; patterns. To do this, Godot provides the OpenSimplexNoise class.\nProbably the most well-known gradient noise algorithm is called Perlin noise. Because it and its successor, simplex noise, are protected by patents, Godot uses an algorithm called OpenSimplex to generate noise.\n\rOpenSimplexNoise works by generating a 3D \u0026ldquo;cloud\u0026rdquo; of points. Each point has a value ranging from -1 to 1. Below are two examples of noise generated by OpenSimplexNoise. In the images, each pixel\u0026rsquo;s white value is mapped to the noise value at that point.\nAs you can see, while \u0026ldquo;noisy\u0026rdquo;, if you pick a particular pixel, adjacent pixels may vary unpredictably, but won\u0026rsquo;t suddenly swing wildly from one extreme to another. The behavior can be adjusted to suit your needs, but we won\u0026rsquo;t go into the details of configuring OpenSimplexNoise here. See the related recipes section below for links to more information.\nAdd the following code at the top of the script:\nonready var noise = OpenSimplexNoise.new()\rvar noise_y = 0\rfunc _ready():\rrandomize()\rnoise.seed = randi()\rnoise.period = 4\rnoise.octaves = 2\rThen, in the shake() function:\nnoise_y += 1\rrotation = max_roll * amount * noise.get_noise_2d(noise.seed, noise_y)\roffset.x = max_offset.x * amount * noise.get_noise_2d(noise.seed*2, noise_y)\roffset.y = max_offset.y * amount * noise.get_noise_2d(noise.seed*3, noise_y)\rget_noise_2d() returns the noise value at a given (x, y) coordinate. We don\u0026rsquo;t want to use the same noise value for all three offsets, so we\u0026rsquo;re arbitrarily choosing three different (but distant) x values in the noise, and then using the steadily increasing noise_y value to \u0026ldquo;move\u0026rdquo; along the gradient at each point.\nDownload the project file here: screen_shake.zip\n\rRelated recipes  Noise Platform character  Like video?   --"},{"uri":"http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_06/","title":"Sound and Colors","tags":[],"description":"","content":"Settings singleton First, we\u0026rsquo;ll add a new script by choosing File -\u0026gt; New Script in the script tab. Name the script settings.gd.\nIn this script we\u0026rsquo;ll place the configuration settings for the game.\nvar enable_sound = true\rvar enable_music = true\rvar circles_per_level = 5\rAdd the script as an autoload by opening \u0026ldquo;Project Settings\u0026rdquo; and selecting the \u0026ldquo;Autoloads\u0026rdquo; tab. Click the folder to load the script and then click \u0026ldquo;Add\u0026rdquo;.\nAdding sound To play sounds, we\u0026rsquo;ll be adding several AudioStreamPlayer nodes to different scenes.\n  First, add one to the Main scene and name it \u0026ldquo;Music\u0026rdquo;. For its Stream property use res://assets/audio/Music_Light-Puzzles.ogg.\n  To the Screens scene, add another called \u0026ldquo;Click\u0026rdquo;, which will play when we tap buttons. Use menu_click.wav from the assets folder.\n  In the Circle scene, add an audio player named \u0026ldquo;Beep\u0026rdquo; and use the 89.ogg sound file.\n  Finally, on the Jumper, we need two sound effects: \u0026ldquo;Jump\u0026rdquo; and \u0026ldquo;Capture\u0026rdquo;. Use 70.ogg and 88.ogg, respectively.\n  Now to play the sounds, we can call their play() methods. Add this to Main.new_game():\nif settings.enable_music:\r$Music.play()\rand Main._on_Jumper_died():\nif settings.enable_music:\r$Music.stop()\rIn Screens.gd add this to _on_button_pressed():\nif settings.enable_sound:\r$Click.play()\rOn the circle, we want to play the Beep sound when a limited circle completes a full orbit. This is in check_orbits():\ncurrent_orbits -= 1\rif settings.enable_sound:\r$Beep.play()\rAnd in Jumper.gd, we add the sounds like so:\nfunc jump():\rtarget.implode()\rtarget = null\rvelocity = transform.x * jump_speed\rif settings.enable_sound:\r$Jump.play()\rfunc _on_Jumper_area_entered(area):\rtarget = area\rvelocity = Vector2.ZERO\remit_signal(\u0026#34;captured\u0026#34;, area)\rif settings.enable_sound:\r$Capture.play()\rRun the game and test that you hear all the sounds as expected.\nSound settings Now that we have sound working, we can connect the buttons on the \u0026ldquo;Settings\u0026rdquo; screen that can toggle sound and music.\nThe button appearance needs to be changed to match the current on/off state of the property. We\u0026rsquo;ll load the textures first so that we can assign them as needed:\nvar sound_buttons = {true: preload(\u0026#34;res://assets/images/buttons/audioOn.png\u0026#34;),\rfalse: preload(\u0026#34;res://assets/images/buttons/audioOff.png\u0026#34;)}\rvar music_buttons = {true: preload(\u0026#34;res://assets/images/buttons/musicOn.png\u0026#34;),\rfalse: preload(\u0026#34;res://assets/images/buttons/musicOff.png\u0026#34;)}\rRight now, we\u0026rsquo;re not handling the buttons when they\u0026rsquo;re pressed. The issue is that we\u0026rsquo;re currently passing the button\u0026rsquo;s name, which won\u0026rsquo;t let us change its texture. Instead, we\u0026rsquo;re going to refactor register_buttons() to pass a reference to the button itself:\nbutton.connect(\u0026#34;pressed\u0026#34;, self, \u0026#34;_on_button_pressed\u0026#34;, [button])\rThen we can update _on_button_pressed() like so:\nfunc _on_button_pressed(button):\rif settings.enable_sound:\r$Click.play()\rmatch button.name:\r\u0026#34;Home\u0026#34;:\rchange_screen($TitleScreen)\r\u0026#34;Play\u0026#34;:\rchange_screen(null)\ryield(get_tree().create_timer(0.5), \u0026#34;timeout\u0026#34;)\remit_signal(\u0026#34;start_game\u0026#34;)\r\u0026#34;Settings\u0026#34;:\rchange_screen($SettingsScreen)\r\u0026#34;Sound\u0026#34;:\rsettings.enable_sound = !settings.enable_sound\rbutton.texture_normal = sound_buttons[settings.enable_sound]\r\u0026#34;Music\u0026#34;:\rsettings.enable_music = !settings.enable_music\rbutton.texture_normal = music_buttons[settings.enable_music]\rColor themes We\u0026rsquo;re also goign to add a way to have different color schemes. These can change in different ways: perhaps as a settings option, or they change as the player gets to higher levels.\nWe\u0026rsquo;ll store the color scheme data in a dictionary, with the keys being the \u0026ldquo;name\u0026rdquo; of the scheme. Each color scheme will also be a dictionary, with the keys denoting the game component that will use that color.\nAdd this to settings.gd:\nvar color_schemes = {\r\u0026#34;NEON1\u0026#34;: {\r\u0026#39;background\u0026#39;: Color8(0, 0, 0),\r\u0026#39;player_body\u0026#39;: Color8(203, 255, 0),\r\u0026#39;player_trail\u0026#39;: Color8(204, 0, 255),\r\u0026#39;circle_fill\u0026#39;: Color8(255, 0, 110),\r\u0026#39;circle_static\u0026#39;: Color8(0, 255, 102),\r\u0026#39;circle_limited\u0026#39;: Color8(204, 0, 255)\r},\r\u0026#34;NEON2\u0026#34;: {\r\u0026#39;background\u0026#39;: Color8(0, 0, 0),\r\u0026#39;player_body\u0026#39;: Color8(246, 255, 0),\r\u0026#39;player_trail\u0026#39;: Color8(255, 255, 255),\r\u0026#39;circle_fill\u0026#39;: Color8(255, 0, 110),\r\u0026#39;circle_static\u0026#39;: Color8(151, 255, 48),\r\u0026#39;circle_limited\u0026#39;: Color8(127, 0, 255)\r},\r\u0026#34;NEON3\u0026#34;: {\r\u0026#39;background\u0026#39;: Color8(0, 0, 0),\r\u0026#39;player_body\u0026#39;: Color8(255, 0, 187),\r\u0026#39;player_trail\u0026#39;: Color8(255, 148, 0),\r\u0026#39;circle_fill\u0026#39;: Color8(255, 148, 0),\r\u0026#39;circle_static\u0026#39;: Color8(170, 255, 0),\r\u0026#39;circle_limited\u0026#39;: Color8(204, 0, 255)\r}\r}\rvar theme = color_schemes[\u0026#34;NEON1\u0026#34;]\rNow on each object, we need to set the colors based on the settings property.\nFor the circle, the color is set using the shader material resource. Because resources are shared, that means that changing one circle\u0026rsquo;s color would change them all. Let\u0026rsquo;s make each circle\u0026rsquo;s material unique to avoid this:\n$Sprite.material = $Sprite.material.duplicate()\r$SpriteEffect.material = $Sprite.material\rThe color of the circle is determined by what mode it\u0026rsquo;s using, so set_mode() is where we\u0026rsquo;ll choose the color:\nfunc set_mode(_mode):\rmode = _mode\rvar color\rmatch mode:\rMODES.STATIC:\r$Label.hide()\rcolor = settings.theme[\u0026#34;circle_static\u0026#34;]\rMODES.LIMITED:\rcurrent_orbits = num_orbits\r$Label.text = str(current_orbits)\r$Label.show()\rcolor = settings.theme[\u0026#34;circle_limited\u0026#34;]\r$Sprite.material.set_shader_param(\u0026#34;color\u0026#34;, color)\rThen in the _draw() function where we\u0026rsquo;re filling in the limited circle, replace the red color with settings.theme[\u0026quot;circle_fill\u0026quot;].\nFor the player, set the color in its _ready():\nfunc _ready():\r$Sprite.material.set_shader_param(\u0026#34;color\u0026#34;, settings.theme[\u0026#34;player_body\u0026#34;])\r$Trail/Points.default_color = settings.theme[\u0026#34;player_trail\u0026#34;]\rIn the next part, we\u0026rsquo;ll add a movement to the circles.\n Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "},{"uri":"http://kidscancode.org/godot_recipes/g101/3d/101_3d_06/","title":"Using CSG","tags":[],"description":"","content":"Earlier, we saw how to design a 3D environment using imported models. But what if you want to make something like a room, with walls, doors, ramps, and other features, but you don\u0026rsquo;t have any models handy? CSG to the rescue!\nWhat is CSG? CSG stands for Constructive Solid Geometry. It allows you to combine primitive shapes to build complex geometry. Shapes can be combined with boolean operations such as Union, Intersection, and Subtraction.\nCSG is a great tool for prototyping environments and game objects. Later in this tutorial, we\u0026rsquo;ll use it to make a small FPS-style level with some ramps, walls and platforms.\nBefore we do that, let\u0026rsquo;s get introduced to how the CSG nodes work.\nCSG Basics Create a new scene with a Spatial root, then add a child node and type \u0026ldquo;CSG\u0026rdquo; in the search box.\nThese are the available CSG shapes. Choose a CSGBox to start. You\u0026rsquo;ll see a plain cube mesh with the following properties:\nThe Operation property is the one that determines how CSG shapes will be combined. The options are:\n Union - The shapes will be merged, removing any \u0026ldquo;inside\u0026rdquo; geometry. Intersection - Only the intersecting (overlapping) geometry will be kept. Subtraction - The second shape is \u0026ldquo;cut out\u0026rdquo; of the first.  CSG operations are performed on a shape by adding children. Add a child CSGCylinder to the CSGBox. Drag the top size handle (orange dot) to make it a bit taller. You can also increase the Sides property to make it look more circular (here it\u0026rsquo;s set to 20):\nBy default, the shape\u0026rsquo;s operation is set to \u0026ldquo;Union\u0026rdquo;. The cylinder shape is being \u0026ldquo;added\u0026rdquo; to the cube. Try changing it to \u0026ldquo;Intersection\u0026rdquo;:\nAnd \u0026ldquo;Subtraction\u0026rdquo;:\nHopefully you\u0026rsquo;re already seeing the possibilities of creating complex shapes through these 3 operations.\nCSGCombiner This node is an \u0026ldquo;empty\u0026rdquo; shape. It\u0026rsquo;s used to organize your shapes. Children of a CSGCombiner will be combined following the same rules as above.\nBuilding a Room Now we\u0026rsquo;re going to make something useful: a large room with some obstacles and features that our character can interact with, and that we can use in the upcoming tutorials. Make a new scene with a Spatial root that we can start working with.\nStart with a CSGBox, and set its Width and Depth to 20 and its Height to 5. We need this to be a box that we go inside, so click the Invert Faces property as well. This reverses the shape so that the solid walls are on the inside rather than the outside. Also check the Use Collision property, so that the physics engine will treat this shape as a static body object.\nAdd an instance of the player character and test that you can walk around in your new room.\nYou may remember that in the last part we added code to capture/release the mouse. You\u0026rsquo;ll need to copy that code over to this scene as well.\n\rAdding features Now let\u0026rsquo;s add some features - some internal walls, a ledge running around the edge with a ramp, and so on. Feel free to get creative and add your own ideas. Here are a few to get started:\nIf you use a CSGCombiner for each of these objects it will be easier to organize and duplicate them. Make sure to enable Use Collision on it.\n\r Wall with door  Add a CSGBox and set its Width to 0.5 and its Height to 5 (the same height as the original room). Make the depth about half the size of the room. You can enable snapping here to make it easier to align.\nAdd another CSGBox as a child and set it to \u0026ldquo;Subtract\u0026rdquo;. Size it to resemble a door. You can also use a cylinder shape to get an arched portal.\n Ramp  For the ramp, we\u0026rsquo;ll use a CSGPolygon. This CSG shape lets you extrude a given polygon to a desired depth. The default shape is a square, but you can add or remove points. For a ramp, we want 3 points.\nAfter adding the CSGPolygon, you can click the Polygon property to adjust its number of points. After that, you can drag the three points to whatever location you like. To ensure everything lines up, you can type the coordinates into the Inspector:\nIn this picture, we\u0026rsquo;ve created a ramp and added a couple of CSGBox shapes to make the ledge.\nPutting it together Make sure to add a Material to your shapes, choosing an Albedo color that seems pleasant to you. In the following examples, we\u0026rsquo;ve picked a tan color.\nHere\u0026rsquo;s an example of a possible room setup:\nHit play and you should be able to walk around the rooms:\nThe area is featureless right now, but to make things more visually interesting, you can add individual lights in each room (more about lighting in a later tutorial). Here\u0026rsquo;s an example of adding some OmniLight and SpotLight nodes to the scene:\nWrapping Up CSG is a powerful tool for building objects directly in Godot without having to move to another modeling application such as Blender. It can be helpful if you need to mock up a test level for your game, or for the final environment. Keep in mind that as the CSG tree becomes more complex, it can incur a performance penalty. Try to use CSGCombiner to separate your scene into separate CSG trees to minimize this.\nIn the next part, we\u0026rsquo;ll look at a popular style of 3D game: first person.\nYou can also find a video version of this lesson here:   "},{"uri":"http://kidscancode.org/godot_recipes/shaders/","title":"Shaders","tags":[],"description":"","content":" Shaders Deep voodoo. Cool effects.\nIn this section: \rShaders: intro\r\r\rInteracting with Shaders\r\r\rGreyscale (monochrome) shader\r\r\rBlur shader\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/audio/","title":"Audio","tags":[],"description":"","content":" Audio Helpful recipes for adding sound effects and music to your game.\nIn this section: \rAudio Manager\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/g101/3d/101_3d_07/","title":"First-person Character","tags":[],"description":"","content":"In this installment, we\u0026rsquo;ll look at how to make a first-person character. We\u0026rsquo;ll use the CSG-based level we designed in the previous part as a place to walk around and test our movement.\nCharacter Scene In an FPS or similar game, we want to give the player the illusion that they\u0026rsquo;re looking out of the character\u0026rsquo;s eyes. One nice aspect of this is that we don\u0026rsquo;t really need a model, at least to get started.\nStart with a KinematicBody. To this we\u0026rsquo;ll add two CollisionShape nodes (\u0026ldquo;Body\u0026rdquo; and \u0026ldquo;Feet\u0026rdquo;). We also want to have a Camera, but we need to be careful about how we handle rotation. The character should rotate in Y, but only the camera should rotate in X (for looking up and down). To make this work, add a Spatial node, which we\u0026rsquo;ll call \u0026ldquo;Pivot\u0026rdquo;, and add the Camera to that.\nThe \u0026ldquo;Body\u0026rdquo; collision shape is going to represent the player\u0026rsquo;s body. We can use a CapsuleShape (rotated 90 degrees around X). Set its Radius to 0.5 and Height to 1.\nOne issue with using a CapsuleShape is that the bottom is rounded. This is good for moving over small bumps in a natural way, but it also means that when standing on the edge of a surface, the player will \u0026ldquo;roll\u0026rdquo; off in a strange way. We can prevent this by using a BoxShape for the \u0026ldquo;Feet\u0026rdquo; collision. Make its extents (.4, .1, .4) and place it so that its bottom is just above the bottom of the capsule. We\u0026rsquo;ll still have the round bottom to move over things, but the box will keep us from sliding off ledges.\nMove the Pivot up a bit, so that it\u0026rsquo;s not pointing the camera out of the \u0026ldquo;middle\u0026rdquo; of the body.\nMoving around Much of the code for movement is the same as we used for the third-person character earlier in this series. We\u0026rsquo;ll start with declaring our variables:\nextends KinematicBody\ronready var camera = $Pivot/Camera\rvar gravity = -30\rvar max_speed = 8\rvar mouse_sensitivity = 0.002 # radians/pixel\r var velocity = Vector3()\r\rThe value of mouse_sensitivity maps the movement of the mouse, which is in pixels, to rotation, in degrees. So for each pixel the mouse moves, we\u0026rsquo;ll rotate by 0.002 radians (or about 0.1 degrees).\n\rfunc get_input():\rvar input_dir = Vector3()\r# desired move in camera direction\r if Input.is_action_pressed(\u0026#34;move_forward\u0026#34;):\rinput_dir += -camera.global_transform.basis.z\rif Input.is_action_pressed(\u0026#34;move_back\u0026#34;):\rinput_dir += camera.global_transform.basis.z\rif Input.is_action_pressed(\u0026#34;strafe_left\u0026#34;):\rinput_dir += -camera.global_transform.basis.x\rif Input.is_action_pressed(\u0026#34;strafe_right\u0026#34;):\rinput_dir += camera.global_transform.basis.x\rinput_dir = input_dir.normalized()\rreturn input_dir\rWhen detecting input, we want to move in the direction the camera is facing, which is not necessarily the current movement direction. Although we\u0026rsquo;re not going to do it yet, this will allow us to implement friction and acceleration for a more natural movement feel.\nWe add up the inputs and return the resulting direction vector.\nfunc _unhandled_input(event):\rif event is InputEventMouseMotion and Input.get_mouse_mode() == Input.MOUSE_MODE_CAPTURED:\rrotate_y(-event.relative.x * mouse_sensitivity)\r$Pivot.rotate_x(-event.relative.y * mouse_sensitivity)\r$Pivot.rotation.x = clamp($Pivot.rotation.x, -1.2, 1.2)\rWe also need to capture mouse movement for camera rotation. As discussed above, horizontal mouse movement rotates the entire body in Y, while vertical motion rotates the helper node in X.\nWe also need to limit that vertical rotation to prevent the camera from flipping upside-down.\nfunc _physics_process(delta):\rvelocity.y += gravity * delta\rvar desired_velocity = get_input() * max_speed\rvelocity.x = desired_velocity.x\rvelocity.z = desired_velocity.z\rvelocity = move_and_slide(velocity, Vector3.UP, true)\rIn _physics_process() we get the desired_velocity, the direction vector returned by get_input(), and multiply it by max_speed to set its length. We don\u0026rsquo;t want to alter our velocity.y because that\u0026rsquo;s set by gravity, so we only set the x and z components based on the input.\nWe\u0026rsquo;re also setting true for the stop_on_slope parameter of move_and_slide(). This keeps us from sliding down the ramp if we stand on it.\nTest your movement and ensure everything is working as expected.\nAdding a weapon First person characters typically have some sort of item, or at least empty hands, visible in front of them. We\u0026rsquo;re going to use the shotgun model from the following art pack:\nKenney Weapon Pack\nAddd a MeshInstance to the Pivot node and use the shotgun.obj model from the art pack. You\u0026rsquo;ll notice that the model is too small for our player\u0026rsquo;s scale, so set Scale to (8, 8, 8).\nWe need to position the model so that it\u0026rsquo;s projecting out \u0026ldquo;through\u0026rdquo; the camera. Aligning it can be difficult, so click the \u0026ldquo;View\u0026rdquo; menu and choose \u0026ldquo;2 Viewports\u0026rdquo;. In the bottom one, select the Camera and click \u0026ldquo;Preview\u0026rdquo;, and in the top you can move the gun until it looks right.\nWrapping up We now have a basic first-person character controller. This could make a good foundation for a wide variety of game types by adding features and behaviors, as we\u0026rsquo;ll see in later lessons.\nYou can also find a video version of this lesson here:   "},{"uri":"http://kidscancode.org/godot_recipes/input/multi_unit_select/","title":"Mouse: Drag-select multiple units","tags":[],"description":"","content":"Problem You want to click-and-drag to select multiple units, RTS style.\nSolution Realtime strategy (RTS) games often require giving orders to many units at once. A typical style of selecting multiple units is to click-and-drag a box around them. Once the units are selected, clicking on the map commands them to move.\nHere\u0026rsquo;s an example of what we\u0026rsquo;re going for:\nUnit setup To test this out, we\u0026rsquo;ll need some basic RTS-style units. They are set up to move towards a target and to avoid running into each other. We won\u0026rsquo;t go into too much detail on them in this tutorial. The unit script is commented if you\u0026rsquo;d like to use it as a base for creating your own RTS units. See below for a link to download the project.\nWorld setup Processing the unit selection will happen in the world. We\u0026rsquo;ll start with a Node2D called \u0026ldquo;World\u0026rdquo; and add a few unit instances in it. Attach a script to the World node and add the following variables:\nextends Node2D\rvar dragging = false # Are we currently dragging?\r var selected = [] # Array of selected units.\r var drag_start = Vector2.ZERO # Location where drag began.\r var select_rect = RectangleShape2D.new() # Collision shape for drag box.\r Note that once we\u0026rsquo;ve drawn the box, we\u0026rsquo;ll need a way to find what units are inside it. The RectangleShape2D will allow us to query the physics engine and see what we collided with.\nDrawing the box We\u0026rsquo;ll be using the left mouse button for this. Clicking starts a drag and then letting go ends it. During dragging, we\u0026rsquo;ll draw the rectangle for visibility.\nfunc _unhandled_input(event):\rif event is InputEventMouseButton and event.button_index == BUTTON_LEFT:\rif event.pressed:\r# We only want to start a drag if there\u0026#39;s no selection.\r if selected.size() == 0:\rdragging = true\rdrag_start = event.position\relif dragging:\r# Button released while dragging.\r dragging = false\rif event is InputEventMouseMotion and dragging:\rupdate()\rfunc _draw():\rif dragging:\rdraw_rect(Rect2(drag_start, get_global_mouse_position() - drag_start),\rColor(.5, .5, .5), false)\rSelecting the units Now that we\u0026rsquo;ve got a selection box, we need to find the units that are inside it. When we release the button and the drag ends, we must query the physics space to find the units. Note that the units are KinematicBody2D, but Area2D or other bodies would work as well.\nWe\u0026rsquo;ll use Physics2DDirectSpaceState.intersect_shape() to find the units. This requires a shape (our rectangle) and a transform (our location). See Godot docs for details.\nelif dragging:\rdragging = false\rupdate()\rvar drag_end = event.position\rselect_rect.extents = (drag_end - drag_start) / 2\rWe start by recording the location when we released the button, and use that to set the RectangleShape2D's extents (remember: extents are measured from the rectangle\u0026rsquo;s center, so they\u0026rsquo;re half the full width/height).\nvar space = get_world_2d().direct_space_state\rvar query = Physics2DShapeQueryParameters.new()\rquery.set_shape(select_rect)\rquery.transform = Transform2D(0, (drag_end + drag_start) / 2)\rselected = space.intersect_shape(query)\rNow we must get a reference to the physics state and set up our shape query using Physics2DShapeQueryParameters, assigning it our shape, and using the center of the dragged area as the origin for the query\u0026rsquo;s transform. Our result after calling intersect_shape() is an array of dictionaries, which looks like this:\n[{collider:[KinematicBody2D:1149], collider_id:1149, metadata:Null, rid:[RID], shape:0},\r{collider:[KinematicBody2D:1144], collider_id:1144, metadata:Null, rid:[RID], shape:0},\r{collider:[KinematicBody2D:1154], collider_id:1154, metadata:Null, rid:[RID], shape:0},\r{collider:[KinematicBody2D:1159], collider_id:1159, metadata:Null, rid:[RID], shape:0}]\rEach of those collider items is a reference to a unit, so we can use this to notify them that they\u0026rsquo;ve been selected, activating the outline shader:\nfor item in selected:\ritem.collider.selected = true\rCommanding the units Finally, we can command the selected units to move by clicking somewhere on the screen:\nfunc _unhandled_input(event):\rif event is InputEventMouseButton and event.button_index == BUTTON_LEFT:\rif event.pressed:\rif selected.size() == 0:\rdragging = true\rdrag_start = event.position\relse:\rfor item in selected:\ritem.collider.target = event.position\ritem.collider.selected = false\rselected = []\rThe else clause here triggers if we click the mouse when selected is greater than 0. Each item\u0026rsquo;s target is set, and we make sure to deselect the units so we can start again.\nWrapping up This technique can be expanded to a wide range of RTS or other game styles. Download the full project below and use it as a base for your own game.\nDownload the project file here: rts_movement.zip\n\rRelated recipes  Mouse Input Inputs: Introduction  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_07/","title":"Moving circles","tags":[],"description":"","content":"Fixing a bug Our first task is to fix a bug with our menu system. Pressing the \u0026ldquo;Start\u0026rdquo; button launches a new game, but as the screen is moving off, it can be pressed again. Try \u0026ldquo;spamming\u0026rdquo; the start button - disaster ensues!\nWe can fix this by disabling the buttons while the screen transition is happening. Since we put all the buttons in a \u0026ldquo;buttons\u0026rdquo; group, we can easily do this with call_group().\nHere\u0026rsquo;s the updated BaseScreen.gd:\nextends CanvasLayer\ronready var tween = $Tween\rfunc appear():\rget_tree().call_group(\u0026#34;buttons\u0026#34;, \u0026#34;set_disabled\u0026#34;, false)\rtween.interpolate_property(self, \u0026#34;offset:x\u0026#34;, 500, 0,\r0.5, Tween.TRANS_BACK, Tween.EASE_IN_OUT)\rtween.start()\rfunc disappear():\rget_tree().call_group(\u0026#34;buttons\u0026#34;, \u0026#34;set_disabled\u0026#34;, true)\rtween.interpolate_property(self, \u0026#34;offset:x\u0026#34;, 0, 500,\r0.5, Tween.TRANS_BACK, Tween.EASE_IN_OUT)\rtween.start()\rScore and level As our score increases, we\u0026rsquo;ll want the game\u0026rsquo;s difficulty to increase as well. This means that when we get points, we\u0026rsquo;ll need to check if we\u0026rsquo;ve passed a certain threshold (circles_per_level). We may also have other things that give us points besides jumping on a circle. To make this easier to handle, we\u0026rsquo;ll give our score variable a setget method in the main script:\nvar score = 0 setget set_score\rvar level = 0\rAnd update the new_game() to use that method:\nfunc new_game():\rself.score = 0\rlevel = 1\rDo the same with the score change in _on_Jumper_captured(), and we\u0026rsquo;ll move the HUD update into our new set_score() method:\nfunc _on_Jumper_captured(object):\r$Camera2D.position = object.position\robject.capture(player)\rcall_deferred(\u0026#34;spawn_circle\u0026#34;)\rself.score += 1\rfunc set_score(value):\rscore = value\r$HUD.update_score(score)\rif score \u0026gt; 0 and score % settings.circles_per_level == 0:\rlevel += 1\r$HUD.show_message(\u0026#34;Level %s\u0026#34; % str(level))\rTry the game and you should see a \u0026ldquo;Level 2\u0026rdquo; message on the screen when you reach five points.\nMoving circles Part of the level progression is going to be increased difficulty. One way we\u0026rsquo;ll do that is by making some circles move. We already have multiple circle types (static and limited), but either of those should be capable of moving, so this won\u0026rsquo;t be a new circle type. Instead, it will be a property that any circle can have.\nOpen up the Circle scene and add a Tween node called \u0026ldquo;MoveTween\u0026rdquo;. Add this to the top of the circle script:\nonready var move_tween = $MoveTween\rvar move_range = 100 # Distance the circle moves.\r var move_speed = 1.0 # The circle\u0026#39;s movement speed.\r If move_range is 0, we\u0026rsquo;ll have a non-moving circle. We\u0026rsquo;ll make the default 100 here so that we can test it out.\nTo handle the movement, we\u0026rsquo;ll start the MoveTween. When it ends, we\u0026rsquo;ll start it again in the opposite direction, using the tween_completed signal.\nThis is the code to start the movement. Connect the tween_completed signal to this function:\nfunc set_tween(object=null, key=null):\rif move_range == 0:\rreturn\rmove_range *= -1\rmove_tween.interpolate_property(self, \u0026#34;position:x\u0026#34;,\rposition.x, position.x + move_range,\rmove_speed, Tween.TRANS_QUAD, Tween.EASE_IN_OUT)\rmove_tween.start()\rFinally, we\u0026rsquo;ll add set_tween() to the end of the init() function and we can try it out.\n\n Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "},{"uri":"http://kidscancode.org/godot_recipes/physics/joints_2d/","title":"Using 2D Joints","tags":[],"description":"","content":"Problem You\u0026rsquo;d like to understand Godot\u0026rsquo;s Joint2D nodes.\nSolution Joint are used to constrain the movement of attached physics objects. For any joint node, you need to attach two bodies, which must extend from PhysicsObject2D.\nProperties These properties are common to all joint nodes:\n Node A and Node B: The assigned physics bodies. Bias: The rate at which the joint pulls the two bodies back together if they move apart. Defaults to 0. Disable Collisions: Allows the connected bodies to ignore collisions between them. Defaults to true.  There are three types of Joint2D. In all of the following examples, there is one RigidBody2D connected via a joint to a StaticBody2D. \u0026ldquo;Visible Collision Shapes\u0026rdquo; is enabled in the screen images below so you can see a representation of the joint.\nPinJoint2D The \u0026ldquo;pin\u0026rdquo; joint attaches the two bodies at a single point, allowing them to freely rotate.\nThe pin joint\u0026rsquo;s Softness property gives some \u0026ldquo;springiness\u0026rdquo; to the connection. The value can range from 0 (the default) which allows no movement, to 16.\nDampedSpringJoint2D This joint connects the two bodies with a spring-like force.\nThe spring\u0026rsquo;s behavior can be adjusted with these properties:\n Length: The joint\u0026rsquo;s maximum length. Rest Length:The joint\u0026rsquo;s length when no forces or movement are applied. Stiffness: The spring\u0026rsquo;s \u0026ldquo;stretchiness\u0026rdquo;, i.e. how much it resists forces pulling against it. Damping: How quickly the spring stops \u0026ldquo;bouncing\u0026rdquo;.  GrooveJoint2D This joint constrains the attached bodies to move linearly.\nBy default, the groove runs vertically, but you can change this by rotating the groove node.\nThese properties control the groove\u0026rsquo;s behavior:\n Length: The groove\u0026rsquo;s length. The attached bodies can\u0026rsquo;t move past this maximum distance. Initial Offset: Starting \u0026ldquo;position\u0026rdquo; along the groove.  You can download an example project to play with these joints here: physics_joints.zip\nRelated Recipes "},{"uri":"http://kidscancode.org/godot_recipes/export/","title":"Exporting","tags":[],"description":"","content":" Exporting Building and exporting your project for PC, web, or mobile.\nIn this section: \r"},{"uri":"http://kidscancode.org/godot_recipes/physics/conveyor_belt/","title":"Conveyor Belt","tags":[],"description":"","content":"Problem You want to make a conveyor belt object that will move bodies (kinematic or rigid).\nSolution You can make a conveyor belt object using nothing but a StaticBody2D by using its constant_linear_velocity property.\nSee below for how to address this in 3D.\n\rHere\u0026rsquo;s an example, using nothing but a StaticBody2D and a RigidBody2D. No code was added. The static body\u0026rsquo;s Constant Linear Velocity is set to (200, 0).\nAnimating the belt There are many ways to present the appearance of your conveyor belt, depending on your art assets. For this demo project, I have only a TileMap which is using this single 88x88 tile:\nAdd a Sprite to your static body, and in its Texture choose \u0026ldquo;New AtlasTexture\u0026rdquo;:\nDrop the tile texture in its Texture property and set the Region to (0, 0, 880, 88):\nChoosing 880 gives us a conveyor belt that\u0026rsquo;s exactly 10 tiles wide. You can use any width you need.\nIf your image doesn\u0026rsquo;t repeat or looks wrong, reimport it with the Repeat flag set to \u0026ldquo;Enabled\u0026rdquo;.\n\rTry adjusting the x of the Region property. You\u0026rsquo;ll see the tiles shift. This is what we need to animate the belt. You can do this with an AnimationPlayer or in code. We\u0026rsquo;ll do the latter for this example:\nextends StaticBody2D\rexport var speed = 100\rfunc _ready():\rconstant_linear_velocity.x = speed\rfunc _process(delta):\r$Sprite.texture.region.position.x -= speed * delta\rThis code ensures that our belt moves at the desired speed, and that the animation matches the physics effect. Note that the directions are opposite: increasing the x of the region shifts the image to the left.\nThis works perfectly well with kinematic bodies, too. Here\u0026rsquo;s the same conveyor belt object added to our Platform character recipe:\n3D At the time of this writing, constant_linear_velocity does not work in 3D using StaticBody.\nHowever, you can use this technique if you change from \u0026ldquo;Bullet\u0026rdquo; to the \u0026ldquo;GodotPhysics\u0026rdquo; engine in your Project Settings:\nRelated recipes  Platform character Using KinematicBody2D Moving Platforms  "},{"uri":"http://kidscancode.org/godot_recipes/ai/context_map/","title":"Context-based steering","tags":[],"description":"","content":"Problem You need an AI-controlled object in your game that can follow a path, avoid obstacles, and make other decisions about how to move around the world.\nSolution \u0026ldquo;Steering behavior\u0026rdquo; is the blanket term for a variety of algorithms that you can use to solve this problem. Which one you choose will depend on your game, the type of world the object lives in, and what type of \u0026ldquo;intelligence\u0026rdquo; you want it to have.\nIn this example, we\u0026rsquo;re going to use a method called \u0026ldquo;Context Behavior\u0026rdquo;, which aims to give the object enough information about the world to make a choice of how to move. For additional reading on this subject, see the following links:\n  Andrew Fray: Context Behaviours Know How to Share\n  James Keats: AI Context Behaviors\n  For this demo, we\u0026rsquo;ll use a generic \u0026ldquo;Agent\u0026rdquo; object. In your game, this might be a car driving around a track, a monster patrolling a dungeon, or some other kind of game entity. Our agent will use a KinematicBody2D, but remember, you can use this technique with any kind of object - the algorithm is about the entity choosing a direction to move, how it moves is entirely separate.\nThe Algorithm To begin, let\u0026rsquo;s imagine our agent has a number of rays extending in all directions (we\u0026rsquo;ll talk about how many to use later - for now let\u0026rsquo;s use 8).\nIn our agent\u0026rsquo;s script, we\u0026rsquo;ll store an array called interest, tracking in which directions the agent wants to go.\nOf course, if they\u0026rsquo;re all the same, then it can\u0026rsquo;t move - it wants to go in all directions equally! So lets consider that it has a preference - it mostly wants to go forward:\nIn this case, the interest array would look like this:\nThe strongest desire is to go forward, but forward-left and forward-right are acceptible as well. But what if an obstacle appears?\nNow we\u0026rsquo;ll introduce a second array, danger, that indicates directions that are not preferred.\nCombining these two arrays, we can eliminate any interest directions that are also contained in danger. By summing up the remaining interest directions, we\u0026rsquo;re left with a new direction pointing away from the obstacle.\nTo summarize:\n Find the object\u0026rsquo;s interest directions. Find the directions that contain danger. Eliminate any interest directions that are dangerous. Sum the remaining interest directions to find the new heading.  Finding Interest This will vary depending on what your agent\u0026rsquo;s goal is. If it\u0026rsquo;s to chase the player, then the interest values should be high in the direction of the player. You can even have multiple targets: closer goals have higher interest, but if an obstacle cancels them out, the lower scoring goals will win.\nFor this demo, we\u0026rsquo;re going to imagine we\u0026rsquo;re making a racing game of some kind. The AI-controlled cars need to make it around the track: their interest array should be pointing forward along the track, so they don\u0026rsquo;t start going backwards.\nThere are a few ways to do this, and in order to keep our agents from needing to know the implementation details, we\u0026rsquo;ll have the track tell them which way to go based on their position. At any time if you ask the track which way is correct, it will tell you.\nThe Code Here\u0026rsquo;s the code for our agent. We start with the exported values: movement parameters and other values we want to be able to adjust easily. look_ahead, for example, is how far ahead the danger rays will detect obstacles.\nNote that we\u0026rsquo;ve made the num_rays adjustable, so that you can find the number that works best for your situation. We\u0026rsquo;ll talk below about the tradeoffs and benefits of larger numbers of rays.\nextends KinematicBody2D\rexport var max_speed = 350\rexport var steer_force = 0.1\rexport var look_ahead = 100\rexport var num_rays = 8\r# context array\r var ray_directions = []\rvar interest = []\rvar danger = []\rvar chosen_dir = Vector2.ZERO\rvar velocity = Vector2.ZERO\rvar acceleration = Vector2.ZERO\rNext, we have _ready() where we size the arrays properly and populate the ray_directions array with the actual ray vectors, distributing them evenly around the circle based on num_rays. We begin with no rotation, so Vector2.RIGHT is forward.\nfunc _ready():\rinterest.resize(num_rays)\rdanger.resize(num_rays)\rray_directions.resize(num_rays)\rfor i in num_rays:\rvar angle = i * 2 * PI / num_rays\rray_directions[i] = Vector2.RIGHT.rotated(angle)\rIn _physics_process() we\u0026rsquo;ll populate the context arrays and execute the movement. Note we\u0026rsquo;ve broken the steps of the algorithm in to separate functions. Once we\u0026rsquo;ve found our chosen direction, we turn towards it as much as possible (based on steer_force) and move.\nfunc _physics_process(delta):\rset_interest()\rset_danger()\rchoose_direction()\rvar desired_velocity = chosen_dir.rotated(rotation) * max_speed\rvelocity = velocity.linear_interpolate(desired_velocity, steer_force)\rrotation = velocity.angle()\rmove_and_collide(velocity * delta)\rNow we\u0026rsquo;ll go over the 3 functions that make up the algorithm. first, setting the interest array. As mentioned above, we\u0026rsquo;re going to ask the world (our owner in this case) to tell us which direction we should be trying to go.\nUsing each ray direction, we take the dot product with the given path direction. Recall that the dot product of two aligned vectors is 1 and for two perpendicular vectors it\u0026rsquo;s 0. We ignore negative values - 0 means we don\u0026rsquo;t want to go that way.\nFor example, with 32 rays, the interest would look like this:\nAs a safety measure, if there\u0026rsquo;s no owner to tell us a direction, we\u0026rsquo;ll default to trying to go forward.\nfunc set_interest():\r# Set interest in each slot based on world direction\r if owner and owner.has_method(\u0026#34;get_path_direction\u0026#34;):\rvar path_direction = owner.get_path_direction(position)\rfor i in num_rays:\rvar d = ray_directions[i].rotated(rotation).dot(path_direction)\rinterest[i] = max(0, d)\r# If no world path, use default interest\r else:\rset_default_interest()\rfunc set_default_interest():\r# Default to moving forward\r for i in num_rays:\rvar d = ray_directions[i].rotated(rotation).dot(transform.x)\rinterest[i] = max(0, d)\rNow we can populate the danger array. Using the Physics2DDirectSpaceState, we cast a ray in each direction. If there\u0026rsquo;s a hit, we add a 1 in that spot.\nfunc set_danger():\r# Cast rays to find danger directions\r var space_state = get_world_2d().direct_space_state\rfor i in num_rays:\rvar result = space_state.intersect_ray(position,\rposition + ray_directions[i].rotated(rotation) * look_ahead,\r[self])\rdanger[i] = 1.0 if result else 0.0\rFinally, we can use the context arrays to choose our direction. Looping through the danger array, zero the interest wherever there\u0026rsquo;s danger. Then, sum up and normalize the remaining interest vectors.\nfunc choose_direction():\r# Eliminate interest in slots with danger\r for i in num_rays:\rif danger[i] \u0026gt; 0.0:\rinterest[i] = 0.0\r# Choose direction based on remaining interest\r chosen_dir = Vector2.ZERO\rfor i in num_rays:\rchosen_dir += ray_directions[i] * interest[i]\rchosen_dir = chosen_dir.normalized()\rExample in Practice Let\u0026rsquo;s try it out in action! Here, we\u0026rsquo;ve created a track using a Path2D and some collision polygons.\nIn the script for this scene, we have a get_path_direction() function. Given a position, this function finds the closest point on the path and puts the PathFollow2D there in order to find the forward direction.\nfunc get_path_direction(pos):\rvar offset = path.curve.get_closest_offset(pos)\rpath_follow.offset = offset\rreturn path_follow.transform.x\rWe\u0026rsquo;ve randomized the speeds of the agents do get some variety. Notice how the fast one finds ways to dodge around the slow ones.\nWrapping up This method is very flexible and can be extended to produce a wide variety of complex-looking behaviors. It\nHere are some additional suggestions for adaptations/improvements:\n Levels of danger  When populating the danger array, don\u0026rsquo;t just use 0 or 1, but instead calculate a danger \u0026ldquo;score\u0026rdquo; based on the distance of the object. Then subtract that amount from the interest rather than removing it. Far away objects will have a small impact while close ones will have more.\n Avoidance  Rather than a danger item canceling the interest, it could add to the interest in the opposite direction.\nRelated recipes  Vectors: Using Dot and Cross Product  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/ui/debug_overlay/","title":"Displaying debug data","tags":[],"description":"","content":"Problem You need an easy way to display debug data on-screen.\nSolution We\u0026rsquo;ll create an overlay that any node can register a property with, and that property will be displayed in an appropriate format.\nHere\u0026rsquo;s an example of what we\u0026rsquo;re going for:\nStart by adding a MarginContainer named DebugStats with a VBoxContainer child. Set the margins to a comfortable value (I usually use 20).\nLet\u0026rsquo;s take a look at the code:\nextends MarginContainer\rclass Property:\rvar num_format = \u0026#34;%4.2f\u0026#34;\rvar object # The object being tracked.\r var property # The property to display (NodePath).\r var label_ref # A reference to the Label.\r var display # Display option (rounded, etc.)\r func _init(_object, _property, _label, _display):\robject = _object\rproperty = _property\rlabel_ref = _label\rdisplay = _display\rfunc set_label():\r# Sets the label\u0026#39;s text.\r var s = object.name + \u0026#34;/\u0026#34; + property + \u0026#34; : \u0026#34;\rvar p = object.get_indexed(property)\rmatch display:\r\u0026#34;\u0026#34;:\rs += str(p)\r\u0026#34;length\u0026#34;:\rs += num_format % p.length()\r\u0026#34;round\u0026#34;:\rmatch typeof(p):\rTYPE_INT, TYPE_REAL:\rs += num_format % p\rTYPE_VECTOR2, TYPE_VECTOR3:\rs += str(p.round())\rlabel_ref.text = s\rvar props = [] # An array of the tracked properties.\r func _process(_delta):\rif not visible:\rreturn\rfor prop in props:\rprop.set_label()\rWe begin with a custom class to encapsulate the data for the object and property we\u0026rsquo;re tracking. Let\u0026rsquo;s break down the class properties:\n object - This is a reference to the object we\u0026rsquo;re tracking. property - This is in the form of a NodePath, meaning we can track something like \u0026quot;position\u0026quot;, but also \u0026quot;position:x\u0026quot;. label_ref - Each property is linked to a Label node, this is a reference to the label so that we can set its text. display - This is an optional setting to configure how the value should be displayed (see below).  In the set_label() method we build up a string to display in the label\u0026rsquo;s text property. We include the object\u0026rsquo;s name and which property we\u0026rsquo;re showing, plus the value modified by the display option.\nFor this example, we\u0026rsquo;ve shown two settings for the display option:\n \u0026quot;length\u0026quot; - if the property is a vector, we\u0026rsquo;ll display its length. \u0026quot;round\u0026quot; - if the property is a numeric type, we\u0026rsquo;ll round its values.  We then need functions to add/remove properties from the display:\nfunc add_property(object, property, display):\rvar label = Label.new()\rlabel.set(\u0026#34;custom_fonts/font\u0026#34;, load(\u0026#34;res://debug/roboto_16.tres\u0026#34;))\r$Column.add_child(l)\rprops.append(Property.new(object, property, label, display))\rfunc remove_property(object, property):\rfor prop in props:\rif prop.object == object and prop.property == property:\rprops.erase(prop)\radd_property() can be called from any node (we should load the debug display as a singleton). This creates the label and registers the property object. Note that we\u0026rsquo;re loading a saved DynamicFont resource to use.\nAdding to game Now any node in the game can register/remove properties from the display like so:\nDebugOverlay.stats.add_property(self, \u0026#34;velocity\u0026#34;, \u0026#34;length\u0026#34;)\rDebugOverlay.stats.add_property(self, \u0026#34;transform:origin\u0026#34;, \u0026#34;round\u0026#34;)\rRelated recipes  Drawing Vectors in 3D  "},{"uri":"http://kidscancode.org/godot_recipes/3d/debug_overlay/","title":"Drawing Vectors in 3D","tags":[],"description":"","content":"Problem You\u0026rsquo;d like visual debug information in your 3D game: a way to see vectors representing velocity, position, etc.\nSolution Debug drawing in 2D is quite convenient. CanvasItem provides a range of primitive drawing methods to use in the _draw() callback. In 3D, things are not quite so simple. One solution is to use ImmediateGeometry to manually create meshes, but this is very cumbersome and inconvenient for quick debugging.\nA better solution is to stick with the CanvasItem draw methods. To do so, we need to project the positions in 3D space onto the 2D viewport. Fortunately, Camera can do this for us using its unproject_position() method.\nSetting up For the display layer, add a CanvasLayer containing a Control to your 3D scene and add a script to the Control.\nAs an example, let\u0026rsquo;s assume this drawing control has a reference to the player node, and we want to draw the node\u0026rsquo;s velocity vector. We also have a reference to the Camera node. More about how we\u0026rsquo;ll add those references later.\nvar player\rvar camera\rfunc _draw():\rvar color = Color(0, 1, 0)\rvar start = camera.unproject_position(player.global_transform.origin)\rvar end = camera.unproject_position(player.global_transform.origin + player.velocity)\rnode.draw_line(start, end, color, width)\rnode.draw_triangle(end, start.direction_to(end), width*2, color)\rfunc draw_triangle(pos, dir, size, color):\rvar a = pos + dir * size\rvar b = pos + dir.rotated(2*PI/3) * size\rvar c = pos + dir.rotated(4*PI/3) * size\rvar points = PoolVector2Array([a, b, c])\rdraw_polygon(points, PoolColorArray([color]))\rWe use unproject_position() to find the start and end points of the vector we want to draw. draw_triangle() is there to give us a nice pointed arrow appearance.\nEasy access from game objects Now let\u0026rsquo;s make this more functional. Your game might have many objects you want to draw debug vectors for. An enemy\u0026rsquo;s facing direction, an acceleration vector, a destination, etc. We need an easy way to register any object to the debug drawing layer.\nAdd the DebugOverlay as an autoload and set it as a singleton. This way we can access it from any node. Add this script to it:\nextends CanvasLayer\ronready var draw = $DebugDraw3D\rfunc _ready():\rif not InputMap.has_action(\u0026#34;toggle_debug\u0026#34;):\rInputMap.add_action(\u0026#34;toggle_debug\u0026#34;)\rvar ev = InputEventKey.new()\rev.scancode = KEY_BACKSLASH\rInputMap.action_add_event(\u0026#34;toggle_debug\u0026#34;, ev)\rfunc _input(event):\rif event.is_action_pressed(\u0026#34;toggle_debug\u0026#34;):\rfor n in get_children():\rn.visible = not n.visible\rI\u0026rsquo;ve included the code to add an input action to toggle visibility. This makes it convenient to drop this into any project without needing to edit the Input Map. We can now reference the drawing layer with DebugOverlay.draw.\nYou can add other debug layers here too. For example, one that displays properties as text. See LINK.\n\rWe\u0026rsquo;ll start by defining a custom object to hold all the information for the debug value we want to display.\nextends Control\rclass Vector:\rvar object # The node to follow\r var property # The property to draw\r var scale # Scale factor\r var width # Line width\r var color # Draw color\r func _init(_object, _property, _scale, _width, _color):\robject = _object\rvalue = _property\rscale = _scale\rwidth = _width\rcolor = _color\rfunc draw(node, camera):\rvar start = camera.unproject_position(object.global_transform.origin)\rvar end = camera.unproject_position(object.global_transform.origin + object.get(property) * scale)\rnode.draw_line(start, end, color, width)\rnode.draw_triangle(end, start.direction_to(end), width*2, color)\rvar vectors = [] # Array to hold all registered values.\r This object encapsulates all the functionality for each vector we want to display, including the drawing code we saw earlier. In _process(), we can then draw them, making sure to get the current active camera:\nfunc _process(delta):\rif not visible:\rreturn\rupdate()\rfunc _draw():\rvar camera = get_viewport().get_camera()\rfor vector in vectors:\rvector.draw(self, camera)\rAnd finally, we can add a function to register a new vector to follow:\nfunc add_vector(object, property, scale, width, color):\rvectors.append(Vector.new(object, property, scale, width, color))\rNow any object in the game can add a debug vector with the following:\nDebugOverlay.draw.add_vector(self, \u0026#34;velocity\u0026#34;, 1, 4, Color(0,1,0, 0.5))\rHere\u0026rsquo;s an example of an AI car displaying its raycasts and steering direction:\nRelated recipes  UI: Displaying debug data  "},{"uri":"http://kidscancode.org/godot_recipes/ui/unit_healthbar/","title":"Object Healthbars","tags":[],"description":"","content":"Problem You want units in your game to have healthbars that follow them as they move.\nSolution Displaying the bar can be done with a TextureProgress node. This is like the ProgressBar node, but allows the use of textures for the bar itself. The length of the bar will indicate the health value, but we can also change the texture color. We\u0026rsquo;ll use three colored bars for this:\nSo that this bar can be added to any unit in the game, we\u0026rsquo;ll make it a separate scene. Start with a Node2D and a TextureProgress child. Add a script to the root node.\nDrag the green bar into the TextureProgress Textures/Progress property and set its Value to 100. Drag the bar until it\u0026rsquo;s centered and above the origin.\nextends Node2D\rvar bar_red = preload(\u0026#34;res://assets/barHorizontal_red.png\u0026#34;)\rvar bar_green = preload(\u0026#34;res://assets/barHorizontal_green.png\u0026#34;)\rvar bar_yellow = preload(\u0026#34;res://assets/barHorizontal_yellow.png\u0026#34;)\ronready var healthbar = $HealthBar\rThe script starts by loading the three colored bars, which will change as the health decreases. We also store a reference to the progress bar.\nfunc _ready():\rhide()\rif get_parent() and get_parent().get(\u0026#34;max_health\u0026#34;):\rhealthbar.max_value = get_parent().max_health\rThe HealthDisplay should be attached to a unit. If the unit has a max_health property, we use that to set the range of the bar (it\u0026rsquo;s 100 by default). We also want the bar to start out hidden, and appear if the unit loses health.\nfunc _process(delta):\rglobal_rotation = 0\rThis prevents the bar from rotating. It will always remain on top of the unit it\u0026rsquo;s attached to.\nfunc update_healthbar(value):\rhealthbar.texture_progress = bar_green\rif value \u0026lt; healthbar.max_value * 0.7:\rhealthbar.texture_progress = bar_yellow\rif value \u0026lt; healthbar.max_value * 0.35:\rhealthbar.texture_progress = bar_red\rif value \u0026lt; healthbar.max_value:\rshow()\rhealthbar.value = value\rFinally, we have a function we can call when the unit\u0026rsquo;s health changes. It updates the value of the bar and sets the texture based on the remaining proportion.\nWhen you attach this to a unit, the bar may appear too big. Set the Scale property of the instanced HealthDisplay to adjust based on the size of your unit.\nHere\u0026rsquo;s an example of this system in use. You can download the example project for this below.\n\nDownload the project file here: tower_defense_demo.zip\n\r"},{"uri":"http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_11/","title":"Mobile ads","tags":[],"description":"","content":"About ads When building a free-to-play mobile game, you have two choices when it comes to monetization: in-app purchases and advertisement. In this part, we\u0026rsquo;ll look at how to integrate a mobile ad platform (Admob) into your game.\nAds can be unpopular and whether to use them is a decision for the individual game developer to make. We\u0026rsquo;re not making a decision on the pros and cons in this tutorial - we\u0026rsquo;re here to show you how to put ads in your game if you want them.\nSet up Admob Head over to Admob and create an account.\nIn the AdMob manager, create a new app - ours is titled \u0026ldquo;Circle Jump\u0026rdquo; - and specify the \u0026ldquo;Android\u0026rdquo; platform (we\u0026rsquo;ll discuss iOS later).\nIn the \u0026ldquo;Circle Jump\u0026rdquo; app, you\u0026rsquo;ll need to create three \u0026ldquo;Ad Units\u0026rdquo;. These are the types of ads that you can show in your game. For this tutorial, we\u0026rsquo;ll need a \u0026ldquo;Banner\u0026rdquo; and an \u0026ldquo;Interstitial\u0026rdquo;. Each ad unit will have an \u0026ldquo;Ad Unit ID\u0026rdquo;, a long string of characters - we\u0026rsquo;ll need that later in the game.\nUsing Godot modules Godot doesn\u0026rsquo;t include ad services by default, so it\u0026rsquo;s necessary to use an engine module, or plugin, to add that functionality. You can find the module we\u0026rsquo;ll be using here: godot-admob. On that page, you\u0026rsquo;ll see a list of the methods provided by the plugin.\nTo use a custom engine module, the engine has to be recompiled. In the case of mobile platforms, that means recompiling the export templates because the default ones we downloaded from Godot weren\u0026rsquo;t compiled with this module.\nCompiling export templates is not difficult, but it does require setting up a build environment on your computer - downloading the required programs and libraries needed to build Godot. If you\u0026rsquo;re new to this concept and interested in learning about it, see the Compiling section of the official docs.\nFortunately, we won\u0026rsquo;t need to compile custom export templates, because it\u0026rsquo;s already been done for us. Head over to the godot-custom-mobile-templates Github repo. Click on \u0026ldquo;Releases\u0026rdquo; and download the version of the export templates that matches your version of Godot.\nThe export template version must match the Godot editor version. If you\u0026rsquo;re using a custom-built editor, you will also have to build the templates from the same code branch.\n\rUnzip the templates somewhere on your computer (don\u0026rsquo;t put them in the Circle Jump project folder).\nConfiguring export Back in the Godot editor, we need to make some changes to the export configuration. First, open Project -\u0026gt; Project Settings and find the \u0026ldquo;Android\u0026rdquo; section. In the Modules property is where you list the module(s) you want to use in your code. The module name is listed on the godot-admob page: \u0026ldquo;org/godotengine/godot/GodotAdMob\u0026rdquo;. If you have more than one module, separate them with commas.\nIn the _Project -\u0026gt; Export_menu, we need to tell Godot to use the custom templates we downloaded. These are set in the \u0026ldquo;Custom Package\u0026rdquo; section. Click the folder icon and navigate to where you unzipped the templates. Make sure to add both the \u0026ldquo;Debug\u0026rdquo; and \u0026ldquo;Release\u0026rdquo; templates.\nCode Now when we run the game (on Android), it will load that module. It\u0026rsquo;s accessed via an engine singleton. Open settings.gd and add the following:\nvar admob = null\rvar real_ads = false\rvar banner_top = false\r# Fill these from your AdMob account:\r var ad_banner_id = \u0026#34;\u0026#34;\rvar ad_interstitial_id = \u0026#34;\u0026#34;\rvar enable_ads = true\rThese are our settings variables for the module. real_ads set to false puts us in \u0026ldquo;Test Ad\u0026rdquo; mode. You shouldn\u0026rsquo;t change this to true until you\u0026rsquo;re ready to release your game. banner_top toggles whether the banner ad should be shown at the top or bottom of the screen.\nad_banner_id and ad_interstitial_id should be filled with your ad unit values from your AdMob account.\nWe need to initialize the module:\nfunc _ready():\rif Engine.has_singleton(\u0026#34;AdMob\u0026#34;):\radmob = Engine.get_singleton(\u0026#34;AdMob\u0026#34;)\radmob.init(real_ads, get_instance_id())\radmob.loadBanner(ad_banner_id, banner_top)\radmob.loadInterstitial(ad_interstitial_id)\rWe first check that the module singleton exists. If it\u0026rsquo;s found, we can initialize the module and load the ad units.\nfunc show_ad_banner():\rif admob and enable_ads:\radmob.showBanner()\rfunc hide_ad_banner():\rif admob:\radmob.hideBanner()\rNext, we have functions to let us show/hide the banner. We only want it showing in the menu screens, not during actual gameplay.\nfunc show_ad_interstitial():\rif admob and enable_ads:\radmob.showInterstitial()\rWe\u0026rsquo;ll use this function to show the interstitial ad at the end of a game.\nfunc _on_interstitial_close():\rif admob and enable_ads:\rshow_ad_banner()\rThe module looks for this callback to run any code when the interstitial ad closes. Since we\u0026rsquo;ll be at the end of a game and going back to the menu, we\u0026rsquo;ll show the banner again.\nNow we need to call these functions from the game. Open Main.gd and add the following:\n In new_game(), add settings.hide_ad_banner(). At the end of _on_Jumper_died() add settings.show_ad_interstitial().  Run the game on your device, and you should see the test ad appear:\nDisabling ads Many games allow ads to be disabled, whether via in-app purchases, reaching a certain level, etc. In our case, we\u0026rsquo;ll add it as a button on the \u0026ldquo;Settings\u0026rdquo; screen.\nFirst, we\u0026rsquo;ll change the enable_ads to give it a setter function:\nvar enable_ads = true setget set_enable_ads\rAnd add the setter function:\nfunc set_enable_ads(value):\renable_ads = value\rif enable_ads:\rshow_ad_banner()\rif !enable_ads:\rhide_ad_banner()\rThis will cause the banner add to appear/disappear instantly when pressing the button.\nTo add the button, we\u0026rsquo;ll need a third row of buttons. Open the BaseScreen scene and duplicate the first HBoxContainer.\nIn the SettingsScreen scene add a Button called \u0026ldquo;Ads\u0026rdquo; to the middle row. Set its text to \u0026ldquo;Disable Ads\u0026rdquo;, its Custom Font (a size of 48 works well), and set its Custom Styles all to \u0026ldquo;New StyleBoxEmpty\u0026rdquo;. Don\u0026rsquo;t forget to add the button to the \u0026ldquo;buttons\u0026rdquo; group.\nIn Screens.gd, add the following to the match statement that processes the buttons:\nmatch button.name:\r\u0026#34;Ads\u0026#34;:\rsettings.enable_ads = !settings.enable_ads\rif settings.enable_ads:\rbutton.text = \u0026#34;Disable Ads\u0026#34;\relse:\rbutton.text = \u0026#34;Enable Ads\u0026#34;\rRun the game on your device and verify that you can enable/disable ads.\n Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "},{"uri":"http://kidscancode.org/godot_recipes/2d/multi_target_camera/","title":"Multitarget Camera","tags":[],"description":"","content":"Problem You need a dynamic camera that moves and zooms to keep multiple objects on screen at the same time.\nAn example might be in a 2 player game, keeping both players on-screen as they move farther and closer together, like so:\nSolution In a single-player game, you\u0026rsquo;re probably used to attaching the camera to the player, so that it automatically follows them. We can\u0026rsquo;t really do this here because we have 2 (or more) players or other game objects that we want to keep on the screen at all times.\nWe need our camera to do 3 things:\n Add/remove any number of targets. Keep the camera\u0026rsquo;s position centered at the midpoint of the targets. Adjust the camera\u0026rsquo;s zoom to keep all targets on screen.  Create a new scene with a Camera2D and attach a script. We\u0026rsquo;ll add this camera to our game once we\u0026rsquo;re done.\nLet\u0026rsquo;s break down how the script works.\nYou can see the full script at the end of the article.\n\rHere\u0026rsquo;s how the script starts:\nextends Camera2D export var move_speed = 0.5 # camera position lerp speed export var zoom_speed = 0.25 # camera zoom lerp speed export var min_zoom = 1.5 # camera won\u0026#39;t zoom closer than this export var max_zoom = 5 # camera won\u0026#39;t zoom farther than this export var margin = Vector2(400, 200) # include some buffer area around targets var targets = [] # Array of targets to be tracked. onready var screen_size = get_viewport_rect().size These settings will let you adjust the camera\u0026rsquo;s behavior. We\u0026rsquo;ll lerp() all camera changes, so making the move/zoom speeds low will introduce some delay in the camera \u0026ldquo;catching up\u0026rdquo; to sudden changes.\nMaximum and minimum zoom values will also depend on the size of objects in your game and how close or far you want to get.\nFinally, the margin property is going to add some extra space around the targets so they\u0026rsquo;re not right on the edge of the viewable area.\nLastly, we have our array of targets and we get the viewport size so that we can properly calculate the scale.\nfunc add_target(t): if not t in targets: targets.append(t) func remove_target(t): if t in targets: targets.remove(t) For adding and removing targets, we have two helper functions. You can use these during gameplay to change what targets are being tracked (\u0026ldquo;Player 3 has entered the game!\u0026quot;). Note that we don\u0026rsquo;t want to have the same target tracked twice, so we reject it if it\u0026rsquo;s already there.\nMost of the functionality happens in _process(). First, moving the camera:\nfunc _process(delta): if !targets: return # Keep the camera centered between the targets var p = Vector2.ZERO for target in targets: p += target.position p /= targets.size() position = lerp(position, p, move_speed) Here, we loop through the targets\u0026rsquo; positions and find the common center. Using lerp() we make sure it moves there smoothly.\nNext, we\u0026rsquo;ll handle the zoom:\n# Find the zoom that will contain all targets var r = Rect2(position, Vector2.ONE) for target in targets: r = r.expand(target.position) r = r.grow_individual(margin.x, margin.y, margin.x, margin.y) var d = max(r.size.x, r.size.y) var z if r.size.x \u0026gt; r.size.y * screen_size.aspect(): z = clamp(r.size.x / screen_size.x, min_zoom, max_zoom) else: z = clamp(r.size.y / screen_size.y, min_zoom, max_zoom) zoom = lerp(zoom, Vector2.ONE * z, zoom_speed) The key functionality here comes from Rect2. We want to find a rectangle that encloses all the targets, which we can get with the expand() method. We then grow the rect by the margin.\nHere you can see the rectangle being drawn (press \u0026ldquo;Tab\u0026rdquo; in the demo project to enable this drawing):\nThen, depending whether the rectangle is wider or taller (relative to the screen\u0026rsquo;s aspect ratio), we find the scale and clamp it in the max/min range we\u0026rsquo;ve defined.\nFull script extends Camera2D export var move_speed = 0.5 # camera position lerp speed export var zoom_speed = 0.25 # camera zoom lerp speed export var min_zoom = 1.5 # camera won\u0026#39;t zoom closer than this export var max_zoom = 5 # camera won\u0026#39;t zoom farther than this export var margin = Vector2(400, 200) # include some buffer area around targets var targets = [] # Array of targets to be tracked. onready var screen_size = get_viewport_rect().size func _process(delta): if !targets: return # Keep the camera centered between the targets var p = Vector2.ZERO for target in targets: p += target.position p /= targets.size() position = lerp(position, p, move_speed) # Find the zoom that will contain all targets var r = Rect2(position, Vector2.ONE) for target in targets: r = r.expand(target.position) r = r.grow_individual(margin.x, margin.y, margin.x, margin.y) var d = max(r.size.x, r.size.y) var z if r.size.x \u0026gt; r.size.y * screen_size.aspect(): z = clamp(r.size.x / screen_size.x, min_zoom, max_zoom) else: z = clamp(r.size.y / screen_size.y, min_zoom, max_zoom) zoom = lerp(zoom, Vector2.ONE * z, zoom_speed) func add_target(t): if not t in targets: targets.append(t) func remove_target(t): if t in targets: targets.remove(t) \rDownload the project file here: multitarget_camera2d.zip\n\rRelated recipes  Touchscreen Camera Splitscreen multiplayer  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/2d/ballistic_bullet/","title":"Ballistic bullet","tags":[],"description":"","content":"Problem You want a 2D bullet that travels in an arc, or ballistic curve.\nSolution One approach to this problem would be to use a RigidBody2D - with its built-in physics, gravity would automatically pull it back to earth after firing it.\nHowever, as mentioned in the 2D shooting recipe, Area2D is a great choice for simple bullets and other projectiles - when you don\u0026rsquo;t need collisions, bouncing, or other physics reactions. Ballistic motion is easy enough to calculate that we won\u0026rsquo;t need the help of the physics engine.\nSetting up the bullet - Bullet (Area2D)\r- Sprite\r- CollisionShape2D\rWe can use Area2D's gravity property. Set it to 150 for the initial test.\nextends Area2D\rvar velocity = Vector2(350, 0)\rfunc _process(delta):\rvelocity.y += gravity * delta\rposition += velocity * delta\rrotation = velocity.angle()\rfunc _on_BallisticBullet_body_entered(body):\rqueue_free()\rUsing the standard equations of motion is all we need to do here. The initial value for velocity is just for testing. Run the bullet scene:\nNow in your object that\u0026rsquo;s doing the shooting, you can instance the bullet and set its initial properties. Put this in whatever function/input handles shooting:\nexport var muzzle_velocity = 350\rexport var gravity = 250\rfunc shoot():\rvar b = Bullet.instance()\rowner.add_child(b)\rb.transform = $Barrel/Position2D.global_transform\rb.velocity = b.transform.x * muzzle_velocity\rb.gravity = gravity\rHere\u0026rsquo;s an example in action:\nRelated recipes  2D shooting recipe 2D: Draw trajectory  "},{"uri":"http://kidscancode.org/godot_recipes/3d/click_to_move/","title":"Click to move","tags":[],"description":"","content":"Problem You want to move a 3D object to a clicked position.\nSolution We\u0026rsquo;ll start with a flat plane for our world. Our actor will move on this plane.\nThe actor for this demo is a triangular prism mesh:\nHere is the code for the movement. If given a target, the object will turn and move toward it.\nextends KinematicBody\rexport var speed = 5\rexport var gravity = -5\rvar target = null\rvar velocity = Vector3.ZERO\rfunc _physics_process(delta):\rvelocity.y += gravity * delta\rif target:\rlook_at(target, Vector3.UP)\rrotation.x = 0\rvelocity = -transform.basis.z * speed\rif transform.origin.distance_to(target) \u0026lt; .5:\rtarget = null\rvelocity = Vector3.ZERO\rvelocity = move_and_slide(velocity, Vector3.UP)\rWe\u0026rsquo;ve also added a MeshInstance called \u0026ldquo;Marker\u0026rdquo; to the scene. This will be moved to indicate the clicked position.\nMouse -\u0026gt; 3D Now we need a way to map mouse position into our 3D world. If you imagine the screen as a window into the 3D world, the mouse is trapped on the glass. To select something in 3D, we must project a ray from our eye (the camera), through the mouse\u0026rsquo;s position and into the world.\nWhile this can be done manually using The Camera\u0026rsquo;s project_ray methods, we can take advantage of the fact that CollisionObject nodes do this automatically. All we need to do is connect our StaticBody' ground's input_event` signal:\nfunc _on_StaticBody_input_event(camera, event, click_position, click_normal, shape_idx):\rif event is InputEventMouseButton and event.pressed:\r$Marker.transform.origin = click_position\r$Player.target = click_position\rWe set the position of the marker and the Player\u0026rsquo;s target to the clicked position:\nWrapping up You can use this technique to detect clicks on any objects in your 3D world.\nDownload the project file here: 3d_click_move.zip\n\rRelated recipes Like video? "},{"uri":"http://kidscancode.org/godot_recipes/ui/floating_text/","title":"Floating combat text","tags":[],"description":"","content":"Problem You want units to display damage as floating numbers when hit.\nSolution There are many ways to approach this problem. For example, you could use a bitmap font and build an image for each number out of its digits, then use a Sprite node to display and move it.\nHowever, for this recipe, we\u0026rsquo;ll use a Label node (named \u0026ldquo;FCT\u0026rdquo;). This will give us the flexibility to change the font, as well as making it easy to display the number as a string - or even other messages such as \u0026ldquo;miss\u0026rdquo;.\nStart with a Label node and add a Tween child. We\u0026rsquo;ll use the Tween to animate the movement and the fade-out effect.\nSet the Label\u0026rsquo;s Custom Fonts/Font property using your favorite font. In this example, we\u0026rsquo;re using \u0026ldquo;Xolonium.ttf\u0026rdquo; with a font size of 28 and a black outline of 1 pixel. In the menu select \u0026ldquo;Layout-\u0026gt;Center\u0026rdquo;, and also set Align and Valign to \u0026ldquo;Center\u0026rdquo;.\nAdd a script to the Label.\nextends Label\rfunc show_value(value, travel, duration, spread, crit=false):\rWhen we spawn the floating text, we\u0026rsquo;ll call this function to set the parameters:\n value - the number (or string) to display travel - a Vector2 representing the direction of travel duration - how long the text will last spread - movement will be randomly spread across this arc crit - if true, indicates the damage was a \u0026ldquo;critical\u0026rdquo; hit  Here\u0026rsquo;s what the function does:\ntext = value\rvar movement = travel.rotated(rand_range(-spread/2, spread/2))\rrect_pivot_offset = rect_size / 2\rFirst, assign the value and randomize the movement based on the given spread (+/-90 degrees, for example). Since we may also be animating the scale, we set the rect_pivot_offset to the center of the control so that it will scale from the center.\n$Tween.interpolate_property(self, \u0026#34;rect_position\u0026#34;,\rrect_position, rect_position + movement,\rduration, Tween.TRANS_LINEAR, Tween.EASE_IN_OUT)\r$Tween.interpolate_property(self, \u0026#34;modulate:a\u0026#34;,\r1.0, 0.0, duration,\rTween.TRANS_LINEAR, Tween.EASE_IN_OUT)\rNext, we have two properties to interpolate: rect_position for the movement and modulate.a for the visibility.\nif crit:\rmodulate = Color(1, 0, 0)\r$Tween.interpolate_property(self, \u0026#34;rect_scale\u0026#34;,\rrect_scale*2, rect_scale,\r0.4, Tween.TRANS_BACK, Tween.EASE_IN)\rIf the hit is a critical, we\u0026rsquo;ll also change the color and animate the scale for a bigger effect. Note, I\u0026rsquo;ve hardcoded this to be red, but you should probably make this a configurable value.\n$Tween.start()\ryield($Tween, \u0026#34;tween_all_completed\u0026#34;)\rqueue_free()\rFinally, we start the Tween and wait for it to finish, then remove the Label.\nFloating text manager Next we\u0026rsquo;ll crate a small node to manage placing and spawning the floating text. This node will be attached to the game entities that you want to display floating text effects.\nThis is a Node2D named \u0026ldquo;FCTManager\u0026rdquo;. It contains the following script:\nextends Node2D\rvar FCT = preload(\u0026#34;res://FCT.tscn\u0026#34;)\rexport var travel = Vector2(0, -80)\rexport var duration = 2\rexport var spread = PI/2\rfunc show_value(value, crit=false):\rvar fct = FCT.instance()\radd_child(fct)\rfct.show_value(str(value), travel, duration, spread, crit)\rHere you can expose the settings to the Inspector for convenient changes. The show_value() method here spawns the floating labels and sets their properties.\nIn your game unit, you\u0026rsquo;d attach an instance of this node, and position it wherever you want the text to appear. Then add something like the following to the unit\u0026rsquo;s take_damage() method:\n$FCTManager.show_value(dmg, crit)\rWrapping up Optimization: in the case where you have a very large number of enemies/bullets, you may experience some performance impact from repeatedly spawning and freeing floating text. In this case, you can spawn a fixed number of text objects in the manager, and show/hide them rather than freeing them at the end of the animation.\nDownload the project file here: floating_text.zip\n\rArt in this demo by Luis Zuno\n\rRelated recipes  UI: Labels UI: Object Healthbars  Like video? "},{"uri":"http://kidscancode.org/godot_recipes/ui/minimap/","title":"Minimap/radar","tags":[],"description":"","content":"Problem You want a minimap or radar-style UI item showing the locations of objects outside of the player\u0026rsquo;s view.\nSolution Here\u0026rsquo;s an example of what we are going for: \nProject setup To illustrate this feature, we\u0026rsquo;ll start with a simplified top-down game using the Autotile recipe and a player based on the Top-down character recipe. See the linked recipes for details on how these parts work.\nThe art in this project comes from kenney.nl, which you can download here: Topdown Shooter and Interface Pack.\n\rOur main scene setup looks like this:\nThe CanvasLayer node is there to hold our UI, including the minimap/radar we\u0026rsquo;re making in this recipe.\nUI Layout The first step will be to create the layout for the minimap. In order to work with whatever other UI elements exist in the game, it must resize smoothly, and integrate well with a container-based layout.\nAdd a MarginContainer first. Set its Custom Constants all to 5. This control will hold the rest of the nodes and ensure it doesn\u0026rsquo;t bleed over into any other elements. Name it \u0026ldquo;MiniMap\u0026rdquo; and save the scene.\nNext, add a NinePatchRect node. This node is similar to a TextureRect but handles resizing differently by not stretching the corners/edges. Drop the panel_woodDetail_blank.png image from the asset folder into the Texture property. This is a 128x128 image and if we scale the root MarginContainer, the image becomes stretched and ugly:\nUsing the NinePatchRects's properties, we can ensure that the frame remains the same size when stretched. You can define these properties graphically in the \u0026ldquo;TextureRegion\u0026rdquo; panel, but it\u0026rsquo;s sometimes easier to enter the values directly. Set all four properties in the Patch Margin section to 64 and change the node\u0026rsquo;s name to \u0026ldquo;Frame\u0026rdquo;.\nNow observe what happens when we change the size:\nNext, we\u0026rsquo;d like to fill in the inner part of the frame with the grid pattern pattern_blueprintPaper.png:\nHowever, we need it to tile automatically no matter what size we make the frame. Also, since this grid area is where our minimap markers will appear, we don\u0026rsquo;t want the grid extending past the edges of the frame.\nAs a child of the MiniMap (and a sibling of the Frame), add another MarginContainer. Set all four margin properties in Custom Constants to 20. As a child of this node, add a TextureRect and assign its Texture to the above image. Set its Stretch Mode to \u0026ldquo;Tile\u0026rdquo;. Name this node \u0026ldquo;Grid\u0026rdquo;.\nTry changing the size of your root node to see the effect:\nFor now, let\u0026rsquo;s leave the minimap\u0026rsquo;s size at (200, 200) - you can check the root node\u0026rsquo;s Rect/Size property to confirm.\nAt this point, your scene tree should look like the following:\nMap Markers As a child of Grid, add a Sprite node named \u0026ldquo;PlayerMarker\u0026rdquo; and give it the minimapIcon_arrowA.png texture. Note the sprite\u0026rsquo;s Transform/Position property: (0, 0), which places it exactly in the top-left corner of the Grid:\nIf our Grid size is currently (150, 150) (you can check this in its Rect/Size property), then its center will be (75, 75). Put the PlayerMarker's Position there:\nDon\u0026rsquo;t worry, we\u0026rsquo;ll automate this later.\nAdd two more Sprite nodes: \u0026ldquo;MobMarker\u0026rdquo; and \u0026ldquo;AlertMarker\u0026rdquo;, using the minimapIcon_jewelRed.png and minimapIcon_exclamationYellow.png textures.\nThese will represent two different types of objects in the game world. Click the \u0026ldquo;Toggle Visibility\u0026rdquo; button next to each so that they won\u0026rsquo;t appear by default.\nScripting the map markers At this point, we have some decisions to make. How we approach populating the minimap with the objects in the world has a lot to do with how the game is set up. Since this is a very minimal demonstration project, we\u0026rsquo;re going keep the process simple. In a larger game, you may need to use a more robust approach.\nFor this demo, we have two game objects: a Mob, which wanders around the map randomly, and a Crate, which the player can pick up. Many of these are scattered around the main scene. Each will need to be represented by one of the map markers we made.\nAdd each item that you want to appear on the minimap to a group named \u0026ldquo;minimap_objects\u0026rdquo;. In each object\u0026rsquo;s script, assign it a minimap_icon property:\n# In the mob\u0026#39;s script:\r var minimap_icon = \u0026#34;mob\u0026#34;\r# In the crate\u0026#39;s script:\r var minimap_icon = \u0026#34;alert\u0026#34;\rNow we can begin adding a script to the MiniMap. First, a player reference that can be assigned in the Inspector when the minimap is added to the main scene and a zoom property to calibrate the scale - how far the minimap can \u0026ldquo;see\u0026rdquo;. We also have some onready variables to make it more convenient to access the nodes we need.\nextends MarginContainer\rexport (NodePath) var player\rexport var zoom = 1.5\ronready var grid = $MarginContainer/Grid\ronready var player_marker = $MarginContainer/Grid/PlayerMarker\ronready var mob_marker = $MarginContainer/Grid/MobMarker\ronready var alert_marker = $MarginContainer/Grid/AlertMarker\rNext, we\u0026rsquo;ll use a dictionary to map the minimap_icon tags we gave our units to the corresponding marker:\nonready var icons = {\u0026#34;mob\u0026#34;: mob_marker, \u0026#34;alert\u0026#34;: alert_marker}\rThen we need a variable to hold the calculated ratio of map size to world size. We\u0026rsquo;ll use another dictionary to assign active markers to each object. The key will be the object (ie the Mob or Crate instance) and the value the assigned marker.\nvar grid_scale\rvar markers = {}\rIn _ready() we\u0026rsquo;ll center the player\u0026rsquo;s marker at the center of the grid. and calculate the scale factor. (Note: you should connect the resized signal and do both of these things in the callback if you have a dynamically sized UI).\nfunc _ready():\rplayer_marker.position = grid.rect_size / 2\rgrid_scale = grid.rect_size / (get_viewport_rect().size * zoom)\rWe\u0026rsquo;ll also create markers for every game object (using the \u0026ldquo;minimap_objects\u0026rdquo; group) by duplicating the matching marker node and tying the marker to the object via the markers dictionary:\nvar map_objects = get_tree().get_nodes_in_group(\u0026#34;minimap_objects\u0026#34;)\rfor item in map_objects:\rvar new_marker = icons[item.minimap_icon].duplicate()\rgrid.add_child(new_marker)\rnew_marker.show()\rmarkers[item] = new_marker\rNow that we have created the markers and linked each one to an object, we can update their positions in _process(). If no player is assigned, we\u0026rsquo;ll do nothing:\nfunc _process(delta):\rif !player:\rreturn\rIf there is a player, we\u0026rsquo;ll first rotate the player marker to match the player\u0026rsquo;s heading. Since our PlayerMarker sprite points upwards rather than along the x axis, we must add 90 degrees:\nplayer_marker.rotation = get_node(player).rotation + PI/2\rNext, we\u0026rsquo;ll find each object\u0026rsquo;s position relative to the player and use that to find the marker\u0026rsquo;s position (remembering to offset by grid.rect_size / 2 because the control\u0026rsquo;s origin is in the top left corner).\nfor item in markers:\rvar obj_pos = (item.position - get_node(player).position) * grid_scale + grid.rect_size / 2\rmarkers[item].position = obj_pos\rThe problem with this is that markers can be placed outside the grid:\nTo fix this, after calculating obj_pos, but before setting the marker\u0026rsquo;s position, clamp it to the grid\u0026rsquo;s rectangle:\nobj_pos.x = clamp(obj_pos.x, 0, grid.rect_size.x)\robj_pos.y = clamp(obj_pos.y, 0, grid.rect_size.y)\rNext, we can decide what to do about markers that are \u0026ldquo;off-screen\u0026rdquo; - when they would be outside the grid\u0026rsquo;s rectangle. Choose one of the following options (do this also before using clamp()). The first option is to hide them:\nif grid.get_rect().has_point(obj_pos + grid.rect_position):\rmarkers[item].hide()\relse:\rmarkers[item].show()\rThe second is to change their appearance, in this case we\u0026rsquo;ll make them smaller to show they\u0026rsquo;re at a farther distance:\nif grid.get_rect().has_point(obj_pos + grid.rect_position):\rmarkers[item].scale = Vector2(0.75, 0.75)\relse:\rmarkers[item].scale = Vector2(1, 1)\rRemoving objects If a mob gets killed or a crate picked up, the game will crash because the marker reference is no longer valid. We need a way to ensure markers are removed when the object is. Here\u0026rsquo;s a quick way to do this in our rudimentary demo setup:\nAdd signal removed to any object that you\u0026rsquo;ve put in the \u0026ldquo;minimap_objects\u0026rdquo; group. Emit this signal when the object is destroyed, along with a reference to itself so the map can identify it:\nemit_signal(\u0026#34;removed\u0026#34;, self)\rIn the _ready() of the main script, connect these signals to the minimap:\nfunc _ready():\rfor object in get_tree().get_nodes_in_group(\u0026#34;minimap_objects\u0026#34;):\robject.connect(\u0026#34;removed\u0026#34;, $CanvasLayer/MiniMap, \u0026#34;_on_object_removed\u0026#34;)\rNow add the receiving function to the minimap script to free the marker and remove the reference:\nfunc _on_object_removed(object):\rif object in markers:\rmarkers[object].queue_free()\rmarkers.erase(object)\rAdjusting zoom If you\u0026rsquo;ve stuck with it this far, we have one more feature to add: adjustable zoom level. With this, scrolling the mouse wheel when hovering over the map will zoom its scale in and out.\nFirst, add a setget to the zoom property:\nexport var zoom = 1.5 setget set_zoom\rfunc set_zoom(value):\rzoom = clamp(value, 0.5, 5)\rgrid_scale = grid.rect_size / (get_viewport_rect().size * zoom)\rOn the MiniMap node, connect the _gui_input signal in the Inspector so we can process the scroll wheel events:\nfunc _on_MiniMap_gui_input(event):\rif event is InputEventMouseButton and event.pressed:\rif event.button_index == BUTTON_WHEEL_UP:\rself.zoom += 0.1\rif event.button_index == BUTTON_WHEEL_DOWN:\rself.zoom -= 0.1\rThat\u0026rsquo;s it - observe the effect of scrolling in and out:\nWrapping up While this is a pretty big recipe, I\u0026rsquo;ve tried to make it flexible enough for you to incorporate into whatever project you\u0026rsquo;re working on.\nSome other things you might want to add:\n More marker types for different game objects. Adding new units when they\u0026rsquo;re spawned (hint: use a signal just like we did for removing units). Clicking on a marker to get info about it. Use a picture of your map as the minimap background instead of the grid.  Download the project file here: minimap.zip\n\rRelated recipes  UI: Containers TileMap: using autotile Top-down character  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/games/circle_jump/circle_jump_12/","title":"Saving settings","tags":[],"description":"","content":"Saving settings We\u0026rsquo;ve added three toggle properties in the game - which works fine - but the settings aren\u0026rsquo;t preserved when we quit. We need to save those settings so the next time you run the game, they persist.\nFirst, we\u0026rsquo;ll define our settings file in res://settings.gd:\nvar settings_file = \u0026#34;user://settings.save\u0026#34;\rNext, we\u0026rsquo;ll add saving/loading functions for the three game settings that we want to save.\nfunc save_settings():\rvar f = File.new()\rf.open(settings_file, File.WRITE)\rf.store_var(enable_sound)\rf.store_var(enable_music)\rf.store_var(enable_ads)\rf.close()\rfunc load_settings():\rvar f = File.new()\rif f.file_exists(settings_file):\rf.open(settings_file, File.READ)\renable_sound = f.get_var()\renable_music = f.get_var()\rself.enable_ads = f.get_var()\rf.close()\rCall load_settings() in _ready() and save_settings() at the end of set_enable_ads(). Also, in Screens.gd we need to save the state when the sound/music settings change, so add settings.save_settings() in each of those parts of the match statement.\nAnother problem we\u0026rsquo;ll have is when the game starts, the icons in the settings menu won\u0026rsquo;t reflect the state that we just loaded from the save file. We can set that in register_buttons() which is already looping through all buttons to connect their signals:\nfor button in buttons:\rbutton.connect(\u0026#34;pressed\u0026#34;, self, \u0026#34;_on_button_pressed\u0026#34;, [button])\rmatch button.name:\r\u0026#34;Ads\u0026#34;:\rif settings.enable_ads:\rbutton.text = \u0026#34;Disable Ads\u0026#34;\relse:\rbutton.text = \u0026#34;Enable Ads\u0026#34;\r\u0026#34;Sound\u0026#34;:\rbutton.texture_normal = sound_buttons[settings.enable_sound]\r\u0026#34;Music\u0026#34;:\rbutton.texture_normal = music_buttons[settings.enable_music]\rAbout screen The other thing we\u0026rsquo;ll add in this part is an \u0026ldquo;About\u0026rdquo; screen. This is where we\u0026rsquo;ll let the player know what the game\u0026rsquo;s all about and link to its license and to this page, since it is a tutorial game.\nComplying with license terms is very important. You can find out what\u0026rsquo;s required by Godot here: Complying with Licenses. Note that the art you\u0026rsquo;re using may also require credit, links, or other acknowledgement.\n\rTo reach it, we\u0026rsquo;ve added a new button on the \u0026ldquo;Title\u0026rdquo; screen:\nThe button is setup just like the others - add it to the \u0026ldquo;buttons\u0026rdquo; group so that it will get registered. In the Screens.gd, add another match for this button\u0026rsquo;s name:\n\u0026#34;About\u0026#34;:\rchange_screen($AboutScreen)\rHere\u0026rsquo;s what the \u0026ldquo;About\u0026rdquo; screen looks like:\nExtending \u0026ldquo;BaseScreen.tscn\u0026rdquo;, we\u0026rsquo;ve added a TextEdit and another container for a single \u0026ldquo;Home\u0026rdquo; button.\nIn the TextEdit, set BBCode enabled and put the following in the Text property:\n[center][u]Circle Jump[/u]\r[img]res://assets/images/godot_logo.png[/img][/center]\rCircle Jump is an open source tutorial game made with the Godot Game Engine. You can find the tutorial and the game\u0026#39;s source code here:\r[url=https://github.com/kidscancode/circle_jump]Circle Jump Source[/url]\rCopyright © 2019 KidsCanCode\r[url=https://github.com/kidscancode/circle_jump/blob/master/LICENSE]License Information[/url]\r\rSee BBCode in RichTextLabel for details on how BBCode formatting works.\n\rTo allow clicking on URLs, connect the meta_clicked signal of the TextEdit:\nfunc _on_TextEdit_meta_clicked(meta):\rOS.shell_open(meta)\r Follow this project on Github: https://github.com/kidscancode/circle_jump\nDo you prefer video?   "},{"uri":"http://kidscancode.org/godot_recipes/3d/rotate_interpolate/","title":"Smooth rotation","tags":[],"description":"","content":"Problem You want to smoothly rotate a 3D object to point in a new direction.\nSolution When you first encounter this problem, you may find yourself thinking in terms of Euler angles - the three values representing the angles to the x/y/z axes. While Godot will allow you to see the object\u0026rsquo;s Euler angles in the rotation property, it is not recommended to use them to work in 3D. There are a number of reasons why this the case, such as a problem called \u0026ldquo;gimbal lock\u0026rdquo;, where you lose one degree of freedom when one of your rotations reaches 90 degrees.\nIf you\u0026rsquo;re interested in the background behind Euler angles and the problems they introduce, like gimbal lock, here\u0026rsquo;s a video that explains it well.\n\rWe can avoid using 3D Euler angles in Godot by using the object\u0026rsquo;s Transform property. This property represents the body\u0026rsquo;s position and orientation in space. It uses a mathematical construct called a matrix to do this, but you don\u0026rsquo;t really need to understand the underlying math in order to make use of it.\nlook_at() Let\u0026rsquo;s say we have a 3D object such as a missile or arrow and you want it to point at its target. Wecan do this using the Spatial method look_at():\nfunc _process(delta):\rvar target_position = $Target.transform.origin\r$Arrow.look_at(target_position, Vector3.UP)\rThis code would make our node ($Arrow) always point at the target\u0026rsquo;s position, no matter how it moves.\nNote that look_at() requires 2 parameters: the target position, and an \u0026ldquo;up vector\u0026rdquo;. Imagine an airplane pointing its nose towards a target - there are an infinite number of ways it could be oriented, because the plane could roll about its axis. This second parameter is how you define what you want the final orientation to be.\nSmooth rotation The above code works, but it snaps the rotation instantly to the target. This might be fine if you have a very slow-moving target, but looks unnatural. It would look better if we move smoothly, or \u0026ldquo;interpolated\u0026rdquo;, the rotation smoothly between the starting orientation and the ending.\nGodot has us covered here too, because the Transform object has a method called interpolate_with(), which returns an intermediate transform between a current one and a target one.\nvar speed = 5\rfunc _process(delta):\rvar target_position = $Target.transform.origin\rvar new_transform = $Arrow.transform.looking_at(target_position, Vector3.UP)\r$Arrow.transform = $Arrow.transform.interpolate_with(new_transform, speed * delta)\rNote that since interpolate_with() operates on the transform, it can be used to interpolate both rotation and position of an object.\nWrapping up That\u0026rsquo;s it! Use this handy method to rotate your 3D objects, and stop thinking about angles!\nDownload the project file here: 3d_rotate.zip\n\rRelated recipes  Gamedev Math: Transforms Gamedev Math: Interpolation Camera Gimbal  Like video? "},{"uri":"http://kidscancode.org/godot_recipes/2d/touchscreen_camera/","title":"Touchscreen Camera","tags":[],"description":"","content":"Problem You need a touch-controlled 2D camera for your mobile game.\nSolution In this recipe, we\u0026rsquo;ll create a generic 2D camera with multiple touch controls:\n Drag to pan Pinch to zoom  Setup Our camera will extend the built-in node, so add a Camera2D to a new scene and name it \u0026ldquo;TouchCamera\u0026rdquo;. Save and attach a script.\nHere are the variables we\u0026rsquo;ll need:\nextends Camera2D\rexport (NodePath) var target\r# Optional: export these properties for convenient editing.\r var target_return_enabled = true\rvar target_return_rate = 0.02\rvar min_zoom = 0.5\rvar max_zoom = 2\rvar zoom_sensitivity = 10\rvar zoom_speed = 0.05\rvar events = {}\rvar last_drag_distance = 0\rIf a target is assigned, then the camera can follow and/or automatically return to it. The other properties that control how the camera works:\n target_return_enabled - If this is true, the camera will automatically return to the target after dragging. target_return_rate - Controls how fast the camera returns to its target. min_zoom / max_zoom - Limits how far you can zoom in/out. zoom_sensitivity - Sets how sensitive pinch-to-zoom will be - it\u0026rsquo;s the number of pixels\u0026rsquo; movement needed to \u0026ldquo;start\u0026rdquo; a zoom. zoom_speed - Used to smooth the zooming.  You can export these properties as well, if you\u0026rsquo;d like to be able to adjust them in the Inspector.\nThe other variables track the state of the camera. events is a dictionary that will hold the active touchscreen events, using the event\u0026rsquo;s index as its key. last_drag_distance keeps track of the distance between the two drag events in a \u0026ldquo;pinch\u0026rdquo; gesture.\nIn the _process() function, we\u0026rsquo;ll move the camera towards the target (if target return is enabled and there\u0026rsquo;s no touch event active).\nfunc _process(delta):\rif target and target_return_enabled and events.size() == 0:\rposition = lerp(position, get_node(target).position, target_return_rate)\rThis will allow us to pan the camera around and it will return to the player when we release the touch.\nNow we\u0026rsquo;re ready to start adding the gestures, starting with \u0026ldquo;pan\u0026rdquo;.\nPan You can test this gesture your computer by enabling \u0026ldquo;Emulate Touch From Mouse\u0026rdquo; in Project Settings -\u0026gt; Input Devices -\u0026gt; Pointing.\n\rJust like mouse or keyboard events, touch events extend InputEvent and follow the same input priority. We\u0026rsquo;ll use _unhandled_input() for processing so that other nodes, such as Control nodes, can process events first:\nfunc _unhandled_input(event):\rif event is InputEventScreenTouch:\rif event.pressed:\revents[event.index] = event\relse:\revents.erase(event.index)\rFirst we\u0026rsquo;re checking for a touch event (InputEventScreenTouch). We add the event to the events dictionary. The event\u0026rsquo;s index property is our dictionary\u0026rsquo;s key. We also remove the event if it\u0026rsquo;s not pressed, which means the touch has ended.\nNext, we need to handle a drag that comes after the touch:\nif event is InputEventScreenDrag:\revents[event.index] = event\rif events.size() == 1:\rposition += event.relative * zoom.x\rIf we get a drag event, we also add to the dictionary. Note that this will be updating the value - index 0 was already there from the first touch event, for example, and has now become a drag event.\nIf there\u0026rsquo;s only one event active, then this must be a one-finger drag, and we can adjust our camera\u0026rsquo;s position accordingly. Note that we need to scale the movement based on the current zoom, or else our drag movement will be disproportionately large when zoomed in and small when zoomed out.\nHere\u0026rsquo;s an example captured directly from a mobile device. The yellow circle indicates the touch location.\n\nZoom You won\u0026rsquo;t be able to test this gesture on your computer because it requires 2 touch events, which the mouse can\u0026rsquo;t emulate.\n\rA \u0026ldquo;pinch\u0026rdquo; gesture will trigger the camera to zoom. This happens when we detect two drag events. If the drag events move toward each other, we\u0026rsquo;ll zoom in; away from each other, we\u0026rsquo;ll zoom out.\nif event is InputEventScreenDrag:\revents[event.index] = event\rif events.size() == 1:\rposition += event.relative * zoom.x\relif events.size() == 2:\rvar drag_distance = events[0].position.distance_to(events[1].position)\rif abs(drag_distance - last_drag_distance) \u0026gt; zoom_sensitivity:\rvar new_zoom = (1 + zoom_speed) if drag_distance \u0026lt; last_drag_distance else (1 - zoom_speed)\rnew_zoom = clamp(zoom.x * new_zoom, min_zoom, max_zoom)\rzoom = Vector2.ONE * new_zoom\rlast_drag_distance = drag_distance\rHere we handle the case of 2 active drag events. drag_distance tells us how far apart they are, and we can compare it with last_drag_distance to see if it\u0026rsquo;s larger or smaller. zoom_speed is a factor, so we\u0026rsquo;ll be multiplying the zoom by 1.05 (for zooming in) and 0.95 (for zooming out). We can then clamp the resulting zoom so that it doesn\u0026rsquo;t exceed our designated limits, and then assign the new zoom level. Finally, we update last_drag_distance for the next event.\n\nWrapping up You can use this camera as a basis for your own camera needs. Here are some suggestions you can try to make yourself:\n Use lerp() to smooth the zooming. Automatically return zoom to default level. Double-tap to reset. Add more gestures -three fingers, etc.  For completeness, here\u0026rsquo;s the full TouchCamera.gd script:\nextends Camera2D\rexport (NodePath) var target\rvar target_return_enabled = true\rvar target_return_rate = 0.02\rvar min_zoom = 0.5\rvar max_zoom = 2\rvar zoom_sensitivity = 10\rvar zoom_speed = 0.05\rvar events = {}\rvar last_drag_distance = 0\rfunc _process(delta):\rif target and target_return_enabled and events.size() == 0:\rposition = lerp(position, get_node(target).position, target_return_rate)\rfunc _unhandled_input(event):\rif event is InputEventScreenTouch:\rif event.pressed:\revents[event.index] = event\relse:\revents.erase(event.index)\rif event is InputEventScreenDrag:\revents[event.index] = event\rif events.size() == 1:\rposition += event.relative * zoom.x\relif events.size() == 2:\rvar drag_distance = events[0].position.distance_to(events[1].position)\rif abs(drag_distance - last_drag_distance) \u0026gt; zoom_sensitivity:\rvar new_zoom = (1 + zoom_speed) if drag_distance \u0026lt; last_drag_distance else (1 - zoom_speed)\rnew_zoom = clamp(zoom.x * new_zoom, min_zoom, max_zoom)\rzoom = Vector2.ONE * new_zoom\rlast_drag_distance = drag_distance\r\rDownload the project file here: 2d_touch_camera.zip\n\rRelated recipes  Input: Input Actions Drag-select multiple units  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/math/dot_cross_product/","title":"Vectors: Using Dot and Cross Product","tags":[],"description":"","content":"Problem You\u0026rsquo;d like to understand what is meant by dot product and cross product.\nSolution In this recipe we\u0026rsquo;ll introduce the concept of vector dot product and cross product and how they might be used.\nDot product Dot product is an operation on two vectors that returns a scalar. It is often visualized as the projection of vector A onto vector B:\nThis is the formula for calculating the dot product:\nWhere θ is the angle between the two vectors and ||A|| is the magnitude of A.\nThis is very useful when both vectors are normalized (i.e. their magnitudes are 1), then the formula simplifies to:\nThis shows that the dot product is directly related to the angle between the two vectors. Since cos(0) == 1 and cos(180) == -1, the result of the dot product can tell you how closely aligned two vectors are:\nSee below for how we can apply this fact in a practical example.\nCross product The cross product of two vectors is a third vector that is perpendicular to both of them. Its magnitude is related to their magnitudes and the angle between them.\nOnce again, if we\u0026rsquo;re using normalized vectors, the result is simplified: it will be directly related to the angle and its magnitude will range from -1 to 1.\nSince the cross product is perpendicular to both vectors, we would need to be working in 3D. In most 2D frameworks, including Godot, the 2D Vector2.cross() method returns a scalar value representing the result\u0026rsquo;s magnitude.\n\rPractical applications Consider this animation, showing how the results of Vector2.dot() and Vector2.cross() change in relation to the changing angle:\nThis demonstrates two common applications of these methods. If the red vector is our object\u0026rsquo;s forward direction, and the green shows the direction towards another object:\n Dot product: Using the result, we can tell if the object is in front of (\u0026gt; 0) or behind (\u0026lt; 0) us. Cross product: Using the result, we can tell if the object is to the left (\u0026lt; 0) or right (\u0026gt; 0).  "},{"uri":"http://kidscancode.org/godot_recipes/2d/2d_draw_trajectory/","title":"Draw trajectory","tags":[],"description":"","content":"Problem You want to draw the trajectory of a ballistic shot, like from a tank.\nSolution Setup For this example, we\u0026rsquo;re using the \u0026ldquo;Ballistic Bullet\u0026rdquo; from this recipe:\n Ballistic bullet  and a tank set up like so, with a Position2D designating the \u0026ldquo;muzzle\u0026rdquo; where the bullet will be spawned:\nIn the tank\u0026rsquo;s script, we instance the bullet like so:\nfunc _unhandled_input(event):\rif event.is_action_released(\u0026#34;shoot\u0026#34;) and can_shoot:\rvar b = Bullet.instance()\rowner.add_child(b)\rb.transform = $Barrel/Muzzle.global_transform\rb.velocity = b.transform.x * muzzle_velocity\rb.gravity = gravity\rcan_shoot = false\rThis instances the bullet, adds it as a child to the \u0026ldquo;world\u0026rdquo; node (the tank\u0026rsquo;s owner) and sets its initial properties. Note that we\u0026rsquo;re using the tank to define gravity, but that\u0026rsquo;s just for this example - in a full project you would likely use a global value for this.\nHere\u0026rsquo;s our starting setup in action:\nLine setup In the main scene, which contains the tank and the ground, we\u0026rsquo;ve added a Line2D. This is what we\u0026rsquo;ll use to draw the trajectory.\nTo improve the line\u0026rsquo;s appearance, we\u0026rsquo;ve set the Width to 15 and all of the Capping options to \u0026ldquo;Round\u0026rdquo;. We\u0026rsquo;ve also added a Gradient in the Fill section:\nDrawing the line Now we\u0026rsquo;re ready to draw the line. The goal will be to move along the projected trajectory and add points to the line as we go. Since we know the starting velocity and the gravity that the bullet is using, we can use the same calculation.\nonready var tank = $Tank\ronready var muzzle = $Tank/Barrel/Muzzle\ronready var line = $Line2D\rvar max_points = 250\rfunc update_trajectory(delta):\rline.clear_points()\rvar pos = muzzle.global_position\rvar vel = muzzle.global_transform.x * tank.muzzle_velocity\rfor i in max_points:\rline.add_point(pos)\rvel.y += tank.gravity * delta\rpos += vel * delta\rif pos.y \u0026gt; $Ground.position.y - 25:\rbreak\rfunc _process(delta):\rif Input.is_action_pressed(\u0026#34;shoot\u0026#34;):\rline.show()\rupdate_trajectory(delta)\rfunc _on_Bullet_exploded(pos):\rtank.can_shoot = true\rline.hide()\rmax_points sets the maximum number of points you want to add to the line. In the update_trajectory() function, we get the bullet\u0026rsquo;s starting position and velocity from the tank (remember, gravity is defined in the tank too, for this example). We then iterate through those points, moving the position each \u0026ldquo;step\u0026rdquo; by the same amount the bullet will move during one frame.\nWe\u0026rsquo;ve also added a break if the path contacts the position of the top of the ground, so that we don\u0026rsquo;t keep drawing in that case.\nFinally, we show/hide the line when shooting or not.\nRelated recipes  2D shooting recipe 2D ballistic bullet  "},{"uri":"http://kidscancode.org/godot_recipes/ui/radial_menu/","title":"Radial Popup Menu","tags":[],"description":"","content":"Problem You want a radial menu - a ring of buttons that pops up for you to choose an option.\nSolution Radial menus are used in a variety of games to allow access to a selection of buttons. For example, clicking on an NPC in a game allows you to choose what action to take: talk, inspect, attack, etc.\nThe specific look-and-feel of your menu should match with your game\u0026rsquo;s esthetic. For this demo, we\u0026rsquo;ll focus on the mechanics of making the menu work, and leave the styling choices to you.\nHere\u0026rsquo;s the node setup:\nWe\u0026rsquo;re using a TextureButton as our root node. This is the button you\u0026rsquo;ll click to open/close the menu.\nThe \u0026ldquo;Buttons\u0026rdquo; Control node is the container where you\u0026rsquo;ll place any number of items that you want. For this example, we\u0026rsquo;re using some buttons from our Cooldown Button recipe.\nFinally, we have a Tween to handle animating the menu opening/closing.\nNow, let\u0026rsquo;s look at the script for the button:\nextends TextureButton\rexport var radius = 120\rexport var speed = 0.25\rvar num\rvar active = false\rHere are our variables. radius represents the \u0026ldquo;size\u0026rdquo; of the menu: the radius of the circle. speed is for the animation - smaller numbers are faster.\nnum keeps track of how many buttons there are, while active is a flag to track whether the menu is open or closed.\nfunc _ready():\r$Buttons.hide()\rnum = $Buttons.get_child_count()\rfor b in $Buttons.get_children():\rb.rect_position = rect_position\rIn _ready() we start setting things up: hiding the menu buttons by default, and setting their positions to that of the main button.\nNow connect the pressed signal of the main button, and the tween_all_completed signal of the Tween.\nfunc _on_StartButton_pressed():\rdisabled = true\rif active:\rhide_menu()\relse:\rshow_menu()\rClicking the button show/hides the menu. We also need to disable the button, or else clicking again while the tween is playing would restart it.\nfunc _on_Tween_tween_all_completed():\rdisabled = false\ractive = not active\rif not active:\r$Buttons.hide()\rWhen the tween animation finishes, toggle the active state and enable the button again.\nLet\u0026rsquo;s look at the show_menu() function:\nfunc show_menu():\rvar spacing = TAU / num\rfor b in $Buttons.get_children():\r# Subtract PI/2 to align the first button to the top\r var a = spacing * b.get_position_in_parent() - PI / 2\rvar dest = b.rect_position + Vector2(radius, 0).rotated(a)\r$Tween.interpolate_property(b, \u0026#34;rect_position\u0026#34;,\rb.rect_position, dest, speed,\rTween.TRANS_BACK, Tween.EASE_OUT)\r$Tween.interpolate_property(b, \u0026#34;rect_scale\u0026#34;,\rVector2(0.5, 0.5), Vector2.ONE, speed,\rTween.TRANS_LINEAR)\r$Buttons.show()\r$Tween.start()\rIn this function we calculate the angle we need between each item (spacing). We then loop through each button and find its destination (dest) based on this angle and the chosen radius. For each button, we\u0026rsquo;re tweening two properties, rect_position and rect_scale, to get our desired effect.\nhide_menu() performs the exact opposite function:\nfunc hide_menu():\rfor b in $Buttons.get_children():\r$Tween.interpolate_property(b, \u0026#34;rect_position\u0026#34;, b.rect_position,\rrect_position, speed, Tween.TRANS_BACK, Tween.EASE_IN)\r$Tween.interpolate_property(b, \u0026#34;rect_scale\u0026#34;, null,\rVector2(0.5, 0.5), speed, Tween.TRANS_LINEAR)\r$Tween.start()\rHere\u0026rsquo;s the end result:\nDownload the project file here: ui_radial_menu.zip\n\rRelated recipes  UI: Cooldown Button  "},{"uri":"http://kidscancode.org/godot_recipes/3d/3d_align_surface/","title":"KinematicBody: align with surface","tags":[],"description":"","content":"Problem You need your kinematic body to align with the surface or terrain.\nSolution This recipe builds on the basic KinematicBody controller described in the KinematicBody: Movement recipe, so read that one first.\nFirst, we\u0026rsquo;ve added some terrain to the scene. You can download the terrain from here: https://fertile-soil-productions.itch.io/modular-terrain-pack. This is low-poly terrain, but you can use or make any terrain you like for this technique.\nAs you can see, the movement still works with the terrain, but the tank seems to \u0026ldquo;float\u0026rdquo; above the slopes because it doesn\u0026rsquo;t change its orientation.\n\nInstead, we need to rotate the tank so that its treads are aligned with the ground, even as the slope changes. To do that, we need to know which way is up.\nSurface normals A surface normal is a unit vector (\u0026ldquo;normal vector\u0026rdquo; and \u0026ldquo;unit vector\u0026rdquo; mean the same thing) perpendicular to a surface. It shows which way the surface is facing. In the case of a Mesh, every surface has a normal pointing outward.\nIn Godot, when a body collides, you can get the normal of the collision. This will be the colliding body\u0026rsquo;s normal at the point of contact.\nOnce we have the surface normal, we need to align the tank\u0026rsquo;s Y axis with it. Note that we can\u0026rsquo;t use Transform.looking_at(), because that will align the -Z (forward) axis with the normal.\nTo do this, we\u0026rsquo;ll use the following function:\nfunc align_with_y(xform, new_y):\rxform.basis.y = new_y\rxform.basis.x = -xform.basis.z.cross(new_y)\rxform.basis = xform.basis.orthonormalized()\rreturn xform\rGiven a transform and a new Y direction vector, this function returns the transform rotated so that its basis.y is aligned with the given normal.\nIf you\u0026rsquo;re unfamiliar with the cross product or other vector math, there\u0026rsquo;s a great vector math intro in the Godot Docs.\n\rWe can update the tank\u0026rsquo;s movement code to call this function when it collides with a surface:\nfunc _physics_process(delta):\rvelocity += gravity * delta\rget_input(delta)\rvelocity = move_and_slide_with_snap(velocity, Vector3.DOWN*2, Vector3.UP, true)\rfor i in get_slide_count():\rvar c = get_slide_collision(i)\rglobal_transform = align_with_y(global_transform, c.normal)\rThis doesn\u0026rsquo;t work quite as expected:\n\nThe problem is that the tank\u0026rsquo;s collision shape could be colliding with more than one of the terrain\u0026rsquo;s faces. Also, move_and_slide() can result in more than one collision in a single frame. This leads to the jittering. We need to choose one face and stick with it.\nAdd a RayCast child to the tank and set its Cast To to (0, -2, 0). Don\u0026rsquo;t forget to check the Enabled property.\nSince this raycast is pointing down from the exact center of the tank, we\u0026rsquo;ll align with the individual surface that it collides with - the one directly beneath the tank.\nfunc _physics_process(delta):\rvelocity += gravity * delta\rget_input(delta)\rvelocity = move_and_slide_with_snap(velocity, Vector3.DOWN*2, Vector3.UP, true)\rvar n = $RayCast.get_collision_normal()\rglobal_transform = align_with_y(global_transform, n)\rThis is much better, but because we are instantly snapping to the new alignment every time the tank crosses an edge, it still looks a little jarring:\n\nWe can solve this last problem by interpolating to the new transform rather than snapping immediately to it.\nfunc _physics_process(delta):\rvelocity += gravity * delta\rget_input(delta)\rvelocity = move_and_slide_with_snap(velocity, Vector3.DOWN*2, Vector3.UP, true)\rvar n = $RayCast.get_collision_normal()\rvar xform = align_with_y(global_transform, n)\rglobal_transform = global_transform.interpolate_with(xform, 0.2)\rThe result is much smoother and more pleasing:\n\nFeel free to experiment with the interpolation amount. We found 0.2 to work well in this situation, but you might find a higher or lower value works better for you.\nRelated recipes  KinematicBody: Movement Math: Interpolation Math: Transforms  Like video?   "},{"uri":"http://kidscancode.org/godot_recipes/games/","title":"Game Tutorials","tags":[],"description":"","content":" Games Demo games and tutorials.\nIn this section: \rMobile Game: Circle Jump\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/3d/kinematic_car/","title":"3D Kinematic Car","tags":[],"description":"","content":" \u0026amp;nbsp 3D Car Making a 3D car.\nIn this section: \r3D Kinematic Car: Base\r\r\r3D Kinematic Car: Traction/Drifting\r\r\r3D Kinematic Car: Chase Camera\r\r\r3D Kinematic Car: Slopes \u0026amp; Ramps\r\r\r"},{"uri":"http://kidscancode.org/godot_recipes/","title":"Home","tags":[],"description":"","content":" Godot Recipes  Godot\u0026rsquo;s nodes are your ingredients. What can you cook up?\n Are you ready to learn game development? Whether it\u0026rsquo;s as a hobby or working towards your dream career, there\u0026rsquo;s never been a better time to get started. Modern programming languages and tools have made it easier than ever to build high-quality games and distribute them to the world. One of these tools is the Godot game engine. For beginners, it offers a friendly way to learn gamedev techniques. For experienced developers, it\u0026rsquo;s a powerful, customizable and open tool for bringing your visions to life.\nOn this site you\u0026rsquo;ll find a gentle introduction to the Godot game engine, as well as a wide variety of gamedev tips and techniques. Feel free to browse the categories in the sidebar and see what catches your interest.\nIf you\u0026rsquo;re new to Godot, start here: What is Godot?.\nHow to use this site Beginners If you\u0026rsquo;re new to game development, start with the \u0026ldquo;Godot 101: Basics\u0026rdquo; section. There you\u0026rsquo;ll find an introduction to the Godot application, and a step-by-step guide to creating your first project. There is a lot of material to absorb here. Don\u0026rsquo;t feel discouraged if you feel you don\u0026rsquo;t get it at first. Repetition is the key to learning complex topics; the more you work with Godot\u0026rsquo;s features, the more familiar and easy they will start to feel.\nIt\u0026rsquo;s assumed that you have at least some general programming experience. If you\u0026rsquo;re completely new to programming, click here for tips on how to get started.\n\rExperienced Developers If you\u0026rsquo;re an experienced developer and/or you\u0026rsquo;re familiar with other modern game engine(s), feel free to explore the menu on the left. You\u0026rsquo;ll find a number of useful guides and tutorials to show you how to do things the \u0026ldquo;Godot Way\u0026rdquo;. Code samples and example projects are available for all articles.\n"},{"uri":"http://kidscancode.org/godot_recipes/recipes/godot3_inheritance/","title":"Inheritance","tags":[],"description":"","content":"In this tutorial, we\u0026rsquo;ll explore how inheritance works in Godot. You can use inheritance in Godot to reuse code and create powerful hierarchies of object and scenes in your game.\nWe\u0026rsquo;ll imagine we\u0026rsquo;re making a classic top-down RPG and use Godot\u0026rsquo;s inheritance capabilities to create two different kinds of characters in the game.\nIntroduction In object oriented programming (OOP), inheritance is a powerful tool. Put briefly, you can define a class that inherits from another class. An object created using the first class will contain the methods and member variables of the \u0026ldquo;master\u0026rdquo; class as well as its own.\nGodot is strongly object-oriented, and offers the opportunity to use inheritance not just with objects (scripts) but also with scenes.\nHere\u0026rsquo;s a preview of what we\u0026rsquo;re making:\nThe green character is controlled by the player, and the other characters are NPCs, walking around the tile-based map semi-randomly.\nProject setup In Project Settings create four new input actions called \u0026ldquo;left\u0026rdquo;, \u0026ldquo;right\u0026rdquo;, \u0026ldquo;up\u0026rdquo;, and \u0026ldquo;down\u0026rdquo; and assign each of them to the matching arrow key. We\u0026rsquo;ll be using those names as dictionary keys, so make sure to note the spelling and capitalization.\nSet the display Width and Height to 640 by 480 (we\u0026rsquo;re using 32x32 tiles, so we don\u0026rsquo;t need much screen space for this demo).\nDownload the art (character spritesheets) and unzip it in the project folder.\nCreating Characters Both kinds of characters share a number of properties and functions:\n A spritesheet containing the 4-directional movement animations An AnimationPlayer to play the movement animations Grid-based movement (the character can only move one full \u0026ldquo;square\u0026rdquo; at a time) Collision detection with walls  We\u0026rsquo;ll start by creating a scene that will contain all of the above. Start with an Area2D and name it \u0026ldquo;Character\u0026rdquo;. Give it the following children:\n Sprite CollisionShape2D Tween (named MoveTween) AnimationPlayer  We\u0026rsquo;ll leave the Sprite without a texture for now, but in the Inspector set its Vframes and Hframes properties to 4 and 3 respectively.\nNext, create a RectangleShape2D in the collision shape and set its Extents property in the Inspector to (10, 18).\n NOTE: Because all the characters are drawn to the same scale, we can be confident that the same sized collision shape will work for all characters. If this isn\u0026rsquo;t the case with the art you\u0026rsquo;re using, you can skip setting the collision shape here and configure it later for the inherited scenes.\n Animations Create four animations in the AnimationPlayer node. Name them to match the four directions we used in the input actions. For each animation, we\u0026rsquo;re going to set the length to 0.8 and add a track for the Sprite's Frame property. The pattern for each direction is listed below. See the screenshot for an example of the end result.\n   direction frames     left 9, 10, 11, 10   down 6, 7, 8, 7   right 3, 4, 5, 4   up 0, 1, 2, 1    Collision Detection Because the characters are moving on a grid, they will either move the full amount to the next tile or not at all. This means that before moving, the character needs to check if the move is possible. Add four RayCast2D nodes and set their names and Cast To properties as follows:\n   Name Cast To     RayCastRight (32, 0)   RayCastLeft (-32, 0)   RayCastDown (0, 32)   RayCastUp (0, -32)    Make sure to set the Enabled property on each one (RayCast2Ds are disabled by default). Your final node setup should look something like this:\nCharacter Script Now add a script to the Character node (it will automatically be named \u0026ldquo;Character.gd\u0026rdquo;).\nFirst, we\u0026rsquo;ll define our class variables:\nextends Area2D\rvar tile_size = 32\rvar can_move = true\rvar facing = \u0026#39;right\u0026#39;\rvar moves = {\u0026#39;right\u0026#39;: Vector2(1, 0),\r\u0026#39;left\u0026#39;: Vector2(-1, 0),\r\u0026#39;up\u0026#39;: Vector2(0, -1),\r\u0026#39;down\u0026#39;: Vector2(0, 1)}\rvar raycasts = {\u0026#39;right\u0026#39;: \u0026#39;RayCastRight\u0026#39;,\r\u0026#39;left\u0026#39;: \u0026#39;RayCastLeft\u0026#39;,\r\u0026#39;up\u0026#39;: \u0026#39;RayCastUp\u0026#39;,\r\u0026#39;down\u0026#39;: \u0026#39;RayCastDown\u0026#39;}\r can_move is a flag that will track whether the character can move. It will be false while a movement is already underway. facing is the current direction of movement. Note that the moves and raycasts dictionaries\u0026rsquo; keys match the input actions we created.\nNext is the code that will execute a movement from one square to another:\nfunc move(dir):\rif get_node(raycasts[facing]).is_colliding():\rreturn\rfacing = dir\rcan_move = false\r$AnimationPlayer.play(facing)\r$MoveTween.interpolate_property(self, \u0026#34;position\u0026#34;, position,\rposition + moves[facing] * tile_size, 0.8,\rTween.TRANS_SINE, Tween.EASE_IN_OUT)\r$MoveTween.start()\rreturn true We pass a direction to move(). If the RayCast2D for that direction detects a collision, the move is canceled. Otherwise, we change facing to that direction, disable movement, and start playing the matching animation. To actually execute the movement, we use the Tween node to interpolate the position property from its current value to its current value plus a 32-pixel movement in the given direction. The duration is set to 0.8 which matches the animation length.\n Note: See the Tween documentation for details on how the interpolate_property() method works.\n Finally, to enable movement again, we need to reset can_move when the movement has finished. Connect the tween_completed signal from MoveTween and add the following:\nfunc _on_MoveTween_tween_completed( object, key ):\rcan_move = true Implementing the Player The player character needs to inherit all the properties we gave to Character as well as adding keyboard controlled movement.\nWe\u0026rsquo;ll start by making a new scene. However, instead of making a new empty scene, click on Scene -\u0026gt; New Inherited Scene in the menu. Select the Character.tscn. Rename the root node from \u0026ldquo;Character\u0026rdquo; to \u0026ldquo;Player\u0026rdquo; and save the new scene.\nAll we need to do for the Sprite is set the texture, so choose a character you like from the \u0026ldquo;res://art/rpgsprites1\u0026rdquo; folder and drag it to the Texture property.\nNext, we need a new script for the player, so remove the attached one (\u0026ldquo;Character.gd\u0026rdquo;) and attach a new one. In the \u0026ldquo;Attach Node Script\u0026rdquo; dialog, click the folder icon next to the Inherits option and choose \u0026ldquo;Character.gd\u0026rdquo;.\nHere\u0026rsquo;s our player script (note that it extends the character script):\nextends \u0026#34;res://Character.gd\u0026#34;\rfunc _process(delta):\rif can_move:\rfor dir in moves.keys():\rif Input.is_action_pressed(dir):\rmove(dir)\rBecause we\u0026rsquo;ve inherited all the behavior from \u0026ldquo;Character.gd\u0026rdquo;, we only need to worry about control. Here, we\u0026rsquo;re using the _process() function to check the keystate each frame. However, only if can_move allows it do we actually check the keys and call move().\nRun the scene and try it out.\nNPC characters Hopefully you\u0026rsquo;re seeing how inheritance works by now, but let\u0026rsquo;s make another type of character: an NPC that will wander around the screen randomly. Make another scene inheriting from \u0026ldquo;Character.tscn\u0026rdquo; and name it NPC.\nThis time, leave the sprite\u0026rsquo;s Texture blank and add a new script, again inheriting from \u0026ldquo;Character.gd\u0026rdquo;.\nextends \u0026#34;res://Character.gd\u0026#34;\rvar textures = [\u0026#39;mage_f.png\u0026#39;, \u0026#39;mage_m.png\u0026#39;,\r\u0026#39;healer_f.png\u0026#39;, \u0026#39;healer_m.png\u0026#39;,\r\u0026#39;townfolk1_f.png\u0026#39;, \u0026#39;townfolk1_m.png\u0026#39;]\rfunc _ready():\rrandomize()\rvar texture = textures[randi() % textures.size()]\rtexture = load(\u0026#34;res://art/rpgsprites1/%s\u0026#34; % texture)\r$Sprite.texture = texture\rfacing = moves.keys()[randi() % 4]\rfunc _process(delta):\rif can_move:\rif not move(facing) or randi() % 10 \u0026gt; 5:\rfacing = moves.keys()[randi() % 4] This time, we\u0026rsquo;re using _ready() to select a random texture and assign it. We\u0026rsquo;re also choosing a random starting direction.\nAs with the player, we\u0026rsquo;ll use _process() to trigger the movement, but this time we\u0026rsquo;ll use the fact that the move() function returns true if it successfully executes (if the raycast detects an obstacle, it returns false). So if the NPC can\u0026rsquo;t move, it will pick a new random direction. For variety, we also add a 50% chance that it will change direction anyway.\nRun the scene and observe the NPC wandering randomly around the screen.\nTesting Collisions Finally, to confirm that the collision detection is working, let\u0026rsquo;s create a small scene for the characters to wander around in. We\u0026rsquo;ll use a TileMap to quickly draw our map.\n Note: See my Tilemap tutorial for details on using TileMaps in Godot.\n There are two tiles (\u0026ldquo;grass.png\u0026rdquo; and \u0026ldquo;stone.png\u0026rdquo;) in the art folder. There is also a TileSet called \u0026ldquo;tiles.tres\u0026rdquo; to save you the step of making your own. In it, only the stone tile has a collision shape, so it will be our obstacle.\nCreate a new \u0026ldquo;Main\u0026rdquo; scene (I usually like to use a plain Node as the root). Add a TileMap and drag \u0026ldquo;tileset.tres\u0026rdquo; into its Tile Set property. Also don\u0026rsquo;t forget to change the Size to (32, 32).\nDraw some walls as you like, and then add a Player instance and a few instances of NPC. Remember, the characters won\u0026rsquo;t know anything about the map - they just know if they can move one tile or not. If you want them to line up properly, you need to make sure the characters\u0026rsquo; starting positions are centered on a tile. This is easy to do if you turn on \u0026ldquo;Snap to Grid\u0026rdquo;. Click the \u0026ldquo;Use Snap\u0026rdquo; button and then open the grid menu by clicking on the three dots next to it:\nUnder \u0026ldquo;Configure Snap\u0026hellip;\u0026rdquo; set the Grid Step and Grid Offset:\nNow you can drag the instanced characters around and they\u0026rsquo;ll always snap to the center of a tile.\nConclusion Imagine we had built this project without using inheritance. The Player and NPC would each have their own scene setup and individual scripts. If we decided to change how we wanted movement to work, we would have to change everything twice. If we added more character types (Monsters, Pets, etc.) the duplicated code would multiply and quickly become unmanageable. With the setup we created above, everything is in one place, and any change to the character automatically propagates to everything that extends it.\nAs you\u0026rsquo;re working on your own projects, look for opportunities to consolidate code and use inheritance for your scenes and/or scripts. As your projects grow in size and complexity, it will quickly become a lifesaver.\n"},{"uri":"http://kidscancode.org/godot_recipes/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"http://kidscancode.org/godot_recipes/tags/","title":"Tags","tags":[],"description":"","content":""}]